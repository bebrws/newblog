{"pageProps":{"title":"Reverse engineering an iOS application to allow for integration with shortcuts and Siri - Recreate AWS Cognito authentication and sending fake UITouch events","dateString":"2023-05-12","slug":"ios-aws-cognito-reverse-engineering","description":"","tags":["Reverse engineering","iOS","aws","cognito","frida","lldb","osx","Siri","shortcuts","UITouch","SwiftUI","Deep linking","IOS URLScheme"],"author":"bebrws","source":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Stuck With a Smart Lock That Only Works With Google or Alexa? Let's Fix That!\"), mdx(\"p\", null, \"I really should have written this up sooner so it was still fresh in my head. Sorry this is a bit of a mess of information but the AWS Cognito example might be useful to some. And the Frida Gadget scripting to add a URLScheme could be helpful.\"), mdx(\"p\", null, \"I am going to make another post for how I was able to use a library by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/lyft/Hammer\"\n  }, \"Lyft called Hammer\"), \" to send fake UITouch events as well next.. and maybe one on just all the lldb commands I learned and what I thought was really helpful.\"), mdx(\"h2\", null, \"Introduction - IOS URLScheme and Frida and some lldb\"), mdx(\"p\", null, \"So for my safety I will try to obscure company names and info as much as possible. Although I don't think I did anything wrong? I'm honestly not sure where the line is drawn on what is legal with stuff like this.\"), mdx(\"p\", null, \"So I moved into a new apartment with a smart lock that has an iOS app which is nice. But it takes a while to load the app and then press the button to lock and unlock the door and I really just wanted to be able to tell Siri to do it if I had full hands... And I love poking around iOS anyways.\"), mdx(\"p\", null, \"I will try to go through my process in the order I went in (mostly) becuase I learned a lot along the way. Recreating this blog post from my notes.\"), mdx(\"p\", null, \"The summary would be that, as someone suggested, the easy way to do something like this is definately to just sniff the network traffic and recreate it. But I wanted to learn more about iOS and how to reverse engineer it so I went the hard way at first.\"), mdx(\"p\", null, \"So originally, I started did use software like Charles Proxy basically to look at the network traffic. And what did I find?\"), mdx(\"p\", null, \"A really nice simple JSON API that uses a JWT token for auth to lock and unlock the door.\"), mdx(\"p\", null, \"So to show how easy it looked at first to use this API here is a curl showing me using the API to lock the door:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"curl -X PATCH \\\"https://$SOMECOMPANYID.execute-api.us-east-1.amazonaws.com/prod_v1/devices/$PROBMYDEVICEID/status\\\" -H \\\"User-Agent: AppName/5 CFNetwork/1404.0.5 Darwin/22.3.0\\\" -H \\\"Content-Type: application/json\\\" -H \\\"Accept: application/json\\\" -H \\\"Accept-Language: en-US,en;q=0.9\\\" -H \\\"Authorization: Bearer $KBEARER\\\" -H \\\"Accept-Encoding: gzip, deflate, br\\\" -d \\\"{\\\\\\\"action\\\\\\\": \\\\\\\"lock\\\\\\\", \\\\\\\"source\\\\\\\": \\\\\\\"{\\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"$MYNAME\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"device\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"iPhone\\\\\\\\\\\\\\\"}\\\\\\\"}\\\"\\n\")), mdx(\"p\", null, \"So all I need to do is send the JSON below to some URL with an AUTH token basically.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"{\\\"action\\\": \\\"lock\\\", \\\"source\\\": \\\"{\\\\\\\"name\\\\\\\":\\\\\\\"Brad\\\\\\\",\\\\\\\"device\\\\\\\":\\\\\\\"iPhone\\\\\\\"}\\\"}\\n\")), mdx(\"p\", null, \"Now I did poke around the rest of the HTTPS traffic I intercepted and saw that there were multiple requests before this. And one of them contained the AUTH token. So I knew right away there was some process happening to get the JWT that was unfortunely looking a little complicated.\"), mdx(\"p\", null, \"So at first I was hoping I could just find some object in the heap that contained the AUTH token and use that via Frida (and it's oh so amazing API with functionality like pulling all objects of any type from memory!). But all the AUTH tokens I was finding were not working.\"), mdx(\"p\", null, \"I should also mention that my original plan was to add an IOS URLScheme to the application so I could just create a Shortcut Siri would use that would open a URL to lock and unlock my door.\"), mdx(\"p\", null, \"At first I tried a number of things. Like how I used create iOS tweaks. Making a custom dylib in xCode and I manually add to the main executable using install_name_tool that swizzles it's way into whatever new functionality I want.\"), mdx(\"p\", null, \"For those thay may need an explanation. A dylib is a dynamically linked library. Meaning it is a binary that the operating system or really dyld will load into memory when an application starts.\"), mdx(\"p\", null, \"So I needed a decrypted copy of the application I was going to be modifying/debugging/etc. There are some websites that actually provide this service and work which was surprising but I did find my old iPhone 6s and was able to use Checkra!n and PAlera1n on an iPhone 7 to get them jailbroken. At this point what worked best for me was \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/AloneMonkey/frida-ios-dump\"\n  }, \"frida-ios-dump\")), mdx(\"p\", null, \"Note that instead of having to install usbmuxd/iproxy at this point, if your on the same network you can just use the ip address:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"./dump.py -H 192.168.1.87 -p 22 AppName\\n\")), mdx(\"p\", null, \"NOTE: From here on out I'll just refer to the iOS app as AppName\"), mdx(\"p\", null, \"After running this dump you should end up with an unencrypted \\\".ipa\\\" file in the same folder. A ipa file type is a zip file that contains the application and all of it's data/metadata.\"), mdx(\"p\", null, \"So you can change the extension from .ipa to .zip. And unzip it right there.\"), mdx(\"p\", null, \"Inside will be a folder named Payload. And inside there will be AppName.App.\"), mdx(\"p\", null, \"Now just like a .App on OSX you can right click and show package contents to see what all the app really contains.\"), mdx(\"p\", null, \"Now the most important file will be the binary itself. Which normally is also named AppName (no file extension) and will be an amr64 binary built for iOS.\"), mdx(\"p\", null, \"There is also a Frameworks folder which will contain a number of frameworks, from my understanding basically just dylibs with a lot more information like header files, that the binary loads at runtime.\"), mdx(\"p\", null, \"So any executable will have a list of dynamically linked libraries it loads at runtime. You can list those with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"otool -L $EXE_NAME_HERE\\n\")), mdx(\"p\", null, \"or to get a more detailed breakdown that includes information such as the path where the binary will look for the dylibs:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"otool -l $EXE_NAME_HERE\\n\")), mdx(\"p\", null, \"It is important to use the lowercase -l version so you can see where rpath points to in some cases. I believe in most cases it will just be the Frameworks directoy.\\nSo if you are going to add your own dylib you could for example use a tool like \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tyilo/insert_dylib\"\n  }, \"insert_dylib\"), \".\"), mdx(\"p\", null, \"For example, I build my own DYLIB which was at first, attempting to swizzle the older handleURL methods on iOS AppDelegate (this no longer works btw)..\"), mdx(\"p\", null, \"But to insert your dylib you would do somethign like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"insert_dylib --strip-codesig --inplace '@executable_path/Frameworks/libhandleURLSwizzleObjC.dylib' ~/Payload/AppName.app/AppName\\ncp ~/libhandleURLSwizzleObjC.dylib ~/Payload/AppName.app/Frameworks\\n\")), mdx(\"p\", null, \"And in your dylib code (you can create a dylib in xcode by creating a static library, and then going to build options and changing the library type to dynamic, you may also want to change the extension from .a to .dylib as well) you will want to add a constructor function.\"), mdx(\"p\", null, \"This function is what gets called when the dylib is loaded into memory and is your chance to \\\"swizzle\\\" or replace existing functions with your own. This way you can add/modify existing functionality in an application.\"), mdx(\"p\", null, \"And these days you just use this tool called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/sensepost/objection\"\n  }, \"objection\"), \" to then handle signing everything and converting your Payload folder into an ipa for you.\"), mdx(\"p\", null, \"And then another tool \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/ios-control/ios-deploy\"\n  }, \"ios-deploy\"), \" to send the app to your iPhone. Jailbroken or not. And start a debugging session with lldb. And Objection by default injects frida so you have can connect to frida and poke around as well!\"), mdx(\"p\", null, \"It is all very user friendly as pretty easy to get started with.\"), mdx(\"h2\", null, \"Getting IOS URLScheme to Work\"), mdx(\"p\", null, \"Even though I didn't end up going this route I finaly figured out a cool way to make it work and wanted to document it. So with the newer iOS SDKs and SwiftUI and all the older handleURL method on AppDelegate is no longer called I beleive with a URLScheme.\"), mdx(\"p\", null, \"First off I needed to update my iOS apps plist file though so it would handle urls. Like AppName://unlockdoor\"), mdx(\"p\", null, \"To do so I scripted:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"head -n4 ~/Payload/AppName.app/Info.plist > ~/Payload/AppName.app/Info.plist-2\\necho \\\"\\\"\\\"    <key>CFBundleURLTypes</key>\\n    <array>\\n        <dict>\\n            <key>CFBundleURLSchemes</key>\\n            <array>\\n                <string>AppName</string>\\n            </array>\\n            <key>CFBundleURLName</key>\\n            <string>com.AppName.ble-wifi</string>\\n        </dict>\\n    </array>\\\"\\\"\\\" >> ~/Payload/AppName.app/Info.plist-2\\ntail -n+5 ~/Payload/AppName.app/Info.plist >> ~/Payload/AppName.app/Info.plist-2\\nmv ~/Payload/AppName.app/Info.plist-2 ~/Payload/AppName.app/Info.plist\\n\")), mdx(\"p\", null, \"The important part is that the CFBundleURLSchemes contains the string for the url proto if I remember right and then the CFBundleURLName has to have the same Bundle of the App.\\nThere is a lot of documentation on this part too so I won't go into too much detail here.\"), mdx(\"p\", null, \"What I think is really cool is that the Frida Gadget, the Frida dylib, that is injected into the App will look for a script to run. So you can create apps with Frida injected and a script included in the Payload/App folder so that you don't need to write a dylib in objective-c or something and can create deployable packagable apps using Frida for tweaks! Pretty amazing.\"), mdx(\"p\", null, \"The documentation for \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://frida.re/docs/gadget/\"\n  }, \"Frida Gadgets is here\"), \". Definately check that out. It's a great feature I never knew about.\"), mdx(\"p\", null, \"So along with using this feature or Frida I ended up figuring out which method I needed to implement to handle IOS URLSchemes with ios 15.7.2 and probably later.\"), mdx(\"p\", null, \"You have to find the UIWindowScene and add a method \\\"- scene:openURLContexts:\\\". This is actually what is trigger with IOS URLSchemes on these newer iOS versions.\"), mdx(\"p\", null, \"I have a super hacky way of finding the UIWindowScene.. and I don't know why I didn't just use ObjC.choose or something.. But this is my Frida Gagdet script:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"rpc.exports = {\\n    init(stage, parameters) {\\n        console.error('[init]', stage, JSON.stringify(parameters));\\n\\n        var globalar = null;\\n\\n        var NSLog = new NativeFunction(Module.findExportByName('Foundation', 'NSLog'), 'void', ['pointer', '...']);\\n        var NSString = ObjC.classes.NSString;\\n        var str = NSString.stringWithFormat_(\\\"[*] BRAD IN FRIDA GADGET\\\");\\n        NSLog(str);\\n        console.error(\\\"[*] BRAD IN FRIDA GADGET\\\");\\n\\n\\n        var NSJSONSerialization = ObjC.classes.NSJSONSerialization;\\n        var NSUTF8StringEncoding = 4;\\n\\n        var NSURL = ObjC.classes.NSURL;\\n        // var NSError = ObjC.classes.NSError;\\n\\n        function convertNSObjectToJSString(obj) {\\n            var valid = NSJSONSerialization.isValidJSONObject_(obj);\\n            if (!valid) return null;\\n            const NSJSONWritingPrettyPrinted = 1;\\n            var errorPtr = Memory.alloc(Process.pointerSize);\\n            Memory.writePointer(errorPtr, NULL); // initialize to NULL\\n            var data = NSJSONSerialization.dataWithJSONObject_options_error_(obj, NSJSONWritingPrettyPrinted, errorPtr);\\n            var error = Memory.readPointer(errorPtr);\\n            if (error.isNull()) {\\n                var str = NSString.alloc().initWithData_encoding_(data, NSUTF8StringEncoding);\\n                return str.toString();\\n            } else {\\n                var errorObj = new ObjC.Object(error); // now you can treat errorObj as an NSError instance\\n                console.error(errorObj.toString());\\n                return null;\\n            }\\n        }\\n\\n\\n        function getCurrentJWT() {\\n            var awsMobileClientPtr = Number(ObjC.chooseSync(ObjC.classes[\\\"AWSMobileClient.AWSMobileClient\\\"])[0].handle);\\n            var awsMobileClientDictPtrStr = Number(awsMobileClientPtr + 0x0000000000000088).toString(16);\\n            var awsMobileClientDictPtr = new NativePointer(\\\"0x\\\" + awsMobileClientDictPtrStr);\\n            var dictPtr = awsMobileClientDictPtr.readPointer()\\n            var dictObj = new ObjC.Object(dictPtr);\\n            var dstr = dictObj.toString();\\n            console.error(\\\"String argument: \\\" + dstr);\\n            var regex = /.*(\\\"eyJ.*\\\").*/;\\n            var jwt = JSON.parse(dstr.match(regex)[1]);\\n            return jwt;\\n        }\\n\\n        function lockUnlockDoor(action) {\\n            var jwt = getCurrentJWT();\\n            console.error(\\\"Got JWT: \\\" + jwt);\\n\\n            var actionParsed = (action == \\\"lock\\\" || action == \\\"unlock\\\") ? action : \\\"lock\\\";\\n            var url = \\\"https://SOMECOMPANYID.execute-api.us-east-1.amazonaws.com/prod_v1/devices/PROBMYDEVICEID/status\\\";\\n            var nsurl = NSURL.alloc().initWithString_(url);\\n            var urlRequest = ObjC.classes.NSMutableURLRequest.alloc().initWithURL_(nsurl);\\n\\n            var actString = \\\"{\\\\\\\"action\\\\\\\": \\\\\\\"\\\" + actionParsed + \\\"\\\\\\\", \\\\\\\"source\\\\\\\": \\\\\\\"{\\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Brad\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"device\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"iPhone\\\\\\\\\\\\\\\"}\\\\\\\"}\\\";\\n            console.error(`\\\\n\\\\nBEB - actString: ${actString} ${actString.length}\\\\n\\\\n`);\\n            var userUpdate = NSString.stringWithFormat_(actString);\\n            console.error(`\\\\n\\\\nBEB - userUpdate: ${userUpdate.toString()} ${userUpdate.length()}\\\\n\\\\n`);\\n\\n            urlRequest.setHTTPMethod_(\\\"PATCH\\\");\\n            urlRequest.setValue_forHTTPHeaderField_(\\\"Bearer \\\" + jwt, \\\"Authorization\\\");\\n            urlRequest.setValue_forHTTPHeaderField_(`${actString.length}`, \\\"Content-Length\\\");\\n            urlRequest.setValue_forHTTPHeaderField_(\\\"application/json\\\", \\\"Content-Type\\\");\\n            urlRequest.setValue_forHTTPHeaderField_(\\\"application/json\\\", \\\"Accept\\\");\\n            urlRequest.setValue_forHTTPHeaderField_(\\\"en-US,en;q=0.9\\\", \\\"Accept-Language\\\");\\n            urlRequest.setValue_forHTTPHeaderField_(\\\"gzip, deflate, br\\\", \\\"Accept-Encoding\\\");\\n            urlRequest.setValue_forHTTPHeaderField_(\\\"appName/5 CFNetwork/1404.0.5 Darwin/22.3.0\\\", \\\"User-Agent\\\");\\n            urlRequest.setValue_forHTTPHeaderField_(\\\"keep-alive\\\", \\\"Connection\\\");\\n\\n            var data1 = userUpdate.dataUsingEncoding_(NSUTF8StringEncoding);\\n\\n            urlRequest.setHTTPBody_(data1);\\n\\n            var session = ObjC.classes.NSURLSession.sharedSession();\\n\\n            console.error(\\\"Setup request and is about to make it\\\");\\n            var dataTask = session.dataTaskWithRequest_completionHandler_(urlRequest, new ObjC.Block({\\n                retType: 'void',\\n                argTypes: ['pointer', 'pointer', 'pointer'],\\n                implementation: function (data, response, error) {\\n                    var dataStr = NSString.alloc().initWithData_encoding_(data, NSUTF8StringEncoding);\\n                    var respObj = new ObjC.Object(response);\\n                    var errorObj = new ObjC.Object(error);\\n                    console.error(\\\"data: \\\", dataStr);\\n                    console.error(\\\"response code: \\\", respObj.statusCode());\\n                    console.error(\\\"error: \\\", errorObj.toString());\\n\\n                    // var respObj = new ObjC.Object(response);\\n                    // console.error(\\\"data as JSON string: \\\", convertNSObjectToJSString(data));\\n\\n                }\\n            }));\\n            dataTask.resume();\\n        }\\n\\n\\n        function setIntercept() {\\n            var scenes = ObjC.classes.UIApplication.sharedApplication().connectedScenes();\\n\\n            var winSceneRegex = /UIWindowScene: (0x[a-fA-F0-9]+)/\\n            var scenesPtr = ptr(scenes.toString().match(winSceneRegex)[1]);\\n            var windowScene = ObjC.Object(scenesPtr);\\n            try {\\n                if (!scenes) {\\n                    console.error(\\\"Couldn't file UIWindowScene on sharedApplication\\\");\\n                } else {\\n                    Interceptor.attach(windowScene.delegate()[\\\"- scene:openURLContexts:\\\"].implementation, {\\n                        onEnter(args) {\\n                            // ObjC: args[0] = self, args[1] = selector, args[2-n] = arguments\\n                            const arg2Str = new ObjC.Object(args[2]);\\n                            console.error(\\\"String argument: \\\" + arg2Str.toString());\\n                            NSLog(NSString.stringWithFormat_(\\\"[*] BRAD scene:openURLContexts: argument 2: \\\" + arg2Str.toString()));\\n\\n                            const arg3Str = new ObjC.Object(args[3]);\\n                            console.error(\\\"String argument: \\\" + arg3Str.toString());\\n                            NSLog(NSString.stringWithFormat_(\\\"[*] BRAD scene:openURLContexts: argument 3: \\\" + arg3Str.toString()));\\n\\n                            globalar = arg3Str;\\n                            var appNameActionFromURLRegex = /URL: appName:\\\\/\\\\/(\\\\S+)/; ///.*URL: appName: \\\\/\\\\/([a-z]*);.*/;\\n                            console.error(arg3Str.toString().match(appNameActionFromURLRegex));\\n                            var action = arg3Str.toString().match(appNameActionFromURLRegex)[1];\\n\\n                            lockUnlockDoor(action);\\n                        }\\n                    });\\n                    console.error(\\\"[*]WindowScene() intercept placed\\\");\\n                    NSLog(NSString.stringWithFormat_(\\\"[*]WindowScene() intercept placed\\\"));\\n                }\\n            }\\n            catch (err) {\\n                console.error(\\\"[*]BRAD Exception: \\\" + err.message);\\n                NSLog(NSString.stringWithFormat_(\\\"[*]BRAD Exception: \\\" + err.message));\\n            }\\n        }\\n\\n        setTimeout(setIntercept, 1000); // IDK why I wanted to wait to add this method. I was thinking maybe it could take a while for the UIWindowScene to get created\\n        console.error(\\\"[*]BRAD SETTIMEOUT\\\");\\n        NSLog(NSString.stringWithFormat_(\\\"[*]BRAD SETTIMEOUT\\\"));\\n\\n\\n    },\\n    dispose() {\\n        console.error('[dispose]');\\n    }\\n};\\n\\n\")), mdx(\"p\", null, \"I save this as appName.js in the Frameworks folder.\"), mdx(\"p\", null, \"In the Frameworks folder I ALSO create the Frida Gadget config to run the script. It is a file named: FridaGadget.config\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"{\\n  \\\"interaction\\\": {\\n    \\\"type\\\": \\\"script\\\",\\n    \\\"path\\\": \\\"appName.js\\\",\\n    \\\"on_change\\\": \\\"reload\\\"\\n  }\\n}\\n\")), mdx(\"p\", null, \"I figure this code could be useful if someone wants to try something similar.\"), mdx(\"p\", null, \"NOTE: That if you are trying to get the JWT from AWS like I was in the code above. It probably won't work often unless the app refreshes it's token often.\"), mdx(\"p\", null, \"The app I was using DIDNT. So this route didn't work. And triggering the app to run its refresh token code was taking forever to figure out.\"), mdx(\"p\", null, \"So now back to actually getting something working.\"), mdx(\"h2\", null, \"AWS Cognito Reverse engineering\"), mdx(\"p\", null, \"So this app actually has a server that handles the requests to lock and unlock the door. And it uses AWS Cognito to handle generation and refreshing of the JWT.\"), mdx(\"p\", null, \"I couldn't find any working examples of using AWS Cognito as a client and I thought this might be helpful for someone trying to do something similar. My code maybe messy but it works and I have invested too much time in it as it is so I am calling it good.\"), mdx(\"p\", null, \"So first off. I used Frida to poke around. And I see that AWS and something called AWS Cognito is being used from the loaded Frameworks. I findout that Cognito is used for auth. Also I saw in the decoded JWT via \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://jwt.io/\"\n  }, \"https://jwt.io/\"), \" that scope of the jwt is \\\"aws.cognito.signin.user.admin\\\". So I know now that this app is using Cognito for auth.\"), mdx(\"p\", null, \"Then I think I was just using Frida's ObjC.chooseSync and grabbing objects and I found some useful information. I also was using lldb and found some information I needed later for basically re creating the AWS Cognito login flow.\"), mdx(\"p\", null, \"So when I run the iod-deploy I used the configuration that automatically starts the app and gives you an lldb session.\"), mdx(\"p\", null, \"I think I started by looking at what I could break on that was AWSCognito related with the command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"image lookup -r -n .*AWSCognito.*\\n\")), mdx(\"p\", null, \"This uses regex to search for anything AWSCognito related. Any methods on the classes that have the string AWSCognito will be listed.\"), mdx(\"p\", null, \"I think I realized by looking at other AWS Cognito client implementations that didn't work that I needed to get a few bits of information.\"), mdx(\"p\", null, \"So I set breakpoints in lldb (using Frida again would have probably been easier but I am just documenting stuff I learned here)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"breakpoint set -r '\\\\[AWSCognitoIdentityUserPoolConfiguration .*\\\\]$\\nbreakpoint set -r '\\\\[AWSCognitoIdentityUserPool .*\\\\]$\\n\")), mdx(\"p\", null, \"I am pretty sure I hit the following breakpoint:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\n  Summary: AWSAppSync`AWSAppSync.AWSCognitoUserPoolsAuthProviderAsync.getLatestAuthToken() -> Swift.String        Address: AWSAppSync[0x0000000000027200] (AWSAppSync.__TEXT.__text + 131900)\\n\")), mdx(\"p\", null, \"And then I started printing out arguments to this method call:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\npo (SEL)$arg2\\n\\npo $arg1\\n\\nexpression -l objc -O -- [$arg1 userPoolConfiguration]\\n\\nexpression -l objc -O -- [[$arg1 userPoolConfiguration] poolId]\\n\\n\")), mdx(\"p\", null, \"The last one of these got me the poolId for AWSCognito account I needed to login with to get a JWT and refresh token so I could send lock and unlock commands.\"), mdx(\"p\", null, \"NOTE: That the poolId will probably be in a format like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"us-east-1_6B31234KN\\n\")), mdx(\"p\", null, \"Then I also needed something called the clientID. This can actually be found in the requests from the HTTPS requests I dumped to JSON.\"), mdx(\"p\", null, \"I also needed to find this information which I got with Frida:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"var awsccp = [];\\nObjC.choose(ObjC.classes['AWSCognitoCredentialsProvider'], {\\n  onMatch: function (serv) {\\n    console.log('Found AWSCognitoCredentialsProvider', serv);\\n    awsccp.push(serv);\\n  },\\n  onComplete: function () {\\n    console.log('Finished AWSCognitoCredentialsProvider search');\\n  }\\n});\\n\\nconsole.log(awsccp);\\n\\n\\nconsole.log(awsccp.getIdentityId())\\n<AWSTask: 0x2867bf380; completed = YES; cancelled = NO; faulted = NO; result = us-east-1:47021234-ffff-4fff-afff-ffffbca71a1c>\\n\\n\")), mdx(\"p\", null, \"And then I had enough info to basically re create the server that the iPhone app used to send my login credentials to which would talk with AWS Cognito and get a JWT and refresh token. I wanted to have my own so that I could get a JWT whenever I want. And I found out that I can just basically refresh my JWT forever so I really just need to get that JWT and I refresh every 30 minutes I beleive it was. The code is below:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const fullUserPoolId = 'us-east-1_5F3ufo6uFF'\\nconst userPoolId = '5F3ufo6uFF'\\nconst ClientId = 'ffuabckjpfffd1ab7881m6g88s'\\nconst username = \\\"myemail@gmail.com\\\";\\nconst password = \\\"MyPassword\\\";\\n\\nimport * as AWS from 'aws-sdk';\\nimport AmazonCognitoIdentity, { CognitoRefreshToken, CognitoAccessToken } from 'amazon-cognito-identity-js';\\n\\nimport * as readline from 'node:readline/promises';\\nimport { stdin as input, stdout as output } from 'node:process';\\n\\nimport * as http from 'http';\\nimport * as url from 'url';\\n\\n\\n\\nconst rl = readline.createInterface({ input, output });\\n\\n\\n// // import type { ICognitoUserData } from 'amazon-cognito-identity-js';\\n\\n// const cognitoUserPool = ;\\n\\n// const cognitoUserData /*: ICognitoUserData*/ = {\\n//     Username: username,\\n//     Pool: cognitoUserPool,\\n//     Storage: undefined // ICognitoStorage ?\\n// }\\n\\nvar cognitoRefreshToken = null;\\nvar cognitoAccessToken = null;\\n\\nvar authenticationData = {\\n    Username: username,\\n    Password: password,\\n};\\nvar authenticationDetails = new AmazonCognitoIdentity.AuthenticationDetails(\\n    authenticationData\\n);\\nvar poolData = {\\n    UserPoolId: fullUserPoolId, // Your user pool id here\\n    ClientId: ClientId, // Your client id here\\n};\\nvar userPool = new AmazonCognitoIdentity.CognitoUserPool(poolData);\\nvar userData = {\\n    Username: username,\\n    Pool: userPool,\\n};\\nvar cognitoUser = new AmazonCognitoIdentity.CognitoUser(userData);\\n\\ncognitoUser.setAuthenticationFlowType('CUSTOM_AUTH');\\n\\n\\n\\nfunction refreshToken() {\\n    const refreshFromGlobal = (cognitoRefreshToken || process.env.APPNAME_REFRESH_TOKEN);\\n    console.log(\\\"Refreshing tokens. What I have globally and in env is:\\\", refreshFromGlobal)\\n    if (refreshFromGlobal) {\\n        cognitoUser.refreshSession(cognitoRefreshToken || new CognitoRefreshToken({ RefreshToken: process.env.APPNAME_REFRESH_TOKEN }), (err, session) => {\\n            if (err) {\\n                console.error(\\\"Error refreshing tokens\\\", err)\\n            } else {\\n                console.log(\\\"Refreshed tokens\\\", session)\\n                // SO LAME, now accessToken and refreshToken are lower case to start..\\n                const { accessToken, refreshToken } = session;\\n                if (refreshToken) {\\n                    cognitoRefreshToken = refreshToken;\\n                } else {\\n                    console.log(\\\"No refresh token after refresh\\\");\\n                }\\n                if (accessToken) {\\n                    cognitoAccessToken = accessToken;\\n                } else {\\n                    console.log(\\\"No access token after refresh\\\");\\n                }\\n            }\\n        })\\n    } else {\\n        console.error(\\\"No refresh token to refresh\\\", refreshFromGlobal)\\n    }\\n}\\n\\nfunction startHTTPServer() {\\n\\n    setInterval(() => {\\n        refreshToken();\\n    }, 1000 * 60 * 30)\\n\\n    console.log(`Starting HTTP Server`)\\n    // Configure our HTTP server to respond with Hello World to all requests.\\n    var server = http.createServer(function (request, response) {\\n        console.log(`HTTP handling request: ${request}\\\\n\\\\n\\\\n\\\\nWith response: ${response}`)\\n        //    var name=request.getParameter('name');\\n        //    console.log(name);\\n        const action = url.parse(request.url, true).query['action'];\\n        if (action) {\\n            const actionParsed = (action == 'lock' || action == 'unlock') ? action : 'lock';\\n            sendLockUnlockRequest(actionParsed).then((res) => {\\n                response.writeHead(200, { \\\"Content-Type\\\": \\\"text/plain\\\" });\\n                response.end(`Handling action for ${actionParsed}. Response: ${JSON.stringify(res)}\\\\n`);\\n            })\\n        } else {\\n            response.writeHead(500, { \\\"Content-Type\\\": \\\"text/plain\\\" });\\n            response.end(`Invalid request\\\\n`);\\n        }\\n    });\\n    // Listen on port 8000, IP defaults to 127.0.0.1\\n    server.listen(8000);\\n}\\n\\n\\nasync function sendLockUnlockRequest(action) {\\n    if (action != 'lock' && action != 'unlock') {\\n        console.error(`Invalid action: ${action} sent to sendLockUnlockRequest`);\\n        return\\n    }\\n\\n    console.log(\\\"Makeing request with:\\\", {\\n        method: \\\"PATCH\\\", // *GET, POST, PUT, DELETE, etc.\\n        headers: {\\n            'Accept': 'application/json',\\n            'Accept-Language': 'en-US,en;q=0.9',\\n            'Authorization': `Bearer ${cognitoAccessToken.getJwtToken()}`,\\n            'Accept-Encoding': 'gzip, deflate, br'\\n        },\\n        body: \\\"{\\\\\\\"action\\\\\\\": \\\\\\\"\\\" + action + \\\"\\\\\\\", \\\\\\\"source\\\\\\\": \\\\\\\"{\\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Brad\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"device\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"iPhone\\\\\\\\\\\\\\\"}\\\\\\\"}\\\"\\n    });\\n    console.log(\\\"body: \\\", \\\"{\\\\\\\"action\\\\\\\": \\\\\\\"\\\" + action + \\\"\\\\\\\", \\\\\\\"source\\\\\\\": \\\\\\\"{\\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Brad\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"device\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"iPhone\\\\\\\\\\\\\\\"}\\\\\\\"}\\\")\\n    const response = await fetch('https://COMPANYID.execute-api.us-east-1.amazonaws.com/prod_v1/devices/PROBMYDEVICEID/status', {\\n        method: \\\"PATCH\\\", // *GET, POST, PUT, DELETE, etc.\\n        headers: {\\n            'Accept': 'application/json',\\n            'Accept-Language': 'en-US,en;q=0.9',\\n            'Authorization': `Bearer ${cognitoAccessToken.getJwtToken()}`,\\n            'Accept-Encoding': 'gzip, deflate, br'\\n        },\\n        body: `{\\\"action\\\": \\\"${action}\\\", \\\"source\\\": \\\"{\\\\\\\\\\\"name\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Bradley\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"device\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"iPhone\\\\\\\\\\\\\\\"}\\\"}`\\n    });\\n    const responseFromAppName = await response.json();\\n    console.log(\\\"response from lock/unlock:\\\", responseFromAppName);\\n    return responseFromAppName;\\n}\\n\\nasync function emailAuthCode(smsCode) {\\n    return new Promise((resolve, reject) => {\\n        cognitoUser.sendCustomChallengeAnswer('answerType:verifyCode,medium:phone,codeType:login,code:' + smsCode, {\\n            mfaRequired: function (result) {\\n                console.log(\\\"result from mfaRequired 2:\\\", result);\\n            },\\n            selectMFAType: function (result) {\\n                console.log(\\\"result from selectMFAType 2:\\\", result);\\n            },\\n            mfaSetup: function (result) {\\n                console.log(\\\"result from mfaSetup 2:\\\", result);\\n            },\\n            totpRequired: function (result) {\\n                console.log(\\\"result from totpRequired 2:\\\", result);\\n            },\\n            newPasswordRequired: function (result) {\\n                console.log(\\\"result from newPasswordRequired 2:\\\", result);\\n            },\\n            associateSecretCode: function (result) {\\n                console.log(\\\"result from associateSecretCode 2:\\\", result);\\n            },\\n            inputVerificationCode: function (result) {\\n                console.log(\\\"result from inputVerificationCode 2:\\\", result);\\n            },\\n            associateSecretCode: function (result) {\\n                console.log(\\\"result from associateSecretCode 2:\\\", result);\\n            },\\n            onSuccess: function (cognitoUserSession) {\\n                console.log(\\\"result from sending Custom Answer 2:\\\", cognitoUserSession);\\n                cognitoAccessToken = cognitoUserSession.getAccessToken();\\n                cognitoRefreshToken = cognitoUserSession.getRefreshToken();\\n                console.log('Got tokens: ', cognitoUserSession);\\n                startHTTPServer();\\n                // TODO: Send curl to open door form here with\\n            },\\n            onFailure: function (err) {\\n                console.log(\\\"err:\\\", err)\\n            },\\n            customChallenge: function (challengeParameters) {\\n                // TODO: From here do I initAuth again for PASSWORD_VERIFIER\\n                console.log(\\\"challengeParameters from sending Custom Answer 2:\\\", challengeParameters)\\n            }\\n        });\\n    })\\n}\\n\\nasync function emailAuthInit() {\\n    return new Promise((resolve, reject) => {\\n        cognitoUser.authenticateUser(authenticationDetails, {\\n\\n            customChallenge: function (challengeParameters) {\\n                console.log(\\\"challengeParameters:\\\", challengeParameters)\\n                cognitoUser.sendCustomChallengeAnswer('answerType:generateCode,medium:phone,codeType:login', {\\n                    onSuccess: function (result) {\\n                        console.log(\\\"result from sending Custom Answer 1:\\\", result)\\n                    },\\n                    onFailure: function (err) {\\n                        console.log(\\\"err:\\\", err)\\n                    },\\n                    customChallenge: function (challengeParameters) {\\n                        console.log(\\\"challengeParameters from sending Custom Answer:\\\", challengeParameters)\\n                        resolve(challengeParameters);\\n                        // TODO This code I think comes from SMS!\\n\\n\\n                    }\\n                });\\n\\n            },\\n\\n            onSuccess: function (result) {\\n                var accessToken = result.getAccessToken().getJwtToken();\\n\\n                console.log(`\\\\naccessToken from cogintoUser authenticateUser: ${accessToken}\\\\n`);\\n\\n                //POTENTIAL: Region needs to be set if not already set previously elsewhere.\\n                AWS.config.region = 'us-east-1';\\n                const k = `cognito-idp.<region>.amazonaws.com/${userPoolId}`;\\n                AWS.config.credentials = new AWS.CognitoIdentityCredentials({\\n                    IdentityId: 'us-east-1:ffff0a60-ffff-4fff-fffc-ffffbca71ffc', // your identity pool id here\\n                    Logins: {\\n                        // Change the key below according to the specific region your user pool is in.\\n                        // cognito-idp.us-east-1.amazonaws.com\\n                        [k]: result\\n                            .getIdToken()\\n                            .getJwtToken(),\\n                    },\\n                });\\n\\n                console.log(`sessionToken:  ${AWS.config.credentials.sessionToken}`);\\n                console.log(`secretAccessKey:  ${AWS.config.credentials.secretAccessKey}`);\\n                //refreshes credentials using AWS.CognitoIdentity.getCredentialsForIdentity()\\n                // AWS.config.credentials.refresh(error => {\\n                //     if (error) {\\n                //         console.error(error);\\n                //     } else {\\n                //         // Instantiate aws sdk service objects now that the credentials have been updated.\\n                //         // example: var s3 = new AWS.S3();\\n                //         console.log('Successfully logged!');\\n                //     }\\n                // });\\n            },\\n\\n            onFailure: function (err) {\\n                console.log(err.message || JSON.stringify(err));\\n            },\\n        });\\n    });\\n}\\n\\nif (process.env['APPNAME_ACCESS_TOKEN'] && process.env['APPNAME_REFRESH_TOKEN']) {\\n    cognitoAccessToken = new CognitoAccessToken({ AccessToken: process.env['APPNAME_ACCESS_TOKEN'] });\\n    cognitoRefreshToken = new CognitoRefreshToken({ RefreshToken: process.env['APPNAME_REFRESH_TOKEN'] });\\n    console.log(`Got tokens from env: `, cognitoAccessToken.getJwtToken(), \\\"\\\\nRefresh:\\\", cognitoRefreshToken.getToken());\\n    startHTTPServer();\\n} else {\\n    console.log(`No tokens in ENV getting them via Cognito`);\\n    await emailAuthInit();\\n    const smsCode = await rl.question('What is the SMS Code: ');\\n    await emailAuthCode(smsCode);\\n}\\n\")), mdx(\"p\", null, \"The really tricky part was looking at the HTTPS dumped requests and figuring out what kind of AWS Cogntio requests I needed to make and what strings to pass. But this was all reverse engineerable from the information in the request bodies and by reading the AWS Cognito library source code.\"), mdx(\"p\", null, \"Basically if you find yourself trying to write something similar where you want to recreate an AWS Cognito login flow and see requests that have in the body:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A request with AuthFlow: CUSTOM_AUTH\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Then a request with ChallengeName: PASSWORD_VERIFIER\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Then a request with ChallengeResponses: PASSWORD_CLAIM_SECRET_BLOCK\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Then ChallengeName: CUSTOM_CHALLENGE\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"ChallengeResponses: \\\\\\\"ANSWER\\\\\\\":\\\\\\\"answerType:generateCode,medium:phone,codeType:login\\\\\\\"\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\\\"{\\\\\\\"ChallengeName\\\\\\\":\\\\\\\"CUSTOM_CHALLENGE\\\\\\\",\\\\\\\"ChallengeParameters\\\\\\\":{\\\\\\\"challengeType\\\\\\\":\\\\\\\"code\\\\\\\"}\")), mdx(\"p\", null, \"Then the above code should be hackable to get something working for you.\"), mdx(\"p\", null, \"My auth flow required authorizing via my username and password then doing 2fa using my phone number which was already in their system somehow.\\nBecause I started getting a text with a code after I passed the first part of the Cogntio verification with the email and password.\"), mdx(\"p\", null, \"Hopefully my Cognito client code above is helpful for someone.\"), mdx(\"p\", null, \"I figured out a bunch of other interesting stuff that I think is useful but I'll have to put that into another post.. this post is already a mess of information and is probably hard to follow.\"), mdx(\"p\", null, \"I did figure out how to send fake touch events. So in this case I could script having the app open then wait a second for the app to load and send touch event to the middle of the screen just to hit the lock or unlock button.\"), mdx(\"p\", null, \"The hackiest of hacks but it's really cool sending these fake touch events. I'll write a post about that next.\"), mdx(\"h3\", null, \"Just some lldb notes:\"), mdx(\"p\", null, \"Ever be steppin and you step INTO a jump/function call and just want to get back to where you were?\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"thread step-out\\n\")), mdx(\"p\", null, \"will get you back!\"), mdx(\"p\", null, \"And you can use it to jump over call or bl instructions as well.\"), mdx(\"p\", null, \"So my LLDB flow was mostly:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Search for possible places to set breakpoints with:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"image lookup -r -n .*AWSCognito.*\\n\")), mdx(\"p\", null, \"AWSCognito being something related to whatever you want to learn more about. Maybe its refreshToken or something..\"), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Then I check that list it generates and see how ridiculously long it is. If I am going to be setting to many breakpoints I work that regex down to be more specific and then set breakpoints with:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"br set -r  .*refreshToken.*\\n\")), mdx(\"p\", null, \"Then when I hit a breakpoint I would read all the variables and pointers I could. I would check the backtrace to see whats going on:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"bt\\n\")), mdx(\"p\", null, \"and from there I could select different \\\"frames\\\" or functions called to get to my breakpoint:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"frame select SOMENUMBERHERE\\n\")), mdx(\"p\", null, \"I would check the registers at each frame:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"register read --all\\n\")), mdx(\"p\", null, \"Although they obviously made the most sense down at the frame you break into.\"), mdx(\"p\", null, \"For each frame your in if you want to see the full dissassembly of the current function run:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"di -f\\n\")), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Just start printing out all the info.\")), mdx(\"p\", null, \"LLDB has nice aliases for the registers that contain function call arguments and can be printed out with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"po $arg1\\npo $arg2\\netc...\\n\")), mdx(\"ol\", {\n    \"start\": 4\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Accessing data on objects I found:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"expression -l objc -O -- [$arg1 userPoolConfiguration]\\n\")), mdx(\"ol\", {\n    \"start\": 5\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Creating variables in LLDB:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"expression -l objc -O -- NSURL *$url = [NSURL URLWithString:@\\\"appName://\\\"];\\n\")), mdx(\"p\", null, \"Would create an NSUrl with the lldb variable name $url.\\nThen I could test that my method was in fact swizzed correctly with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"expression -l objc -O -- [[UIApplication sharedApplication].delegate application:[UIApplication sharedApplication] handleOpenURL:$url];\\n\")), mdx(\"p\", null, \"More examples of variables:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"expression id $delegate = (id)[[UIApplication sharedApplication] delegate]\\nexpression id $keyWindow= (id)[$delegate window]\\nexpression id $root = (id)[$keyWindow rootViewController]\\npo $root\\n\")), mdx(\"ol\", {\n    \"start\": 6\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Got a sneaking suspicion some address is really a pointer? Want to see if its an object?\\nCast it as an (id) and po it:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"po (id)0x7facaada2c80\\n\")), mdx(\"ol\", {\n    \"start\": 7\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"IMPORTANT - You can use\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"command script import lldb.macosx.heap\\n\")), mdx(\"p\", null, \"in lldb to get access to some realllllly helpful heap functions. Similar to what Frida provides for searching the heap for objects. Huuuuuuge for me.\"), mdx(\"ol\", {\n    \"start\": 8\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"My .lldbinit file:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"command script import lldb.macosx.heap\\ntype summary add --category swift --summary-string \\\"Unmanaged Contains: ${var._value%@}\\\" Swift.Unmanaged<AnyObject>\\ncommand script import /Users/bbarrows/lldb/load_swift.py\\n# to run lldb \\\"shell\\\" scripts\\ncommand alias shsource command source\\n# to run a shell command, like `open`\\ncommand alias shellcmd platform shell\\n# tell lldb to assume swift, not objc\\nsettings set target.language Swift\\ncommand alias clear-lang settings clear target.language\\ncommand alias swiftui_script load_swift /Users/bbarrows/lldb/helpers.swift\\n#command script import  /Users/bbarrows/repos/MyLLDB/python/sbt.py\\ncommand alias eco expression -l objective-c -O --\\ncommand alias ecs expression -l swift -O --\\ncommand alias br breakpoint\\ncommand alias rr register read\\ncommand alias rra register read\\ncommand regex ims 's/(.+)/image lookup -rn %1/'\\ncommand regex z 's/(.+)/breakpoint set -r %1/'\\ncommand regex mr 's/(.+) (.+)/memory read --size 8 --format x --count %2 %1/'\\ncommand regex pos  's/(.+)/po (const char *)%1/'\\ncommand regex posc  's/(.+)/expression -l swift -O -- unsafeBitCast(0x7f8c7b002b30, to: %1.self)/'\\n\")), mdx(\"h3\", null, \"Useful tools\"), mdx(\"p\", null, \"Best tool I think for dumping headers these days is \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/cxnder/ktool\"\n  }, \"ktool\"), \"\\nReally nice GUI too and handles the MachO sections that are causing the older header dump tools to fail.\"), mdx(\"p\", null, \"I also probably learned the most and got the farthest just using lldb and Frida BUT attaching xCode to your running process and then using the xCode Memory Graph was super helpful to figure out what was related to what and what information I could find. For example, I had some Swift class with private properties or whatever that I couldn't access but I was able to figure out the offset from the object handle and get a reference to its JWT that way.\"), mdx(\"p\", null, \"For me Frida and lldb are the most useful tools other then, in this case, just using a tool like Charles Proxy for dumping the https session. I actually was using another tool called Quantum I think but same idea and I can't remember the name now. Surge 5 also works fine.. But it's pretty buggy and has poort documentation especially if your trying to do stuff like have your mac control it on your phone.\"), mdx(\"h1\", null, \"Summary\"), mdx(\"p\", null, \"I poked around a lot trying a lot of different things. I was hoping to just hook or add and implementation for handling IOS URLSchemes so I could script opening the app and have it lock and unlock the door.\"), mdx(\"p\", null, \"I couldn't find a good way to get a JWT that was always valid. The application will run some Swift code that I wasn't able to track down in a relatively sane amount of time so I gave up on getting the JWT and refresh token from the heap/app.\"), mdx(\"p\", null, \"I ended up looking at the HTTPS requests. Figuring out it was using AWS Cognito. And then re creating my own service that just mimicks whats the lock company does to get me a JWT for their lock control server.\"), mdx(\"p\", null, \"Now I have a service running that I logged into once, it refreshes the JWT every 30 min, and I can send HTTPS requests to it to lock and unlock my door with a Siri/Shortcut I created.\"));\n}\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<h1>Stuck With a Smart Lock That Only Works With Google or Alexa? Let&#x27;s Fix That!</h1><p>I really should have written this up sooner so it was still fresh in my head. Sorry this is a bit of a mess of information but the AWS Cognito example might be useful to some. And the Frida Gadget scripting to add a URLScheme could be helpful.</p><p>I am going to make another post for how I was able to use a library by <a href=\"https://github.com/lyft/Hammer\">Lyft called Hammer</a> to send fake UITouch events as well next.. and maybe one on just all the lldb commands I learned and what I thought was really helpful.</p><h2>Introduction - IOS URLScheme and Frida and some lldb</h2><p>So for my safety I will try to obscure company names and info as much as possible. Although I don&#x27;t think I did anything wrong? I&#x27;m honestly not sure where the line is drawn on what is legal with stuff like this.</p><p>So I moved into a new apartment with a smart lock that has an iOS app which is nice. But it takes a while to load the app and then press the button to lock and unlock the door and I really just wanted to be able to tell Siri to do it if I had full hands... And I love poking around iOS anyways.</p><p>I will try to go through my process in the order I went in (mostly) becuase I learned a lot along the way. Recreating this blog post from my notes.</p><p>The summary would be that, as someone suggested, the easy way to do something like this is definately to just sniff the network traffic and recreate it. But I wanted to learn more about iOS and how to reverse engineer it so I went the hard way at first.</p><p>So originally, I started did use software like Charles Proxy basically to look at the network traffic. And what did I find?</p><p>A really nice simple JSON API that uses a JWT token for auth to lock and unlock the door.</p><p>So to show how easy it looked at first to use this API here is a curl showing me using the API to lock the door:</p><pre><code class=\"language-bash\">curl -X PATCH &quot;https://$SOMECOMPANYID.execute-api.us-east-1.amazonaws.com/prod_v1/devices/$PROBMYDEVICEID/status&quot; -H &quot;User-Agent: AppName/5 CFNetwork/1404.0.5 Darwin/22.3.0&quot; -H &quot;Content-Type: application/json&quot; -H &quot;Accept: application/json&quot; -H &quot;Accept-Language: en-US,en;q=0.9&quot; -H &quot;Authorization: Bearer $KBEARER&quot; -H &quot;Accept-Encoding: gzip, deflate, br&quot; -d &quot;{\\&quot;action\\&quot;: \\&quot;lock\\&quot;, \\&quot;source\\&quot;: \\&quot;{\\\\\\&quot;name\\\\\\&quot;:\\\\\\&quot;$MYNAME\\\\\\&quot;,\\\\\\&quot;device\\\\\\&quot;:\\\\\\&quot;iPhone\\\\\\&quot;}\\&quot;}&quot;\n</code></pre><p>So all I need to do is send the JSON below to some URL with an AUTH token basically.</p><pre><code>{&quot;action&quot;: &quot;lock&quot;, &quot;source&quot;: &quot;{\\&quot;name\\&quot;:\\&quot;Brad\\&quot;,\\&quot;device\\&quot;:\\&quot;iPhone\\&quot;}&quot;}\n</code></pre><p>Now I did poke around the rest of the HTTPS traffic I intercepted and saw that there were multiple requests before this. And one of them contained the AUTH token. So I knew right away there was some process happening to get the JWT that was unfortunely looking a little complicated.</p><p>So at first I was hoping I could just find some object in the heap that contained the AUTH token and use that via Frida (and it&#x27;s oh so amazing API with functionality like pulling all objects of any type from memory!). But all the AUTH tokens I was finding were not working.</p><p>I should also mention that my original plan was to add an IOS URLScheme to the application so I could just create a Shortcut Siri would use that would open a URL to lock and unlock my door.</p><p>At first I tried a number of things. Like how I used create iOS tweaks. Making a custom dylib in xCode and I manually add to the main executable using install_name_tool that swizzles it&#x27;s way into whatever new functionality I want.</p><p>For those thay may need an explanation. A dylib is a dynamically linked library. Meaning it is a binary that the operating system or really dyld will load into memory when an application starts.</p><p>So I needed a decrypted copy of the application I was going to be modifying/debugging/etc. There are some websites that actually provide this service and work which was surprising but I did find my old iPhone 6s and was able to use Checkra!n and PAlera1n on an iPhone 7 to get them jailbroken. At this point what worked best for me was <a href=\"https://github.com/AloneMonkey/frida-ios-dump\">frida-ios-dump</a></p><p>Note that instead of having to install usbmuxd/iproxy at this point, if your on the same network you can just use the ip address:</p><pre><code>./dump.py -H 192.168.1.87 -p 22 AppName\n</code></pre><p>NOTE: From here on out I&#x27;ll just refer to the iOS app as AppName</p><p>After running this dump you should end up with an unencrypted &quot;.ipa&quot; file in the same folder. A ipa file type is a zip file that contains the application and all of it&#x27;s data/metadata.</p><p>So you can change the extension from .ipa to .zip. And unzip it right there.</p><p>Inside will be a folder named Payload. And inside there will be AppName.App.</p><p>Now just like a .App on OSX you can right click and show package contents to see what all the app really contains.</p><p>Now the most important file will be the binary itself. Which normally is also named AppName (no file extension) and will be an amr64 binary built for iOS.</p><p>There is also a Frameworks folder which will contain a number of frameworks, from my understanding basically just dylibs with a lot more information like header files, that the binary loads at runtime.</p><p>So any executable will have a list of dynamically linked libraries it loads at runtime. You can list those with:</p><pre><code>otool -L $EXE_NAME_HERE\n</code></pre><p>or to get a more detailed breakdown that includes information such as the path where the binary will look for the dylibs:</p><pre><code>otool -l $EXE_NAME_HERE\n</code></pre><p>It is important to use the lowercase -l version so you can see where rpath points to in some cases. I believe in most cases it will just be the Frameworks directoy.\nSo if you are going to add your own dylib you could for example use a tool like <a href=\"https://github.com/tyilo/insert_dylib\">insert_dylib</a>.</p><p>For example, I build my own DYLIB which was at first, attempting to swizzle the older handleURL methods on iOS AppDelegate (this no longer works btw)..</p><p>But to insert your dylib you would do somethign like:</p><pre><code>insert_dylib --strip-codesig --inplace &#x27;@executable_path/Frameworks/libhandleURLSwizzleObjC.dylib&#x27; ~/Payload/AppName.app/AppName\ncp ~/libhandleURLSwizzleObjC.dylib ~/Payload/AppName.app/Frameworks\n</code></pre><p>And in your dylib code (you can create a dylib in xcode by creating a static library, and then going to build options and changing the library type to dynamic, you may also want to change the extension from .a to .dylib as well) you will want to add a constructor function.</p><p>This function is what gets called when the dylib is loaded into memory and is your chance to &quot;swizzle&quot; or replace existing functions with your own. This way you can add/modify existing functionality in an application.</p><p>And these days you just use this tool called <a href=\"https://github.com/sensepost/objection\">objection</a> to then handle signing everything and converting your Payload folder into an ipa for you.</p><p>And then another tool <a href=\"https://github.com/ios-control/ios-deploy\">ios-deploy</a> to send the app to your iPhone. Jailbroken or not. And start a debugging session with lldb. And Objection by default injects frida so you have can connect to frida and poke around as well!</p><p>It is all very user friendly as pretty easy to get started with.</p><h2>Getting IOS URLScheme to Work</h2><p>Even though I didn&#x27;t end up going this route I finaly figured out a cool way to make it work and wanted to document it. So with the newer iOS SDKs and SwiftUI and all the older handleURL method on AppDelegate is no longer called I beleive with a URLScheme.</p><p>First off I needed to update my iOS apps plist file though so it would handle urls. Like AppName://unlockdoor</p><p>To do so I scripted:</p><pre><code>head -n4 ~/Payload/AppName.app/Info.plist &gt; ~/Payload/AppName.app/Info.plist-2\necho &quot;&quot;&quot;    &lt;key&gt;CFBundleURLTypes&lt;/key&gt;\n    &lt;array&gt;\n        &lt;dict&gt;\n            &lt;key&gt;CFBundleURLSchemes&lt;/key&gt;\n            &lt;array&gt;\n                &lt;string&gt;AppName&lt;/string&gt;\n            &lt;/array&gt;\n            &lt;key&gt;CFBundleURLName&lt;/key&gt;\n            &lt;string&gt;com.AppName.ble-wifi&lt;/string&gt;\n        &lt;/dict&gt;\n    &lt;/array&gt;&quot;&quot;&quot; &gt;&gt; ~/Payload/AppName.app/Info.plist-2\ntail -n+5 ~/Payload/AppName.app/Info.plist &gt;&gt; ~/Payload/AppName.app/Info.plist-2\nmv ~/Payload/AppName.app/Info.plist-2 ~/Payload/AppName.app/Info.plist\n</code></pre><p>The important part is that the CFBundleURLSchemes contains the string for the url proto if I remember right and then the CFBundleURLName has to have the same Bundle of the App.\nThere is a lot of documentation on this part too so I won&#x27;t go into too much detail here.</p><p>What I think is really cool is that the Frida Gadget, the Frida dylib, that is injected into the App will look for a script to run. So you can create apps with Frida injected and a script included in the Payload/App folder so that you don&#x27;t need to write a dylib in objective-c or something and can create deployable packagable apps using Frida for tweaks! Pretty amazing.</p><p>The documentation for <a href=\"https://frida.re/docs/gadget/\">Frida Gadgets is here</a>. Definately check that out. It&#x27;s a great feature I never knew about.</p><p>So along with using this feature or Frida I ended up figuring out which method I needed to implement to handle IOS URLSchemes with ios 15.7.2 and probably later.</p><p>You have to find the UIWindowScene and add a method &quot;- scene:openURLContexts:&quot;. This is actually what is trigger with IOS URLSchemes on these newer iOS versions.</p><p>I have a super hacky way of finding the UIWindowScene.. and I don&#x27;t know why I didn&#x27;t just use ObjC.choose or something.. But this is my Frida Gagdet script:</p><pre><code>rpc.exports = {\n    init(stage, parameters) {\n        console.error(&#x27;[init]&#x27;, stage, JSON.stringify(parameters));\n\n        var globalar = null;\n\n        var NSLog = new NativeFunction(Module.findExportByName(&#x27;Foundation&#x27;, &#x27;NSLog&#x27;), &#x27;void&#x27;, [&#x27;pointer&#x27;, &#x27;...&#x27;]);\n        var NSString = ObjC.classes.NSString;\n        var str = NSString.stringWithFormat_(&quot;[*] BRAD IN FRIDA GADGET&quot;);\n        NSLog(str);\n        console.error(&quot;[*] BRAD IN FRIDA GADGET&quot;);\n\n\n        var NSJSONSerialization = ObjC.classes.NSJSONSerialization;\n        var NSUTF8StringEncoding = 4;\n\n        var NSURL = ObjC.classes.NSURL;\n        // var NSError = ObjC.classes.NSError;\n\n        function convertNSObjectToJSString(obj) {\n            var valid = NSJSONSerialization.isValidJSONObject_(obj);\n            if (!valid) return null;\n            const NSJSONWritingPrettyPrinted = 1;\n            var errorPtr = Memory.alloc(Process.pointerSize);\n            Memory.writePointer(errorPtr, NULL); // initialize to NULL\n            var data = NSJSONSerialization.dataWithJSONObject_options_error_(obj, NSJSONWritingPrettyPrinted, errorPtr);\n            var error = Memory.readPointer(errorPtr);\n            if (error.isNull()) {\n                var str = NSString.alloc().initWithData_encoding_(data, NSUTF8StringEncoding);\n                return str.toString();\n            } else {\n                var errorObj = new ObjC.Object(error); // now you can treat errorObj as an NSError instance\n                console.error(errorObj.toString());\n                return null;\n            }\n        }\n\n\n        function getCurrentJWT() {\n            var awsMobileClientPtr = Number(ObjC.chooseSync(ObjC.classes[&quot;AWSMobileClient.AWSMobileClient&quot;])[0].handle);\n            var awsMobileClientDictPtrStr = Number(awsMobileClientPtr + 0x0000000000000088).toString(16);\n            var awsMobileClientDictPtr = new NativePointer(&quot;0x&quot; + awsMobileClientDictPtrStr);\n            var dictPtr = awsMobileClientDictPtr.readPointer()\n            var dictObj = new ObjC.Object(dictPtr);\n            var dstr = dictObj.toString();\n            console.error(&quot;String argument: &quot; + dstr);\n            var regex = /.*(&quot;eyJ.*&quot;).*/;\n            var jwt = JSON.parse(dstr.match(regex)[1]);\n            return jwt;\n        }\n\n        function lockUnlockDoor(action) {\n            var jwt = getCurrentJWT();\n            console.error(&quot;Got JWT: &quot; + jwt);\n\n            var actionParsed = (action == &quot;lock&quot; || action == &quot;unlock&quot;) ? action : &quot;lock&quot;;\n            var url = &quot;https://SOMECOMPANYID.execute-api.us-east-1.amazonaws.com/prod_v1/devices/PROBMYDEVICEID/status&quot;;\n            var nsurl = NSURL.alloc().initWithString_(url);\n            var urlRequest = ObjC.classes.NSMutableURLRequest.alloc().initWithURL_(nsurl);\n\n            var actString = &quot;{\\&quot;action\\&quot;: \\&quot;&quot; + actionParsed + &quot;\\&quot;, \\&quot;source\\&quot;: \\&quot;{\\\\\\&quot;name\\\\\\&quot;:\\\\\\&quot;Brad\\\\\\&quot;,\\\\\\&quot;device\\\\\\&quot;:\\\\\\&quot;iPhone\\\\\\&quot;}\\&quot;}&quot;;\n            console.error(`\\n\\nBEB - actString: ${actString} ${actString.length}\\n\\n`);\n            var userUpdate = NSString.stringWithFormat_(actString);\n            console.error(`\\n\\nBEB - userUpdate: ${userUpdate.toString()} ${userUpdate.length()}\\n\\n`);\n\n            urlRequest.setHTTPMethod_(&quot;PATCH&quot;);\n            urlRequest.setValue_forHTTPHeaderField_(&quot;Bearer &quot; + jwt, &quot;Authorization&quot;);\n            urlRequest.setValue_forHTTPHeaderField_(`${actString.length}`, &quot;Content-Length&quot;);\n            urlRequest.setValue_forHTTPHeaderField_(&quot;application/json&quot;, &quot;Content-Type&quot;);\n            urlRequest.setValue_forHTTPHeaderField_(&quot;application/json&quot;, &quot;Accept&quot;);\n            urlRequest.setValue_forHTTPHeaderField_(&quot;en-US,en;q=0.9&quot;, &quot;Accept-Language&quot;);\n            urlRequest.setValue_forHTTPHeaderField_(&quot;gzip, deflate, br&quot;, &quot;Accept-Encoding&quot;);\n            urlRequest.setValue_forHTTPHeaderField_(&quot;appName/5 CFNetwork/1404.0.5 Darwin/22.3.0&quot;, &quot;User-Agent&quot;);\n            urlRequest.setValue_forHTTPHeaderField_(&quot;keep-alive&quot;, &quot;Connection&quot;);\n\n            var data1 = userUpdate.dataUsingEncoding_(NSUTF8StringEncoding);\n\n            urlRequest.setHTTPBody_(data1);\n\n            var session = ObjC.classes.NSURLSession.sharedSession();\n\n            console.error(&quot;Setup request and is about to make it&quot;);\n            var dataTask = session.dataTaskWithRequest_completionHandler_(urlRequest, new ObjC.Block({\n                retType: &#x27;void&#x27;,\n                argTypes: [&#x27;pointer&#x27;, &#x27;pointer&#x27;, &#x27;pointer&#x27;],\n                implementation: function (data, response, error) {\n                    var dataStr = NSString.alloc().initWithData_encoding_(data, NSUTF8StringEncoding);\n                    var respObj = new ObjC.Object(response);\n                    var errorObj = new ObjC.Object(error);\n                    console.error(&quot;data: &quot;, dataStr);\n                    console.error(&quot;response code: &quot;, respObj.statusCode());\n                    console.error(&quot;error: &quot;, errorObj.toString());\n\n                    // var respObj = new ObjC.Object(response);\n                    // console.error(&quot;data as JSON string: &quot;, convertNSObjectToJSString(data));\n\n                }\n            }));\n            dataTask.resume();\n        }\n\n\n        function setIntercept() {\n            var scenes = ObjC.classes.UIApplication.sharedApplication().connectedScenes();\n\n            var winSceneRegex = /UIWindowScene: (0x[a-fA-F0-9]+)/\n            var scenesPtr = ptr(scenes.toString().match(winSceneRegex)[1]);\n            var windowScene = ObjC.Object(scenesPtr);\n            try {\n                if (!scenes) {\n                    console.error(&quot;Couldn&#x27;t file UIWindowScene on sharedApplication&quot;);\n                } else {\n                    Interceptor.attach(windowScene.delegate()[&quot;- scene:openURLContexts:&quot;].implementation, {\n                        onEnter(args) {\n                            // ObjC: args[0] = self, args[1] = selector, args[2-n] = arguments\n                            const arg2Str = new ObjC.Object(args[2]);\n                            console.error(&quot;String argument: &quot; + arg2Str.toString());\n                            NSLog(NSString.stringWithFormat_(&quot;[*] BRAD scene:openURLContexts: argument 2: &quot; + arg2Str.toString()));\n\n                            const arg3Str = new ObjC.Object(args[3]);\n                            console.error(&quot;String argument: &quot; + arg3Str.toString());\n                            NSLog(NSString.stringWithFormat_(&quot;[*] BRAD scene:openURLContexts: argument 3: &quot; + arg3Str.toString()));\n\n                            globalar = arg3Str;\n                            var appNameActionFromURLRegex = /URL: appName:\\/\\/(\\S+)/; ///.*URL: appName: \\/\\/([a-z]*);.*/;\n                            console.error(arg3Str.toString().match(appNameActionFromURLRegex));\n                            var action = arg3Str.toString().match(appNameActionFromURLRegex)[1];\n\n                            lockUnlockDoor(action);\n                        }\n                    });\n                    console.error(&quot;[*]WindowScene() intercept placed&quot;);\n                    NSLog(NSString.stringWithFormat_(&quot;[*]WindowScene() intercept placed&quot;));\n                }\n            }\n            catch (err) {\n                console.error(&quot;[*]BRAD Exception: &quot; + err.message);\n                NSLog(NSString.stringWithFormat_(&quot;[*]BRAD Exception: &quot; + err.message));\n            }\n        }\n\n        setTimeout(setIntercept, 1000); // IDK why I wanted to wait to add this method. I was thinking maybe it could take a while for the UIWindowScene to get created\n        console.error(&quot;[*]BRAD SETTIMEOUT&quot;);\n        NSLog(NSString.stringWithFormat_(&quot;[*]BRAD SETTIMEOUT&quot;));\n\n\n    },\n    dispose() {\n        console.error(&#x27;[dispose]&#x27;);\n    }\n};\n\n</code></pre><p>I save this as appName.js in the Frameworks folder.</p><p>In the Frameworks folder I ALSO create the Frida Gadget config to run the script. It is a file named: FridaGadget.config</p><pre><code>{\n  &quot;interaction&quot;: {\n    &quot;type&quot;: &quot;script&quot;,\n    &quot;path&quot;: &quot;appName.js&quot;,\n    &quot;on_change&quot;: &quot;reload&quot;\n  }\n}\n</code></pre><p>I figure this code could be useful if someone wants to try something similar.</p><p>NOTE: That if you are trying to get the JWT from AWS like I was in the code above. It probably won&#x27;t work often unless the app refreshes it&#x27;s token often.</p><p>The app I was using DIDNT. So this route didn&#x27;t work. And triggering the app to run its refresh token code was taking forever to figure out.</p><p>So now back to actually getting something working.</p><h2>AWS Cognito Reverse engineering</h2><p>So this app actually has a server that handles the requests to lock and unlock the door. And it uses AWS Cognito to handle generation and refreshing of the JWT.</p><p>I couldn&#x27;t find any working examples of using AWS Cognito as a client and I thought this might be helpful for someone trying to do something similar. My code maybe messy but it works and I have invested too much time in it as it is so I am calling it good.</p><p>So first off. I used Frida to poke around. And I see that AWS and something called AWS Cognito is being used from the loaded Frameworks. I findout that Cognito is used for auth. Also I saw in the decoded JWT via <a href=\"https://jwt.io/\">https://jwt.io/</a> that scope of the jwt is &quot;aws.cognito.signin.user.admin&quot;. So I know now that this app is using Cognito for auth.</p><p>Then I think I was just using Frida&#x27;s ObjC.chooseSync and grabbing objects and I found some useful information. I also was using lldb and found some information I needed later for basically re creating the AWS Cognito login flow.</p><p>So when I run the iod-deploy I used the configuration that automatically starts the app and gives you an lldb session.</p><p>I think I started by looking at what I could break on that was AWSCognito related with the command:</p><pre><code>image lookup -r -n .*AWSCognito.*\n</code></pre><p>This uses regex to search for anything AWSCognito related. Any methods on the classes that have the string AWSCognito will be listed.</p><p>I think I realized by looking at other AWS Cognito client implementations that didn&#x27;t work that I needed to get a few bits of information.</p><p>So I set breakpoints in lldb (using Frida again would have probably been easier but I am just documenting stuff I learned here)</p><pre><code>breakpoint set -r &#x27;\\[AWSCognitoIdentityUserPoolConfiguration .*\\]$\nbreakpoint set -r &#x27;\\[AWSCognitoIdentityUserPool .*\\]$\n</code></pre><p>I am pretty sure I hit the following breakpoint:</p><pre><code>\n  Summary: AWSAppSync`AWSAppSync.AWSCognitoUserPoolsAuthProviderAsync.getLatestAuthToken() -&gt; Swift.String        Address: AWSAppSync[0x0000000000027200] (AWSAppSync.__TEXT.__text + 131900)\n</code></pre><p>And then I started printing out arguments to this method call:</p><pre><code>\npo (SEL)$arg2\n\npo $arg1\n\nexpression -l objc -O -- [$arg1 userPoolConfiguration]\n\nexpression -l objc -O -- [[$arg1 userPoolConfiguration] poolId]\n\n</code></pre><p>The last one of these got me the poolId for AWSCognito account I needed to login with to get a JWT and refresh token so I could send lock and unlock commands.</p><p>NOTE: That the poolId will probably be in a format like this:</p><pre><code>us-east-1_6B31234KN\n</code></pre><p>Then I also needed something called the clientID. This can actually be found in the requests from the HTTPS requests I dumped to JSON.</p><p>I also needed to find this information which I got with Frida:</p><pre><code>var awsccp = [];\nObjC.choose(ObjC.classes[&#x27;AWSCognitoCredentialsProvider&#x27;], {\n  onMatch: function (serv) {\n    console.log(&#x27;Found AWSCognitoCredentialsProvider&#x27;, serv);\n    awsccp.push(serv);\n  },\n  onComplete: function () {\n    console.log(&#x27;Finished AWSCognitoCredentialsProvider search&#x27;);\n  }\n});\n\nconsole.log(awsccp);\n\n\nconsole.log(awsccp.getIdentityId())\n&lt;AWSTask: 0x2867bf380; completed = YES; cancelled = NO; faulted = NO; result = us-east-1:47021234-ffff-4fff-afff-ffffbca71a1c&gt;\n\n</code></pre><p>And then I had enough info to basically re create the server that the iPhone app used to send my login credentials to which would talk with AWS Cognito and get a JWT and refresh token. I wanted to have my own so that I could get a JWT whenever I want. And I found out that I can just basically refresh my JWT forever so I really just need to get that JWT and I refresh every 30 minutes I beleive it was. The code is below:</p><pre><code>const fullUserPoolId = &#x27;us-east-1_5F3ufo6uFF&#x27;\nconst userPoolId = &#x27;5F3ufo6uFF&#x27;\nconst ClientId = &#x27;ffuabckjpfffd1ab7881m6g88s&#x27;\nconst username = &quot;myemail@gmail.com&quot;;\nconst password = &quot;MyPassword&quot;;\n\nimport * as AWS from &#x27;aws-sdk&#x27;;\nimport AmazonCognitoIdentity, { CognitoRefreshToken, CognitoAccessToken } from &#x27;amazon-cognito-identity-js&#x27;;\n\nimport * as readline from &#x27;node:readline/promises&#x27;;\nimport { stdin as input, stdout as output } from &#x27;node:process&#x27;;\n\nimport * as http from &#x27;http&#x27;;\nimport * as url from &#x27;url&#x27;;\n\n\n\nconst rl = readline.createInterface({ input, output });\n\n\n// // import type { ICognitoUserData } from &#x27;amazon-cognito-identity-js&#x27;;\n\n// const cognitoUserPool = ;\n\n// const cognitoUserData /*: ICognitoUserData*/ = {\n//     Username: username,\n//     Pool: cognitoUserPool,\n//     Storage: undefined // ICognitoStorage ?\n// }\n\nvar cognitoRefreshToken = null;\nvar cognitoAccessToken = null;\n\nvar authenticationData = {\n    Username: username,\n    Password: password,\n};\nvar authenticationDetails = new AmazonCognitoIdentity.AuthenticationDetails(\n    authenticationData\n);\nvar poolData = {\n    UserPoolId: fullUserPoolId, // Your user pool id here\n    ClientId: ClientId, // Your client id here\n};\nvar userPool = new AmazonCognitoIdentity.CognitoUserPool(poolData);\nvar userData = {\n    Username: username,\n    Pool: userPool,\n};\nvar cognitoUser = new AmazonCognitoIdentity.CognitoUser(userData);\n\ncognitoUser.setAuthenticationFlowType(&#x27;CUSTOM_AUTH&#x27;);\n\n\n\nfunction refreshToken() {\n    const refreshFromGlobal = (cognitoRefreshToken || process.env.APPNAME_REFRESH_TOKEN);\n    console.log(&quot;Refreshing tokens. What I have globally and in env is:&quot;, refreshFromGlobal)\n    if (refreshFromGlobal) {\n        cognitoUser.refreshSession(cognitoRefreshToken || new CognitoRefreshToken({ RefreshToken: process.env.APPNAME_REFRESH_TOKEN }), (err, session) =&gt; {\n            if (err) {\n                console.error(&quot;Error refreshing tokens&quot;, err)\n            } else {\n                console.log(&quot;Refreshed tokens&quot;, session)\n                // SO LAME, now accessToken and refreshToken are lower case to start..\n                const { accessToken, refreshToken } = session;\n                if (refreshToken) {\n                    cognitoRefreshToken = refreshToken;\n                } else {\n                    console.log(&quot;No refresh token after refresh&quot;);\n                }\n                if (accessToken) {\n                    cognitoAccessToken = accessToken;\n                } else {\n                    console.log(&quot;No access token after refresh&quot;);\n                }\n            }\n        })\n    } else {\n        console.error(&quot;No refresh token to refresh&quot;, refreshFromGlobal)\n    }\n}\n\nfunction startHTTPServer() {\n\n    setInterval(() =&gt; {\n        refreshToken();\n    }, 1000 * 60 * 30)\n\n    console.log(`Starting HTTP Server`)\n    // Configure our HTTP server to respond with Hello World to all requests.\n    var server = http.createServer(function (request, response) {\n        console.log(`HTTP handling request: ${request}\\n\\n\\n\\nWith response: ${response}`)\n        //    var name=request.getParameter(&#x27;name&#x27;);\n        //    console.log(name);\n        const action = url.parse(request.url, true).query[&#x27;action&#x27;];\n        if (action) {\n            const actionParsed = (action == &#x27;lock&#x27; || action == &#x27;unlock&#x27;) ? action : &#x27;lock&#x27;;\n            sendLockUnlockRequest(actionParsed).then((res) =&gt; {\n                response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });\n                response.end(`Handling action for ${actionParsed}. Response: ${JSON.stringify(res)}\\n`);\n            })\n        } else {\n            response.writeHead(500, { &quot;Content-Type&quot;: &quot;text/plain&quot; });\n            response.end(`Invalid request\\n`);\n        }\n    });\n    // Listen on port 8000, IP defaults to 127.0.0.1\n    server.listen(8000);\n}\n\n\nasync function sendLockUnlockRequest(action) {\n    if (action != &#x27;lock&#x27; &amp;&amp; action != &#x27;unlock&#x27;) {\n        console.error(`Invalid action: ${action} sent to sendLockUnlockRequest`);\n        return\n    }\n\n    console.log(&quot;Makeing request with:&quot;, {\n        method: &quot;PATCH&quot;, // *GET, POST, PUT, DELETE, etc.\n        headers: {\n            &#x27;Accept&#x27;: &#x27;application/json&#x27;,\n            &#x27;Accept-Language&#x27;: &#x27;en-US,en;q=0.9&#x27;,\n            &#x27;Authorization&#x27;: `Bearer ${cognitoAccessToken.getJwtToken()}`,\n            &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate, br&#x27;\n        },\n        body: &quot;{\\&quot;action\\&quot;: \\&quot;&quot; + action + &quot;\\&quot;, \\&quot;source\\&quot;: \\&quot;{\\\\\\&quot;name\\\\\\&quot;:\\\\\\&quot;Brad\\\\\\&quot;,\\\\\\&quot;device\\\\\\&quot;:\\\\\\&quot;iPhone\\\\\\&quot;}\\&quot;}&quot;\n    });\n    console.log(&quot;body: &quot;, &quot;{\\&quot;action\\&quot;: \\&quot;&quot; + action + &quot;\\&quot;, \\&quot;source\\&quot;: \\&quot;{\\\\\\&quot;name\\\\\\&quot;:\\\\\\&quot;Brad\\\\\\&quot;,\\\\\\&quot;device\\\\\\&quot;:\\\\\\&quot;iPhone\\\\\\&quot;}\\&quot;}&quot;)\n    const response = await fetch(&#x27;https://COMPANYID.execute-api.us-east-1.amazonaws.com/prod_v1/devices/PROBMYDEVICEID/status&#x27;, {\n        method: &quot;PATCH&quot;, // *GET, POST, PUT, DELETE, etc.\n        headers: {\n            &#x27;Accept&#x27;: &#x27;application/json&#x27;,\n            &#x27;Accept-Language&#x27;: &#x27;en-US,en;q=0.9&#x27;,\n            &#x27;Authorization&#x27;: `Bearer ${cognitoAccessToken.getJwtToken()}`,\n            &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate, br&#x27;\n        },\n        body: `{&quot;action&quot;: &quot;${action}&quot;, &quot;source&quot;: &quot;{\\\\&quot;name\\\\\\&quot;:\\\\\\&quot;Bradley\\\\\\&quot;,\\\\\\&quot;device\\\\\\&quot;:\\\\\\&quot;iPhone\\\\\\&quot;}&quot;}`\n    });\n    const responseFromAppName = await response.json();\n    console.log(&quot;response from lock/unlock:&quot;, responseFromAppName);\n    return responseFromAppName;\n}\n\nasync function emailAuthCode(smsCode) {\n    return new Promise((resolve, reject) =&gt; {\n        cognitoUser.sendCustomChallengeAnswer(&#x27;answerType:verifyCode,medium:phone,codeType:login,code:&#x27; + smsCode, {\n            mfaRequired: function (result) {\n                console.log(&quot;result from mfaRequired 2:&quot;, result);\n            },\n            selectMFAType: function (result) {\n                console.log(&quot;result from selectMFAType 2:&quot;, result);\n            },\n            mfaSetup: function (result) {\n                console.log(&quot;result from mfaSetup 2:&quot;, result);\n            },\n            totpRequired: function (result) {\n                console.log(&quot;result from totpRequired 2:&quot;, result);\n            },\n            newPasswordRequired: function (result) {\n                console.log(&quot;result from newPasswordRequired 2:&quot;, result);\n            },\n            associateSecretCode: function (result) {\n                console.log(&quot;result from associateSecretCode 2:&quot;, result);\n            },\n            inputVerificationCode: function (result) {\n                console.log(&quot;result from inputVerificationCode 2:&quot;, result);\n            },\n            associateSecretCode: function (result) {\n                console.log(&quot;result from associateSecretCode 2:&quot;, result);\n            },\n            onSuccess: function (cognitoUserSession) {\n                console.log(&quot;result from sending Custom Answer 2:&quot;, cognitoUserSession);\n                cognitoAccessToken = cognitoUserSession.getAccessToken();\n                cognitoRefreshToken = cognitoUserSession.getRefreshToken();\n                console.log(&#x27;Got tokens: &#x27;, cognitoUserSession);\n                startHTTPServer();\n                // TODO: Send curl to open door form here with\n            },\n            onFailure: function (err) {\n                console.log(&quot;err:&quot;, err)\n            },\n            customChallenge: function (challengeParameters) {\n                // TODO: From here do I initAuth again for PASSWORD_VERIFIER\n                console.log(&quot;challengeParameters from sending Custom Answer 2:&quot;, challengeParameters)\n            }\n        });\n    })\n}\n\nasync function emailAuthInit() {\n    return new Promise((resolve, reject) =&gt; {\n        cognitoUser.authenticateUser(authenticationDetails, {\n\n            customChallenge: function (challengeParameters) {\n                console.log(&quot;challengeParameters:&quot;, challengeParameters)\n                cognitoUser.sendCustomChallengeAnswer(&#x27;answerType:generateCode,medium:phone,codeType:login&#x27;, {\n                    onSuccess: function (result) {\n                        console.log(&quot;result from sending Custom Answer 1:&quot;, result)\n                    },\n                    onFailure: function (err) {\n                        console.log(&quot;err:&quot;, err)\n                    },\n                    customChallenge: function (challengeParameters) {\n                        console.log(&quot;challengeParameters from sending Custom Answer:&quot;, challengeParameters)\n                        resolve(challengeParameters);\n                        // TODO This code I think comes from SMS!\n\n\n                    }\n                });\n\n            },\n\n            onSuccess: function (result) {\n                var accessToken = result.getAccessToken().getJwtToken();\n\n                console.log(`\\naccessToken from cogintoUser authenticateUser: ${accessToken}\\n`);\n\n                //POTENTIAL: Region needs to be set if not already set previously elsewhere.\n                AWS.config.region = &#x27;us-east-1&#x27;;\n                const k = `cognito-idp.&lt;region&gt;.amazonaws.com/${userPoolId}`;\n                AWS.config.credentials = new AWS.CognitoIdentityCredentials({\n                    IdentityId: &#x27;us-east-1:ffff0a60-ffff-4fff-fffc-ffffbca71ffc&#x27;, // your identity pool id here\n                    Logins: {\n                        // Change the key below according to the specific region your user pool is in.\n                        // cognito-idp.us-east-1.amazonaws.com\n                        [k]: result\n                            .getIdToken()\n                            .getJwtToken(),\n                    },\n                });\n\n                console.log(`sessionToken:  ${AWS.config.credentials.sessionToken}`);\n                console.log(`secretAccessKey:  ${AWS.config.credentials.secretAccessKey}`);\n                //refreshes credentials using AWS.CognitoIdentity.getCredentialsForIdentity()\n                // AWS.config.credentials.refresh(error =&gt; {\n                //     if (error) {\n                //         console.error(error);\n                //     } else {\n                //         // Instantiate aws sdk service objects now that the credentials have been updated.\n                //         // example: var s3 = new AWS.S3();\n                //         console.log(&#x27;Successfully logged!&#x27;);\n                //     }\n                // });\n            },\n\n            onFailure: function (err) {\n                console.log(err.message || JSON.stringify(err));\n            },\n        });\n    });\n}\n\nif (process.env[&#x27;APPNAME_ACCESS_TOKEN&#x27;] &amp;&amp; process.env[&#x27;APPNAME_REFRESH_TOKEN&#x27;]) {\n    cognitoAccessToken = new CognitoAccessToken({ AccessToken: process.env[&#x27;APPNAME_ACCESS_TOKEN&#x27;] });\n    cognitoRefreshToken = new CognitoRefreshToken({ RefreshToken: process.env[&#x27;APPNAME_REFRESH_TOKEN&#x27;] });\n    console.log(`Got tokens from env: `, cognitoAccessToken.getJwtToken(), &quot;\\nRefresh:&quot;, cognitoRefreshToken.getToken());\n    startHTTPServer();\n} else {\n    console.log(`No tokens in ENV getting them via Cognito`);\n    await emailAuthInit();\n    const smsCode = await rl.question(&#x27;What is the SMS Code: &#x27;);\n    await emailAuthCode(smsCode);\n}\n</code></pre><p>The really tricky part was looking at the HTTPS dumped requests and figuring out what kind of AWS Cogntio requests I needed to make and what strings to pass. But this was all reverse engineerable from the information in the request bodies and by reading the AWS Cognito library source code.</p><p>Basically if you find yourself trying to write something similar where you want to recreate an AWS Cognito login flow and see requests that have in the body:</p><ol><li>A request with AuthFlow: CUSTOM_AUTH</li><li>Then a request with ChallengeName: PASSWORD_VERIFIER</li><li>Then a request with ChallengeResponses: PASSWORD_CLAIM_SECRET_BLOCK</li><li>Then ChallengeName: CUSTOM_CHALLENGE</li><li>ChallengeResponses: \\&quot;ANSWER\\&quot;:\\&quot;answerType:generateCode,medium:phone,codeType:login\\&quot;</li><li>&quot;{\\&quot;ChallengeName\\&quot;:\\&quot;CUSTOM_CHALLENGE\\&quot;,\\&quot;ChallengeParameters\\&quot;:{\\&quot;challengeType\\&quot;:\\&quot;code\\&quot;}</li></ol><p>Then the above code should be hackable to get something working for you.</p><p>My auth flow required authorizing via my username and password then doing 2fa using my phone number which was already in their system somehow.\nBecause I started getting a text with a code after I passed the first part of the Cogntio verification with the email and password.</p><p>Hopefully my Cognito client code above is helpful for someone.</p><p>I figured out a bunch of other interesting stuff that I think is useful but I&#x27;ll have to put that into another post.. this post is already a mess of information and is probably hard to follow.</p><p>I did figure out how to send fake touch events. So in this case I could script having the app open then wait a second for the app to load and send touch event to the middle of the screen just to hit the lock or unlock button.</p><p>The hackiest of hacks but it&#x27;s really cool sending these fake touch events. I&#x27;ll write a post about that next.</p><h3>Just some lldb notes:</h3><p>Ever be steppin and you step INTO a jump/function call and just want to get back to where you were?</p><pre><code>thread step-out\n</code></pre><p>will get you back!</p><p>And you can use it to jump over call or bl instructions as well.</p><p>So my LLDB flow was mostly:</p><ol><li>Search for possible places to set breakpoints with:</li></ol><pre><code>image lookup -r -n .*AWSCognito.*\n</code></pre><p>AWSCognito being something related to whatever you want to learn more about. Maybe its refreshToken or something..</p><ol start=\"2\"><li>Then I check that list it generates and see how ridiculously long it is. If I am going to be setting to many breakpoints I work that regex down to be more specific and then set breakpoints with:</li></ol><pre><code>br set -r  .*refreshToken.*\n</code></pre><p>Then when I hit a breakpoint I would read all the variables and pointers I could. I would check the backtrace to see whats going on:</p><pre><code>bt\n</code></pre><p>and from there I could select different &quot;frames&quot; or functions called to get to my breakpoint:</p><pre><code>frame select SOMENUMBERHERE\n</code></pre><p>I would check the registers at each frame:</p><pre><code>register read --all\n</code></pre><p>Although they obviously made the most sense down at the frame you break into.</p><p>For each frame your in if you want to see the full dissassembly of the current function run:</p><pre><code>di -f\n</code></pre><ol start=\"3\"><li>Just start printing out all the info.</li></ol><p>LLDB has nice aliases for the registers that contain function call arguments and can be printed out with:</p><pre><code>po $arg1\npo $arg2\netc...\n</code></pre><ol start=\"4\"><li>Accessing data on objects I found:</li></ol><pre><code>expression -l objc -O -- [$arg1 userPoolConfiguration]\n</code></pre><ol start=\"5\"><li>Creating variables in LLDB:</li></ol><pre><code>expression -l objc -O -- NSURL *$url = [NSURL URLWithString:@&quot;appName://&quot;];\n</code></pre><p>Would create an NSUrl with the lldb variable name $url.\nThen I could test that my method was in fact swizzed correctly with:</p><pre><code>expression -l objc -O -- [[UIApplication sharedApplication].delegate application:[UIApplication sharedApplication] handleOpenURL:$url];\n</code></pre><p>More examples of variables:</p><pre><code>expression id $delegate = (id)[[UIApplication sharedApplication] delegate]\nexpression id $keyWindow= (id)[$delegate window]\nexpression id $root = (id)[$keyWindow rootViewController]\npo $root\n</code></pre><ol start=\"6\"><li>Got a sneaking suspicion some address is really a pointer? Want to see if its an object?\nCast it as an (id) and po it:</li></ol><pre><code>po (id)0x7facaada2c80\n</code></pre><ol start=\"7\"><li>IMPORTANT - You can use</li></ol><pre><code>command script import lldb.macosx.heap\n</code></pre><p>in lldb to get access to some realllllly helpful heap functions. Similar to what Frida provides for searching the heap for objects. Huuuuuuge for me.</p><ol start=\"8\"><li>My .lldbinit file:</li></ol><pre><code>command script import lldb.macosx.heap\ntype summary add --category swift --summary-string &quot;Unmanaged Contains: ${var._value%@}&quot; Swift.Unmanaged&lt;AnyObject&gt;\ncommand script import /Users/bbarrows/lldb/load_swift.py\n# to run lldb &quot;shell&quot; scripts\ncommand alias shsource command source\n# to run a shell command, like `open`\ncommand alias shellcmd platform shell\n# tell lldb to assume swift, not objc\nsettings set target.language Swift\ncommand alias clear-lang settings clear target.language\ncommand alias swiftui_script load_swift /Users/bbarrows/lldb/helpers.swift\n#command script import  /Users/bbarrows/repos/MyLLDB/python/sbt.py\ncommand alias eco expression -l objective-c -O --\ncommand alias ecs expression -l swift -O --\ncommand alias br breakpoint\ncommand alias rr register read\ncommand alias rra register read\ncommand regex ims &#x27;s/(.+)/image lookup -rn %1/&#x27;\ncommand regex z &#x27;s/(.+)/breakpoint set -r %1/&#x27;\ncommand regex mr &#x27;s/(.+) (.+)/memory read --size 8 --format x --count %2 %1/&#x27;\ncommand regex pos  &#x27;s/(.+)/po (const char *)%1/&#x27;\ncommand regex posc  &#x27;s/(.+)/expression -l swift -O -- unsafeBitCast(0x7f8c7b002b30, to: %1.self)/&#x27;\n</code></pre><h3>Useful tools</h3><p>Best tool I think for dumping headers these days is <a href=\"https://github.com/cxnder/ktool\">ktool</a>\nReally nice GUI too and handles the MachO sections that are causing the older header dump tools to fail.</p><p>I also probably learned the most and got the farthest just using lldb and Frida BUT attaching xCode to your running process and then using the xCode Memory Graph was super helpful to figure out what was related to what and what information I could find. For example, I had some Swift class with private properties or whatever that I couldn&#x27;t access but I was able to figure out the offset from the object handle and get a reference to its JWT that way.</p><p>For me Frida and lldb are the most useful tools other then, in this case, just using a tool like Charles Proxy for dumping the https session. I actually was using another tool called Quantum I think but same idea and I can&#x27;t remember the name now. Surge 5 also works fine.. But it&#x27;s pretty buggy and has poort documentation especially if your trying to do stuff like have your mac control it on your phone.</p><h1>Summary</h1><p>I poked around a lot trying a lot of different things. I was hoping to just hook or add and implementation for handling IOS URLSchemes so I could script opening the app and have it lock and unlock the door.</p><p>I couldn&#x27;t find a good way to get a JWT that was always valid. The application will run some Swift code that I wasn&#x27;t able to track down in a relatively sane amount of time so I gave up on getting the JWT and refresh token from the heap/app.</p><p>I ended up looking at the HTTPS requests. Figuring out it was using AWS Cognito. And then re creating my own service that just mimicks whats the lock company does to get me a JWT for their lock control server.</p><p>Now I have a service running that I logged into once, it refreshes the JWT every 30 min, and I can send HTTPS requests to it to lock and unlock my door with a Siri/Shortcut I created.</p>","scope":{"slug":"ios-aws-cognito-reverse-engineering","title":"Reverse engineering an iOS application to allow for integration with shortcuts and Siri - Recreate AWS Cognito authentication and sending fake UITouch events","date":"2023-05-12","author":"bebrws","tags":["Reverse engineering","iOS","aws","cognito","frida","lldb","osx","Siri","shortcuts","UITouch","SwiftUI","Deep linking","IOS URLScheme"]}}},"__N_SSG":true}