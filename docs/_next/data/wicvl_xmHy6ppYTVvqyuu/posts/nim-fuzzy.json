{"pageProps":{"title":"Writing a fuzzy string search algorithm in Nim","dateString":"2020-08-30","slug":"nim-fuzzy","description":"","tags":["nim"],"author":"bebrws","source":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/static/fznim.gif\",\n    \"alt\": \"An animated gif of the fzf like usage of fznim\"\n  })), mdx(\"h2\", null, \"Introducing FZNim\"), mdx(\"p\", null, \"I needed a fuzzy string search algorithm for my fzf like library and this website's gimmicky search bar.\"), mdx(\"p\", null, \"I did see that the Nim documentation actually has an implementation which is used for searching their documentation.\"), mdx(\"p\", null, \"I tried this and I actually ran into a few issues. It also didn't quite get the results I expected. Which just felt bad.\"), mdx(\"p\", null, \"So I wrote my own:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"proc fzfuzzyMatch*(pattern: string, str: string, longestItemLength: int) : tuple[score: int, matched: bool, item: string] =\\n  var\\n    strIndex = 0\\n    patIndex = 0\\n    lastCharMatchedScore = 0\\n    score = 0\\n    numInRow = 0\\n\\n  while (strIndex < str.len) and (patIndex < pattern.len):\\n    var\\n      patternChar = pattern[patIndex].toLowerAscii\\n      strChar     = str[strIndex].toLowerAscii\\n\\n    # Ignore certain characters\\n    if patternChar in {'_', ' ', '.'}:\\n      patIndex += 1\\n      continue\\n    if strChar in {'_', ' ', '.'}:\\n      strIndex += 1\\n      continue\\n\\n    if strIndex == 0 and patternChar == strChar:\\n      score += longestItemLength\\n      lastCharMatchedScore += 2\\n      patIndex += 1\\n      strIndex += 1\\n      numInRow += 1\\n    elif strChar == patternChar:\\n      score += int(longestItemLength/strIndex) * (if numInRow == 0: 1 else: (numInRow * 3))\\n      numInRow += 1\\n      strIndex += 1\\n      patIndex += 1\\n    else:\\n      if not (str[strIndex] in {'_', ' ', '.'}):\\n        numInRow = 0\\n      strIndex += 1\\n\\n\\n  result = (\\n    score:   max(0, int(score)),\\n    matched: (int(score) > 0),\\n    item: str\\n  )\\n\")), mdx(\"p\", null, \"This is actually or obviously VERY simple.\"), mdx(\"p\", null, \"The fzfuzzyMatch function takes two arguments pattern and str.\"), mdx(\"p\", null, \"pattern in the string representing the search string you would be typing in and str would be one of the string from a list of strings you want to search over.\"), mdx(\"p\", null, \"My algorithm weights the results based on the matched character's position in the string and requires the length of the longest string being searched. This is passed in via longestItemLength.\"), mdx(\"p\", null, \"All it does it iterate over both the pattern and str string at the same time. Both are converted to lowercase to prevent any upper lower case search issues.\"), mdx(\"p\", null, \"Then it takes the first charcter in the pattern string (from the search box) and checks the first character in str for a match. If the first character matches the score has longestItemLength added to it. This if statement is on line 22.\"), mdx(\"p\", null, \"The score is just a value we keep adding to as matches happen to rate a string higher or lower in the overall search rankings.\"), mdx(\"p\", null, \"The next elif is when a character is matched that is not the first character. Here the score has the longestItemLength/strIndex \", \"*\", \" numInRow added to it.\"), mdx(\"p\", null, \"longestItemLength/strIndex is just a value that becomes smaller as the matches character moves farther down the string (to the right).\"), mdx(\"p\", null, \"numInRow is the number of characters matched in a row. If a character match is missed then this is reset.\"), mdx(\"p\", null, \"That is basically it!\"), mdx(\"p\", null, \"Pretty simple and provides some pretty nice results. If you check out the example in fznim you can see it highlight the matched characters which is a nice way to visualize some of this too.\"), mdx(\"p\", null, \"To run this example you could checkout the repo and compile it with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"git clone git@github.com:bebrws/fznim.git\\ncd fznim\\nnimble install -y; nim c examples/fzf.nim; cat fznim.nim | ./examples/fzf\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p><img src=\"/static/fznim.gif\" alt=\"An animated gif of the fzf like usage of fznim\"/></p><div style=\"position:relative\"><span style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\">#</span><h2 id=\"Introducing%20FZNim\" class=\"jsx-2373991563\"><a href=\"#Introducing%20FZNim\" class=\"jsx-2373991563\">Introducing FZNim</a></h2></div><p>I needed a fuzzy string search algorithm for my fzf like library and this website&#x27;s gimmicky search bar.</p><p>I did see that the Nim documentation actually has an implementation which is used for searching their documentation.</p><p>I tried this and I actually ran into a few issues. It also didn&#x27;t quite get the results I expected. Which just felt bad.</p><p>So I wrote my own:</p><pre><code>proc fzfuzzyMatch*(pattern: string, str: string, longestItemLength: int) : tuple[score: int, matched: bool, item: string] =\n  var\n    strIndex = 0\n    patIndex = 0\n    lastCharMatchedScore = 0\n    score = 0\n    numInRow = 0\n\n  while (strIndex &lt; str.len) and (patIndex &lt; pattern.len):\n    var\n      patternChar = pattern[patIndex].toLowerAscii\n      strChar     = str[strIndex].toLowerAscii\n\n    # Ignore certain characters\n    if patternChar in {&#x27;_&#x27;, &#x27; &#x27;, &#x27;.&#x27;}:\n      patIndex += 1\n      continue\n    if strChar in {&#x27;_&#x27;, &#x27; &#x27;, &#x27;.&#x27;}:\n      strIndex += 1\n      continue\n\n    if strIndex == 0 and patternChar == strChar:\n      score += longestItemLength\n      lastCharMatchedScore += 2\n      patIndex += 1\n      strIndex += 1\n      numInRow += 1\n    elif strChar == patternChar:\n      score += int(longestItemLength/strIndex) * (if numInRow == 0: 1 else: (numInRow * 3))\n      numInRow += 1\n      strIndex += 1\n      patIndex += 1\n    else:\n      if not (str[strIndex] in {&#x27;_&#x27;, &#x27; &#x27;, &#x27;.&#x27;}):\n        numInRow = 0\n      strIndex += 1\n\n\n  result = (\n    score:   max(0, int(score)),\n    matched: (int(score) &gt; 0),\n    item: str\n  )\n</code></pre><p>This is actually or obviously VERY simple.</p><p>The fzfuzzyMatch function takes two arguments pattern and str.</p><p>pattern in the string representing the search string you would be typing in and str would be one of the string from a list of strings you want to search over.</p><p>My algorithm weights the results based on the matched character&#x27;s position in the string and requires the length of the longest string being searched. This is passed in via longestItemLength.</p><p>All it does it iterate over both the pattern and str string at the same time. Both are converted to lowercase to prevent any upper lower case search issues.</p><p>Then it takes the first charcter in the pattern string (from the search box) and checks the first character in str for a match. If the first character matches the score has longestItemLength added to it. This if statement is on line 22.</p><p>The score is just a value we keep adding to as matches happen to rate a string higher or lower in the overall search rankings.</p><p>The next elif is when a character is matched that is not the first character. Here the score has the longestItemLength/strIndex <!-- -->*<!-- --> numInRow added to it.</p><p>longestItemLength/strIndex is just a value that becomes smaller as the matches character moves farther down the string (to the right).</p><p>numInRow is the number of characters matched in a row. If a character match is missed then this is reset.</p><p>That is basically it!</p><p>Pretty simple and provides some pretty nice results. If you check out the example in fznim you can see it highlight the matched characters which is a nice way to visualize some of this too.</p><p>To run this example you could checkout the repo and compile it with:</p><pre><code>git clone git@github.com:bebrws/fznim.git\ncd fznim\nnimble install -y; nim c examples/fzf.nim; cat fznim.nim | ./examples/fzf\n</code></pre>","scope":{"slug":"nim-fuzzy","title":"Writing a fuzzy string search algorithm in Nim","date":"2020-08-30","author":"bebrws","tags":["nim"]}}},"__N_SSG":true}