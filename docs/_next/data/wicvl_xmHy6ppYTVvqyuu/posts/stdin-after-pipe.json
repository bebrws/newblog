{"pageProps":{"title":"Getting Input from STDIN after piping in STDIN to a C or Nim program","dateString":"2020-01-22","slug":"stdin-after-pipe","description":"","tags":["linux"],"author":"bebrws","source":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Writing my fzf like Nim library/application I ran into an issue. I could pipe input into the command line utility but then after processing the input from the piped\"), mdx(\"p\", null, \"STDIN I was unable to get input from the user via getch\"), mdx(\"p\", null, \"I actually found the answer was a few lines of code.\"), mdx(\"p\", null, \"In C:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"#include <stdio.h>\\n#include <unistd.h>\\n\\n    if (!isatty(fileno(stdin))) {\\n        // duplicate stdin file descriptor and open it as a FILE*\\n        input = fdopen(dup(fileno(stdin)), \\\"r\\\");\\n        // reopen stdin on the terminal (assuming stdout is still connected to the terminal)\\n        freopen(ttyname(fileno(stdout)), \\\"r\\\", stdin);\\n    }\\n\\n\")), mdx(\"p\", null, \"In Nim:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\nimport posix\\nimport os\\nimport terminal\\n\\nproc fdopen(f: cint, mode: cstring): File {.\\nimportc: \\\"fdopen\\\", header: \\\"<stdio.h>\\\", tags: [].}\\n\\nproc freopen(filename, mode: cstring, stream: File): File {.\\nimportc: \\\"freopen\\\", nodecl.}\\n\\nif getFileInfo(stdin).id.file != 37:\\nvar stdindup = dup(c_fileno(stdin))\\nvar input = fdopen(stdindup, cstring(\\\"r\\\"))\\ndiscard freopen(ttyname(c_fileno(stdout)), cstring(\\\"r\\\"), stdin)\\n\\n\")), mdx(\"p\", null, \"Note that c_fdopen and c_freopen should exist in the nim standard library like they do above. I was just having trouble importing them\"));\n}\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p>Writing my fzf like Nim library/application I ran into an issue. I could pipe input into the command line utility but then after processing the input from the piped</p><p>STDIN I was unable to get input from the user via getch</p><p>I actually found the answer was a few lines of code.</p><p>In C:</p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\n    if (!isatty(fileno(stdin))) {\n        // duplicate stdin file descriptor and open it as a FILE*\n        input = fdopen(dup(fileno(stdin)), &quot;r&quot;);\n        // reopen stdin on the terminal (assuming stdout is still connected to the terminal)\n        freopen(ttyname(fileno(stdout)), &quot;r&quot;, stdin);\n    }\n\n</code></pre><p>In Nim:</p><pre><code>\nimport posix\nimport os\nimport terminal\n\nproc fdopen(f: cint, mode: cstring): File {.\nimportc: &quot;fdopen&quot;, header: &quot;&lt;stdio.h&gt;&quot;, tags: [].}\n\nproc freopen(filename, mode: cstring, stream: File): File {.\nimportc: &quot;freopen&quot;, nodecl.}\n\nif getFileInfo(stdin).id.file != 37:\nvar stdindup = dup(c_fileno(stdin))\nvar input = fdopen(stdindup, cstring(&quot;r&quot;))\ndiscard freopen(ttyname(c_fileno(stdout)), cstring(&quot;r&quot;), stdin)\n\n</code></pre><p>Note that c_fdopen and c_freopen should exist in the nim standard library like they do above. I was just having trouble importing them</p>","scope":{"slug":"stdin-after-pipe","title":"Getting Input from STDIN after piping in STDIN to a C or Nim program","date":"2020-01-22","author":"bebrws","tags":["linux"]}}},"__N_SSG":true}