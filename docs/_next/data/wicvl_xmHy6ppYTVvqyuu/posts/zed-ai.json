{"pageProps":{"title":"Zed AI Alternative or My Approach Prior to Zed AI","dateString":"2024-08-20","slug":"zed-ai","description":"","tags":["Zed","Editor","AI","RAG","LLM","Scripting","Shell"],"author":"bebrws","source":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"My Zed AI Before there was Zed AI\"), mdx(\"h2\", null, \"RAG AKA Context? and my Shell Script\"), mdx(\"p\", null, \"So the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://zed.dev\"\n  }, \"Zed IDE\"), \" just released a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://zed.dev/blog/zed-ai\"\n  }, \"huge blog post\"), \" about \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://zed.dev/ai\"\n  }, \"Zed AI\"), \". And this is actually a really nice feature.\"), mdx(\"p\", null, \"I really like how it\\u2019s implemented (easy to use), how it is supposed to be extendable, but mostly just how easy it is to use, especially with a huge number of different APIs/LLMs. It is super easy to configure and then select a different LLM to answer your question. However, what I have been looking for is a way to easily provide more context to the LLM. I wanted to be able to open some random repository and ask the LLM a question about the code, maybe even ask it to implement support for Arm64 (SENinja cough cough\\u2026 which actually worked pretty well).\"), mdx(\"p\", null, \"So, the major feature for me is the ability to easily add files/folders to your prompt\\u2019s context. You can use this /file command to select files or folders, and all of that content is added to the beginning of the prompt as it appears. It is really easy to use, and I love it.\"), mdx(\"p\", null, \"Before this, I was doing the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-shell\"\n  }, \"#!/usr/bin/env bash\\n\\n# Function to check if a file is binary\\nis_binary() {\\n    file --mime-encoding \\\"$1\\\" | grep -q binary\\n}\\n\\n# Function to get file type\\nget_file_type() {\\n    file -b \\\"$1\\\"\\n}\\n\\n# Get all tracked files. Change this line if you only want to include certain files or folders like \\\"*.py\\\" or \\\"src/\\\"\\nfiles=$(git ls-files)\\n\\n# Write header\\necho \\\"Below is the combined text of all files in the git repository $(basename $(git rev-parse --show-toplevel))\\\"\\necho \\\"The list of files include is listed below ending in a new line with just the following characters: \\\\\\\"~~~~~~~~~~\\\\\\\"\\\"\\necho \\\"$(git ls-files)\\\"\\necho \\\"~~~~~~~~~~\\\"\\necho -e \\\"\\\\n\\\\n\\\\n\\\\n\\\"\\necho \\\"Each file is preceded by a delimiter containing metadata about the file.\\\"\\necho \\\"The metadata lines all begin and end in the strings \\\\\\\"===\\\\\\\"\\\"\\necho \\\"The metadata lines which separate each file contain 3 different lines of metadata\\\"\\necho \\\"The first is the filename which is prefixed by the string \\\\\\\"=== FILE: \\\\\\\" and ending in the string \\\\\\\"===\\\\\\\"\\\"\\necho \\\"The second is the file type which is prefixed by the string \\\\\\\"=== TYPE: \\\\\\\" and ending in the string \\\\\\\"===\\\\\\\"\\\"\\necho \\\"The third is the line above the start of the actual file contents. It will always be the string \\\\\\\"=== BEGIN FILE CONTENT ===\\\\\\\"\\\"\\necho -e \\\"\\\\n\\\\n--- BELOW WE START THE LISTING OF FILE METADATA FOLLOWED BY THE FILE CONTENT ---\\\"\\n\\n# Process each file\\nwhile IFS= read -r file; do\\n    if [ -f \\\"$file\\\" ] && ! is_binary \\\"$file\\\"; then\\n        file_type=$(get_file_type \\\"$file\\\")\\n\\n        echo \\\"\\\"\\n        echo \\\"=== FILE: $file ===\\\"\\n        echo \\\"=== TYPE: $file_type ===\\\"\\n        echo \\\"=== BEGIN FILE CONTENT ===\\\"\\n        cat \\\"$file\\\"\\n        echo \\\"=== END FILE CONTENT ===\\\"\\n    fi\\ndone <<<\\\"$files\\\"\\n\\necho \\\"--- END FILE COMPILATION ---\\\"\\n\")), mdx(\"p\", null, \"I had this script named gatherRepoSource, and although I couldn\\u2019t easily select file by file or folder by folder with a nice GUI, I could change this line:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"files=$(git ls-files)\\n\")), mdx(\"p\", null, \"to say something like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"files=$(git ls-files | grep \\\\.py)\\n\")), mdx(\"p\", null, \"to only inlude python files for example.\"), mdx(\"p\", null, \"I would then just run this from any repository I was working in and pipe this out to a file (it was chmod +x and in $PATH):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"gatherRepoSource > PromptContext.txt\\n\")), mdx(\"p\", null, \"I could then either drag and drop that file into Claude, for example, or copy and paste the contents into another LLM and follow that content with my actual question.\"), mdx(\"p\", null, \"It actually worked really well.\"), mdx(\"p\", null, \"I think Zed\\u2019s implementation is obviously a much nicer approach than using something like this script, and I am excited to have this tool. It is actually a little scary how effective it is, but the future is coming, and all I can do is try to embrace it and move with it.\"));\n}\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<div style=\"position:relative\"><span style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\">#</span><h1 id=\"My%20Zed%20AI%20Before%20there%20was%20Zed%20AI\" class=\"jsx-2373991563\"><a href=\"#My%20Zed%20AI%20Before%20there%20was%20Zed%20AI\" class=\"jsx-2373991563\">My Zed AI Before there was Zed AI</a></h1></div><div style=\"position:relative\"><span style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\">#</span><h2 id=\"RAG%20AKA%20Context%3f%20and%20my%20Shell%20Script\" class=\"jsx-2373991563\"><a href=\"#RAG%20AKA%20Context%3f%20and%20my%20Shell%20Script\" class=\"jsx-2373991563\">RAG AKA Context? and my Shell Script</a></h2></div><p>So the <a href=\"https://zed.dev\">Zed IDE</a> just released a <a href=\"https://zed.dev/blog/zed-ai\">huge blog post</a> about <a href=\"https://zed.dev/ai\">Zed AI</a>. And this is actually a really nice feature.</p><p>I really like how it’s implemented (easy to use), how it is supposed to be extendable, but mostly just how easy it is to use, especially with a huge number of different APIs/LLMs. It is super easy to configure and then select a different LLM to answer your question. However, what I have been looking for is a way to easily provide more context to the LLM. I wanted to be able to open some random repository and ask the LLM a question about the code, maybe even ask it to implement support for Arm64 (SENinja cough cough… which actually worked pretty well).</p><p>So, the major feature for me is the ability to easily add files/folders to your prompt’s context. You can use this /file command to select files or folders, and all of that content is added to the beginning of the prompt as it appears. It is really easy to use, and I love it.</p><p>Before this, I was doing the following:</p><pre><code class=\"language-shell\">#!/usr/bin/env bash\n\n# Function to check if a file is binary\nis_binary() {\n    file --mime-encoding &quot;$1&quot; | grep -q binary\n}\n\n# Function to get file type\nget_file_type() {\n    file -b &quot;$1&quot;\n}\n\n# Get all tracked files. Change this line if you only want to include certain files or folders like &quot;*.py&quot; or &quot;src/&quot;\nfiles=$(git ls-files)\n\n# Write header\necho &quot;Below is the combined text of all files in the git repository $(basename $(git rev-parse --show-toplevel))&quot;\necho &quot;The list of files include is listed below ending in a new line with just the following characters: \\&quot;~~~~~~~~~~\\&quot;&quot;\necho &quot;$(git ls-files)&quot;\necho &quot;~~~~~~~~~~&quot;\necho -e &quot;\\n\\n\\n\\n&quot;\necho &quot;Each file is preceded by a delimiter containing metadata about the file.&quot;\necho &quot;The metadata lines all begin and end in the strings \\&quot;===\\&quot;&quot;\necho &quot;The metadata lines which separate each file contain 3 different lines of metadata&quot;\necho &quot;The first is the filename which is prefixed by the string \\&quot;=== FILE: \\&quot; and ending in the string \\&quot;===\\&quot;&quot;\necho &quot;The second is the file type which is prefixed by the string \\&quot;=== TYPE: \\&quot; and ending in the string \\&quot;===\\&quot;&quot;\necho &quot;The third is the line above the start of the actual file contents. It will always be the string \\&quot;=== BEGIN FILE CONTENT ===\\&quot;&quot;\necho -e &quot;\\n\\n--- BELOW WE START THE LISTING OF FILE METADATA FOLLOWED BY THE FILE CONTENT ---&quot;\n\n# Process each file\nwhile IFS= read -r file; do\n    if [ -f &quot;$file&quot; ] &amp;&amp; ! is_binary &quot;$file&quot;; then\n        file_type=$(get_file_type &quot;$file&quot;)\n\n        echo &quot;&quot;\n        echo &quot;=== FILE: $file ===&quot;\n        echo &quot;=== TYPE: $file_type ===&quot;\n        echo &quot;=== BEGIN FILE CONTENT ===&quot;\n        cat &quot;$file&quot;\n        echo &quot;=== END FILE CONTENT ===&quot;\n    fi\ndone &lt;&lt;&lt;&quot;$files&quot;\n\necho &quot;--- END FILE COMPILATION ---&quot;\n</code></pre><p>I had this script named gatherRepoSource, and although I couldn’t easily select file by file or folder by folder with a nice GUI, I could change this line:</p><pre><code>files=$(git ls-files)\n</code></pre><p>to say something like:</p><pre><code>files=$(git ls-files | grep \\.py)\n</code></pre><p>to only inlude python files for example.</p><p>I would then just run this from any repository I was working in and pipe this out to a file (it was chmod +x and in $PATH):</p><pre><code>gatherRepoSource &gt; PromptContext.txt\n</code></pre><p>I could then either drag and drop that file into Claude, for example, or copy and paste the contents into another LLM and follow that content with my actual question.</p><p>It actually worked really well.</p><p>I think Zed’s implementation is obviously a much nicer approach than using something like this script, and I am excited to have this tool. It is actually a little scary how effective it is, but the future is coming, and all I can do is try to embrace it and move with it.</p>","scope":{"slug":"zed-ai","title":"Zed AI Alternative or My Approach Prior to Zed AI","date":"2024-08-20","author":"bebrws","tags":["Zed","Editor","AI","RAG","LLM","Scripting","Shell"]}}},"__N_SSG":true}