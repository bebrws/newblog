{"pageProps":{"title":"ZSH shortcut (keybinding) to replace cursor selected word with your preset choice","dateString":"2020-11-28","slug":"zsh-widgets","description":"","tags":["zsh"],"author":"bebrws","source":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"ZSH Is Amazingly Powerful\"), mdx(\"p\", null, \"One of my favorite features is actually it's \\\"line editor\\\" Zle.\"), mdx(\"p\", null, \"Zle is what powers ZSH' input. It provides a quick and easy way to jump through words and syntax, forwards and backwards, providing powerful features all for the sole function of editing one single line (usually - of course it can do more).\"), mdx(\"p\", null, \"So far, I have found that the easiest way to use Zle is with ZSH Widgets.\"), mdx(\"p\", null, \"These Widgets can be bound to keys with bind-key. In this Widgets you are allowed to use the Zle line editor and there you can do cool things like show a message below the prompt. Take input below the prompt. Edit the current prompt. Read the current text being entered into the prompt. Etc etc..\"), mdx(\"p\", null, \"To send keys to the terminal, effectively typing where your cursor currently is you can run:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"export AVAR=\\\"STRING\\\"; Zle -U $AVAR\\n\")), mdx(\"p\", null, \"and STRING will appear where your cursor is as if you had typed it.\"), mdx(\"p\", null, \"It is amazing how powerful a shell can be. You have zsh hooks to run zsh functions on certain events such as changing directories or on signals, you can edit, view and analyze the current prompt all the while having the ability to run processes and manipulate the output.\"), mdx(\"h2\", null, \"Creating a ZSH Widget\"), mdx(\"p\", null, \"I use fzf so that I can quickly script user interfaces that are fast and easy to use. This is going to be another widget where I end up using fzf to take care of what could potentially be a repetitive and annoying task.\"), mdx(\"p\", null, \"Use case and a question:\"), mdx(\"p\", null, \"There are always multiple versions of clang and ar installed on my laptop. The compiler and linker that ships with OSX and that come with XCode are different.\"), mdx(\"p\", null, \"I don't know why and would love to know actually if anyone can tell me why the ar binary (linker) that is part of a fresh OSX install won't create binaries that can be linked or compiled with another clang build. ( This is not an issue with libtool. ) I get error messages sometimes saying that clang is trying to link a file for architecure A with the same arcitecture A. (It will say something like \\\"unable to link the binary compiled for x86_64 with the other x86_64 binary\\\".)\"), mdx(\"p\", null, \"Anyhow, I hate using xcrun to find the location of the toolchain files and sometimes require CFLAGS or linker arguments and other things I want to quickly look up (and I don't want in an environment variable). So I created the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function replacecurrentword() {\\n    export CURRENTWORD=\\\"${LBUFFER/* /}${RBUFFER/ */}\\\"\\n\\n    Zle kill-word\\n    Zle backward-kill-word\\n\\n  if [ -z \\\"$CURRENTWORD\\\" ]; then\\n    export REPLACEMENT=\\\"$(cat ~/.my_inserts| fzf  )\\\"\\n  else\\n    export REPLACEMENT=\\\"$(cat ~/.my_inserts| fzf  -q $CURRENTWORD)\\\"\\n  fi\\n\\n    Zle -M \\\"Replacing $CURRENTWORD with $REPLACEMENT\\\"\\n\\n    Zle -U \\\"$REPLACEMENT\\\"\\n}\\nZle -N replacecurrentword\\nbindkey \\\"^rr\\\" replacecurrentword\\n\")), mdx(\"p\", null, \"Now this is bound to the following:\\nControl + r + r\"), mdx(\"p\", null, \"Then I go and create a file at ~/.my_inserts\"), mdx(\"p\", null, \"Currently mine looks like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"/usr/local/Cellar/llvm/11.0.0/bin/clang\\n/usr/local/Cellar/llvm/11.0.0/bin/ar\\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang\\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ar\\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib\\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld\\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang  -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk\\n\")), mdx(\"p\", null, \"Now I can be typing say:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"./configure CC= clang\\n\")), mdx(\"p\", null, \"and with my cursor over clang I can hit Control + r + r\"), mdx(\"p\", null, \"Then select one of the clang strings I have selected to set the compiler for the configuration script.\"), mdx(\"p\", null, \"I may need to jump back and add some quotes around the replaced string in this example, but in most cases I wouldnt't. Only if I had to deal with some OSX specific file path probably and was required to monkey around with sysroot.\"), mdx(\"p\", null, \"This function could do that.. it could do a lot of things most likely\"), mdx(\"h2\", null, \"An Extra Couple Scripts\"), mdx(\"h3\", null, \"Assuming you have a directory named repos in your home directory that you travel to often\"), mdx(\"p\", null, \"With this you can begin typing a directory, then lazily or hastily hit\"), mdx(\"p\", null, \"Control + r + r\"), mdx(\"p\", null, \"Then fzf will popup with the word you were typing already into the search and you can select one of the repos you want to goto.\"), mdx(\"p\", null, \"The only requirements for ALL of this functionality is 1. fzf binary:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"brew install fzf\\n\")), mdx(\"p\", null, \"and 1. zsh which comes standard with OSX now.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\nfunction goto_repos_dir_fzf() {\\n  export CURRENTWORD=\\\"${LBUFFER/* /}${RBUFFER/ */}\\\"\\n\\n    Zle kill-word\\n    Zle backward-kill-word\\n\\n\\n    if [ -z \\\"$CURRENTWORD\\\" ]; then\\n    eval code \\\"$HOME/repos/$(ls ~/repos | fzf)\\\"\\n  else\\n    eval code \\\"$HOME/repos/$(ls ~/repos | fzf -q $CURRENTWORD)\\\"\\n  fi\\n}\\nZle -N goto_repos_dir_fzf\\nbindkey \\\"^re\\\" goto_repos_dir_fzf\\n\")), mdx(\"h3\", null, \"Killing Processes\"), mdx(\"p\", null, \"If there are a few processes you need to get rid of. You could:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\nfunction kill_process_using_fzf() {\\n  export CURRENTWORD=\\\"${LBUFFER/* /}${RBUFFER/ */}\\\"\\n\\n  Zle kill-word\\n  Zle backward-kill-word\\n\\n  if [ -z \\\"$CURRENTWORD\\\" ]; then\\n    sudo kill -9 $(ps -efc | fzf -m  | awk '{print $2}')\\n  else\\n    sudo kill -9 $(ps -efc | fzf -m -q $CURRENTWORD | awk '{print $2}')\\n  fi\\n}\\nZle -N kill_process_using_fzf\\nbindkey \\\"^pp\\\" kill_process_using_fzf\\n\\n\")), mdx(\"p\", null, \"Control + p + p now will bring up a nice menu where you can use the tab key to select multiple processes. On enter they will be killed.\"));\n}\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<div style=\"position:relative\"><span style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\">#</span><h1 id=\"ZSH%20Is%20Amazingly%20Powerful\" class=\"jsx-2373991563\"><a href=\"#ZSH%20Is%20Amazingly%20Powerful\" class=\"jsx-2373991563\">ZSH Is Amazingly Powerful</a></h1></div><p>One of my favorite features is actually it&#x27;s &quot;line editor&quot; Zle.</p><p>Zle is what powers ZSH&#x27; input. It provides a quick and easy way to jump through words and syntax, forwards and backwards, providing powerful features all for the sole function of editing one single line (usually - of course it can do more).</p><p>So far, I have found that the easiest way to use Zle is with ZSH Widgets.</p><p>These Widgets can be bound to keys with bind-key. In this Widgets you are allowed to use the Zle line editor and there you can do cool things like show a message below the prompt. Take input below the prompt. Edit the current prompt. Read the current text being entered into the prompt. Etc etc..</p><p>To send keys to the terminal, effectively typing where your cursor currently is you can run:</p><pre><code>export AVAR=&quot;STRING&quot;; Zle -U $AVAR\n</code></pre><p>and STRING will appear where your cursor is as if you had typed it.</p><p>It is amazing how powerful a shell can be. You have zsh hooks to run zsh functions on certain events such as changing directories or on signals, you can edit, view and analyze the current prompt all the while having the ability to run processes and manipulate the output.</p><div style=\"position:relative\"><span style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\">#</span><h2 id=\"Creating%20a%20ZSH%20Widget\" class=\"jsx-2373991563\"><a href=\"#Creating%20a%20ZSH%20Widget\" class=\"jsx-2373991563\">Creating a ZSH Widget</a></h2></div><p>I use fzf so that I can quickly script user interfaces that are fast and easy to use. This is going to be another widget where I end up using fzf to take care of what could potentially be a repetitive and annoying task.</p><p>Use case and a question:</p><p>There are always multiple versions of clang and ar installed on my laptop. The compiler and linker that ships with OSX and that come with XCode are different.</p><p>I don&#x27;t know why and would love to know actually if anyone can tell me why the ar binary (linker) that is part of a fresh OSX install won&#x27;t create binaries that can be linked or compiled with another clang build. ( This is not an issue with libtool. ) I get error messages sometimes saying that clang is trying to link a file for architecure A with the same arcitecture A. (It will say something like &quot;unable to link the binary compiled for x86_64 with the other x86_64 binary&quot;.)</p><p>Anyhow, I hate using xcrun to find the location of the toolchain files and sometimes require CFLAGS or linker arguments and other things I want to quickly look up (and I don&#x27;t want in an environment variable). So I created the following:</p><pre><code>function replacecurrentword() {\n    export CURRENTWORD=&quot;${LBUFFER/* /}${RBUFFER/ */}&quot;\n\n    Zle kill-word\n    Zle backward-kill-word\n\n  if [ -z &quot;$CURRENTWORD&quot; ]; then\n    export REPLACEMENT=&quot;$(cat ~/.my_inserts| fzf  )&quot;\n  else\n    export REPLACEMENT=&quot;$(cat ~/.my_inserts| fzf  -q $CURRENTWORD)&quot;\n  fi\n\n    Zle -M &quot;Replacing $CURRENTWORD with $REPLACEMENT&quot;\n\n    Zle -U &quot;$REPLACEMENT&quot;\n}\nZle -N replacecurrentword\nbindkey &quot;^rr&quot; replacecurrentword\n</code></pre><p>Now this is bound to the following:\nControl + r + r</p><p>Then I go and create a file at ~/.my_inserts</p><p>Currently mine looks like:</p><pre><code>/usr/local/Cellar/llvm/11.0.0/bin/clang\n/usr/local/Cellar/llvm/11.0.0/bin/ar\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ar\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang  -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk\n</code></pre><p>Now I can be typing say:</p><pre><code>./configure CC= clang\n</code></pre><p>and with my cursor over clang I can hit Control + r + r</p><p>Then select one of the clang strings I have selected to set the compiler for the configuration script.</p><p>I may need to jump back and add some quotes around the replaced string in this example, but in most cases I wouldnt&#x27;t. Only if I had to deal with some OSX specific file path probably and was required to monkey around with sysroot.</p><p>This function could do that.. it could do a lot of things most likely</p><div style=\"position:relative\"><span style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\">#</span><h2 id=\"An%20Extra%20Couple%20Scripts\" class=\"jsx-2373991563\"><a href=\"#An%20Extra%20Couple%20Scripts\" class=\"jsx-2373991563\">An Extra Couple Scripts</a></h2></div><div style=\"position:relative\"><span style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\">#</span><h3 id=\"Assuming%20you%20have%20a%20directory%20named%20repos%20in%20your%20home%20directory%20that%20you%20travel%20to%20often\" class=\"jsx-2373991563\"><a href=\"#Assuming%20you%20have%20a%20directory%20named%20repos%20in%20your%20home%20directory%20that%20you%20travel%20to%20often\" class=\"jsx-2373991563\">Assuming you have a directory named repos in your home directory that you travel to often</a></h3></div><p>With this you can begin typing a directory, then lazily or hastily hit</p><p>Control + r + r</p><p>Then fzf will popup with the word you were typing already into the search and you can select one of the repos you want to goto.</p><p>The only requirements for ALL of this functionality is 1. fzf binary:</p><pre><code>brew install fzf\n</code></pre><p>and 1. zsh which comes standard with OSX now.</p><pre><code>\nfunction goto_repos_dir_fzf() {\n  export CURRENTWORD=&quot;${LBUFFER/* /}${RBUFFER/ */}&quot;\n\n    Zle kill-word\n    Zle backward-kill-word\n\n\n    if [ -z &quot;$CURRENTWORD&quot; ]; then\n    eval code &quot;$HOME/repos/$(ls ~/repos | fzf)&quot;\n  else\n    eval code &quot;$HOME/repos/$(ls ~/repos | fzf -q $CURRENTWORD)&quot;\n  fi\n}\nZle -N goto_repos_dir_fzf\nbindkey &quot;^re&quot; goto_repos_dir_fzf\n</code></pre><div style=\"position:relative\"><span style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\">#</span><h3 id=\"Killing%20Processes\" class=\"jsx-2373991563\"><a href=\"#Killing%20Processes\" class=\"jsx-2373991563\">Killing Processes</a></h3></div><p>If there are a few processes you need to get rid of. You could:</p><pre><code>\nfunction kill_process_using_fzf() {\n  export CURRENTWORD=&quot;${LBUFFER/* /}${RBUFFER/ */}&quot;\n\n  Zle kill-word\n  Zle backward-kill-word\n\n  if [ -z &quot;$CURRENTWORD&quot; ]; then\n    sudo kill -9 $(ps -efc | fzf -m  | awk &#x27;{print $2}&#x27;)\n  else\n    sudo kill -9 $(ps -efc | fzf -m -q $CURRENTWORD | awk &#x27;{print $2}&#x27;)\n  fi\n}\nZle -N kill_process_using_fzf\nbindkey &quot;^pp&quot; kill_process_using_fzf\n\n</code></pre><p>Control + p + p now will bring up a nice menu where you can use the tab key to select multiple processes. On enter they will be killed.</p>","scope":{"slug":"zsh-widgets","title":"ZSH shortcut (keybinding) to replace cursor selected word with your preset choice","date":"2020-11-28","author":"bebrws","tags":["zsh"]}}},"__N_SSG":true}