{"pageProps":{"title":"ZSH Setup to Run the Last Command/Prompt After Sending a Few Empty Lines","dateString":"2024-08-26","slug":"zsh-run-last-command-empty-prompt","description":"","tags":["ZSH","shell","zsh-setup","scripting"],"author":"bebrws","source":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/static/repeat-command.mov.gif\",\n    \"alt\": \"A gif showing this shell script in action where after sending 2 empty command prompts the last non empty command prompt is run\"\n  })), mdx(\"h1\", null, \"Why do this? What does this do?\"), mdx(\"p\", null, \"After running a command in the terminal, I often find myself needing to run the same command again. This is especially true when I am working on a project and need to run the same command multiple times in a row.\"), mdx(\"p\", null, \"Or maybe I am remoting into my laptop from my phone and need to run a command that is too long to type out.\"), mdx(\"p\", null, \"I want an easy way to run the last command again without having to type it out or use the up arrow key to find it.\"), mdx(\"p\", null, \"So this script keeps track of the last non-empty ZSH command prompt/buffer and runs it whenever I send a few empty lines by pressing the enter key 2 times in a row.\"), mdx(\"p\", null, \"This count feels like a safe number of required empty lines before running the last command. It is unlikely that I would accidentally run the last command by sending a few empty lines in a row. While being easy and quick enough to do that I can deal with the previous mentioned issues easily.\"), mdx(\"h1\", null, \"Setup\"), mdx(\"p\", null, \"I am on a Mac so I am using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$HOME/.config\"), \" directory. I created a file at: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$HOME/.config/zsh-rerun-on-empty-prompt.zsh\"), \" with the contents:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-zsh\"\n  }, \"\\n# Initialize variables\\nexport EMPTY_PROMPT_COUNT=0\\nexport LAST_COMMAND=\\\"\\\"\\n\\n# Ignore new lines from \\\"control-c\\\"\\nfunction TRAPINT() {\\n    export EMPTY_PROMPT_COUNT=0\\n}\\n\\n# Function to be called before each prompt\\nfunction preexec() {\\n  export EMPTY_PROMPT_COUNT=0\\n  if [[ -n $1 ]]; then\\n    export LAST_COMMAND=$1\\n  fi\\n}\\n\\n# Function to be called after each command\\nfunction precmd() {\\n  if [[ $EMPTY_PROMPT_COUNT -eq 4 && -n $LAST_COMMAND ]]; then\\n    echo \\\"Executing: $LAST_COMMAND\\\"\\n    eval \\\"$LAST_COMMAND\\\"\\n    export EMPTY_PROMPT_COUNT=0\\n  elif [[ -z $BUFFER ]]; then\\n    export EMPTY_PROMPT_COUNT=$((EMPTY_PROMPT_COUNT+1))\\n  else\\n    export EMPTY_PROMPT_COUNT=0\\n  fi\\n}\\n\\n# Set up the hooks\\nautoload -Uz add-zsh-hook\\nadd-zsh-hook preexec preexec\\nadd-zsh-hook precmd precmd\\n\")), mdx(\"p\", null, \"Then I added the following to my \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$HOME/.zshrc\"), \" file:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-zsh\"\n  }, \"source $HOME/.config/zsh-rerun-on-empty-prompt.zsh\\n\")), mdx(\"p\", null, \"Pretty simple to do! \"));\n}\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p><img src=\"/static/repeat-command.mov.gif\" alt=\"A gif showing this shell script in action where after sending 2 empty command prompts the last non empty command prompt is run\"/></p><h1>Why do this? What does this do?</h1><p>After running a command in the terminal, I often find myself needing to run the same command again. This is especially true when I am working on a project and need to run the same command multiple times in a row.</p><p>Or maybe I am remoting into my laptop from my phone and need to run a command that is too long to type out.</p><p>I want an easy way to run the last command again without having to type it out or use the up arrow key to find it.</p><p>So this script keeps track of the last non-empty ZSH command prompt/buffer and runs it whenever I send a few empty lines by pressing the enter key 2 times in a row.</p><p>This count feels like a safe number of required empty lines before running the last command. It is unlikely that I would accidentally run the last command by sending a few empty lines in a row. While being easy and quick enough to do that I can deal with the previous mentioned issues easily.</p><h1>Setup</h1><p>I am on a Mac so I am using the <code>$HOME/.config</code> directory. I created a file at: <code>$HOME/.config/zsh-rerun-on-empty-prompt.zsh</code> with the contents:</p><pre><code class=\"language-zsh\">\n# Initialize variables\nexport EMPTY_PROMPT_COUNT=0\nexport LAST_COMMAND=&quot;&quot;\n\n# Ignore new lines from &quot;control-c&quot;\nfunction TRAPINT() {\n    export EMPTY_PROMPT_COUNT=0\n}\n\n# Function to be called before each prompt\nfunction preexec() {\n  export EMPTY_PROMPT_COUNT=0\n  if [[ -n $1 ]]; then\n    export LAST_COMMAND=$1\n  fi\n}\n\n# Function to be called after each command\nfunction precmd() {\n  if [[ $EMPTY_PROMPT_COUNT -eq 4 &amp;&amp; -n $LAST_COMMAND ]]; then\n    echo &quot;Executing: $LAST_COMMAND&quot;\n    eval &quot;$LAST_COMMAND&quot;\n    export EMPTY_PROMPT_COUNT=0\n  elif [[ -z $BUFFER ]]; then\n    export EMPTY_PROMPT_COUNT=$((EMPTY_PROMPT_COUNT+1))\n  else\n    export EMPTY_PROMPT_COUNT=0\n  fi\n}\n\n# Set up the hooks\nautoload -Uz add-zsh-hook\nadd-zsh-hook preexec preexec\nadd-zsh-hook precmd precmd\n</code></pre><p>Then I added the following to my <code>$HOME/.zshrc</code> file:</p><pre><code class=\"language-zsh\">source $HOME/.config/zsh-rerun-on-empty-prompt.zsh\n</code></pre><p>Pretty simple to do! </p>","scope":{"slug":"zsh-run-last-command-empty-prompt","title":"ZSH Setup to Run the Last Command/Prompt After Sending a Few Empty Lines","date":"2024-08-26","author":"bebrws","tags":["ZSH","shell","zsh-setup","scripting"]}}},"__N_SSG":true}