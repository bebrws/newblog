{"pageProps":{"title":"Joystick Mouse With Zoom and Scroll","dateString":"2024-11-28","slug":"mouse","description":"","tags":["Arduino","Mouse","USB","HID"],"author":"bebrws","source":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"My Joystick Mouse With Zoom and Scroll\"), mdx(\"p\", null, \"Just a little side project I thought was pretty cool. It actually works really well and is easy to get going \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"wired\"), \". \"), mdx(\"p\", null, \"Creating a wireless mouse is actually much more work than I expected and I am focusing elsewhere currently but thought this mouse was pretty interesting and fun.\"), mdx(\"p\", null, \"It is actually really usable and I really like the zoom toggle and scroll button that I have added.\"), mdx(\"video\", {\n    controls: true,\n    style: {\n      width: '100%'\n    }\n  }, mdx(\"source\", {\n    src: \"/static/mouse.mp4\",\n    type: \"video/mp4\"\n  }), mdx(\"source\", {\n    src: \"/static/mouse.mov\",\n    type: \"video/quicktime\"\n  }), \"Your browser does not support the video tag. This is a video of me demoing the mouse.\"), mdx(\"video\", {\n    controls: true,\n    style: {\n      width: '100%'\n    }\n  }, mdx(\"source\", {\n    src: \"/static/mouse2.mp4\",\n    type: \"video/mp4\"\n  }), mdx(\"source\", {\n    src: \"/static/mouse2.mov\",\n    type: \"video/quicktime\"\n  }), \"Your browser does not support the video tag. This is a video of me demoing the mouse.\"), mdx(\"h2\", null, \"Code for Arduino Uno R4\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"#include <Mouse.h>    // Built-in library for mouse emulation\\n#include <Keyboard.h> // Built-in library for keyboard emulation\\n\\nconst int joystickXPin = A1;\\nconst int joystickYPin = A0;\\nconst int joystickClickPin = 2;\\nconst int signalPin = 4; // Define the signal pin\\nconst int buttonPins[] = {5, 6, 7, 8}; // Pins for additional buttons\\nconst int numButtons = sizeof(buttonPins) / sizeof(buttonPins[0]);\\n\\n// Joystick center values and dead zone for stability\\nconst int centerX = 506;\\nconst int centerY = 513;\\nconst int deadzone = 20; // Adjust for joystick sensitivity\\nconst int scrollThreshold = 5; // Threshold to start scrolling\\n\\nstatic unsigned long lastScrollTime = 0;\\nunsigned long currentTime = millis();\\nconst int buttonScrollThreshold = 7; // Threshold to start scrolling\\n\\nvoid setup() {\\n  // Start the built-in Mouse and Keyboard libraries\\n  Mouse.begin();\\n  Keyboard.begin();\\n\\n  // Initialize joystick and button pins\\n  pinMode(joystickClickPin, INPUT_PULLUP);\\n  pinMode(signalPin, INPUT); // Configure signalPin as input\\n  for (int i = 0; i < numButtons; i++) {\\n    pinMode(buttonPins[i], INPUT_PULLUP);\\n  }\\n\\n  Serial.begin(9600);\\n  Serial.println(\\\"Mouse and Keyboard HID initialized\\\");\\n}\\n\\nvoid loop() {\\n  // Read joystick values\\n  int xValue = analogRead(joystickXPin);\\n  int yValue = analogRead(joystickYPin);\\n\\n  // Calculate mouse movement\\n  int deltaX = map(xValue, 0, 1023, -10, 10);\\n  int deltaY = map(yValue, 0, 1023, -10, 10);\\n\\n  // Check if signalPin is HIGH\\n  if (digitalRead(signalPin) == HIGH) {\\n    // Hold the Control key and use deltaY for scrolling\\n    Keyboard.press(KEY_LEFT_CTRL); // Press Control key\\n\\n    // Scroll up or down based on deltaY exceeding thresholds\\n    if (deltaY > scrollThreshold) {\\n      Mouse.move(0, 0, 1); // Scroll up\\n      Serial.println(\\\"Scrolling up\\\");\\n    } else if (deltaY < -scrollThreshold) {\\n      Mouse.move(0, 0, -1); // Scroll down\\n      Serial.println(\\\"Scrolling down\\\");\\n    }\\n\\n    Keyboard.release(KEY_LEFT_CTRL); // Release Control key\\n  } else {\\n    // Normal mouse movement mode\\n    if (abs(xValue - centerX) < deadzone) {\\n      deltaX = 0;\\n    }\\n    if (abs(yValue - centerY) < deadzone) {\\n      deltaY = 0;\\n    }\\n\\n    // Move the mouse\\n    if (digitalRead(buttonPins[0]) != LOW && (deltaX != 0 || deltaY != 0)) {\\n      Mouse.move(deltaX, -deltaY); // Invert Y-axis if needed\\n    }\\n\\n    // Handle right click (buttonPins[0])\\n    if (digitalRead(buttonPins[1]) == LOW || digitalRead(buttonPins[0]) == LOW) {\\n      currentTime = millis();\\n      if (currentTime - lastScrollTime > 100) { // Scroll every 100ms\\n          if (deltaY > buttonScrollThreshold) {\\n              Mouse.move(0, 0, 1);\\n          } else if (deltaY < -buttonScrollThreshold) {\\n              Mouse.move(0, 0, -1);\\n          }\\n          lastScrollTime = millis(); // Update the last scroll time\\n      }   \\n    }\\n\\n    // Handle right click (buttonPins[2])\\n    if (digitalRead(buttonPins[2]) == LOW) {\\n      Mouse.press(MOUSE_RIGHT);\\n    } else {\\n      Mouse.release(MOUSE_RIGHT);\\n    }\\n\\n    // Handle joystick button click\\n    if (digitalRead(buttonPins[3]) == LOW || digitalRead(joystickClickPin) == LOW) {\\n      Mouse.press(MOUSE_LEFT); // Joystick button now triggers left click\\n      Serial.println(\\\"Joystick button pressed - Left click\\\");\\n    } else {\\n      Mouse.release(MOUSE_LEFT);\\n    }    \\n\\n    // NOTE: This is the inconsistent button so I just made it scroll as well above\\n    // if (digitalRead(buttonPins[1]) == LOW) {\\n    //     Keyboard.press(KEY_LEFT_GUI); // Press the SUPER/Windows/Command key\\n    //     Keyboard.press(' ');          // Press the SPACE key\\n    //     delay(100);                   // Optional: small delay to ensure both keys are registered\\n    //     Keyboard.releaseAll();        // Release all keys\\n    //     Serial.println(\\\"SUPER + SPACE triggered\\\");\\n    // }    \\n\\n    // // Handle left click (buttonPins[3])\\n    // if (digitalRead(buttonPins[3]) == LOW) {\\n    //   Mouse.press(MOUSE_LEFT);\\n    // } \\n    // else {\\n    //   Mouse.release(MOUSE_LEFT);\\n    // }\\n  }\\n\\n  // Optional: Debug information\\n  Serial.print(\\\"X: \\\");\\n  Serial.print(xValue);\\n  Serial.print(\\\" Y: \\\");\\n  Serial.print(yValue);\\n  Serial.print(\\\" DX: \\\");\\n  Serial.print(deltaX);\\n  Serial.print(\\\" DY: \\\");\\n  Serial.println(deltaY);\\n\\n  delay(10); // Small delay to control mouse speed\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<div style=\"position:relative\"><span style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\">#</span><h2 id=\"My%20Joystick%20Mouse%20With%20Zoom%20and%20Scroll\" class=\"jsx-2373991563\"><a href=\"#My%20Joystick%20Mouse%20With%20Zoom%20and%20Scroll\" class=\"jsx-2373991563\">My Joystick Mouse With Zoom and Scroll</a></h2></div><p>Just a little side project I thought was pretty cool. It actually works really well and is easy to get going <em>wired</em>. </p><p>Creating a wireless mouse is actually much more work than I expected and I am focusing elsewhere currently but thought this mouse was pretty interesting and fun.</p><p>It is actually really usable and I really like the zoom toggle and scroll button that I have added.</p><video controls=\"\" style=\"width:100%\"><source src=\"/static/mouse.mp4\" type=\"video/mp4\"/><source src=\"/static/mouse.mov\" type=\"video/quicktime\"/>Your browser does not support the video tag. This is a video of me demoing the mouse.</video><video controls=\"\" style=\"width:100%\"><source src=\"/static/mouse2.mp4\" type=\"video/mp4\"/><source src=\"/static/mouse2.mov\" type=\"video/quicktime\"/>Your browser does not support the video tag. This is a video of me demoing the mouse.</video><div style=\"position:relative\"><span style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\">#</span><h2 id=\"Code%20for%20Arduino%20Uno%20R4\" class=\"jsx-2373991563\"><a href=\"#Code%20for%20Arduino%20Uno%20R4\" class=\"jsx-2373991563\">Code for Arduino Uno R4</a></h2></div><pre><code>#include &lt;Mouse.h&gt;    // Built-in library for mouse emulation\n#include &lt;Keyboard.h&gt; // Built-in library for keyboard emulation\n\nconst int joystickXPin = A1;\nconst int joystickYPin = A0;\nconst int joystickClickPin = 2;\nconst int signalPin = 4; // Define the signal pin\nconst int buttonPins[] = {5, 6, 7, 8}; // Pins for additional buttons\nconst int numButtons = sizeof(buttonPins) / sizeof(buttonPins[0]);\n\n// Joystick center values and dead zone for stability\nconst int centerX = 506;\nconst int centerY = 513;\nconst int deadzone = 20; // Adjust for joystick sensitivity\nconst int scrollThreshold = 5; // Threshold to start scrolling\n\nstatic unsigned long lastScrollTime = 0;\nunsigned long currentTime = millis();\nconst int buttonScrollThreshold = 7; // Threshold to start scrolling\n\nvoid setup() {\n  // Start the built-in Mouse and Keyboard libraries\n  Mouse.begin();\n  Keyboard.begin();\n\n  // Initialize joystick and button pins\n  pinMode(joystickClickPin, INPUT_PULLUP);\n  pinMode(signalPin, INPUT); // Configure signalPin as input\n  for (int i = 0; i &lt; numButtons; i++) {\n    pinMode(buttonPins[i], INPUT_PULLUP);\n  }\n\n  Serial.begin(9600);\n  Serial.println(&quot;Mouse and Keyboard HID initialized&quot;);\n}\n\nvoid loop() {\n  // Read joystick values\n  int xValue = analogRead(joystickXPin);\n  int yValue = analogRead(joystickYPin);\n\n  // Calculate mouse movement\n  int deltaX = map(xValue, 0, 1023, -10, 10);\n  int deltaY = map(yValue, 0, 1023, -10, 10);\n\n  // Check if signalPin is HIGH\n  if (digitalRead(signalPin) == HIGH) {\n    // Hold the Control key and use deltaY for scrolling\n    Keyboard.press(KEY_LEFT_CTRL); // Press Control key\n\n    // Scroll up or down based on deltaY exceeding thresholds\n    if (deltaY &gt; scrollThreshold) {\n      Mouse.move(0, 0, 1); // Scroll up\n      Serial.println(&quot;Scrolling up&quot;);\n    } else if (deltaY &lt; -scrollThreshold) {\n      Mouse.move(0, 0, -1); // Scroll down\n      Serial.println(&quot;Scrolling down&quot;);\n    }\n\n    Keyboard.release(KEY_LEFT_CTRL); // Release Control key\n  } else {\n    // Normal mouse movement mode\n    if (abs(xValue - centerX) &lt; deadzone) {\n      deltaX = 0;\n    }\n    if (abs(yValue - centerY) &lt; deadzone) {\n      deltaY = 0;\n    }\n\n    // Move the mouse\n    if (digitalRead(buttonPins[0]) != LOW &amp;&amp; (deltaX != 0 || deltaY != 0)) {\n      Mouse.move(deltaX, -deltaY); // Invert Y-axis if needed\n    }\n\n    // Handle right click (buttonPins[0])\n    if (digitalRead(buttonPins[1]) == LOW || digitalRead(buttonPins[0]) == LOW) {\n      currentTime = millis();\n      if (currentTime - lastScrollTime &gt; 100) { // Scroll every 100ms\n          if (deltaY &gt; buttonScrollThreshold) {\n              Mouse.move(0, 0, 1);\n          } else if (deltaY &lt; -buttonScrollThreshold) {\n              Mouse.move(0, 0, -1);\n          }\n          lastScrollTime = millis(); // Update the last scroll time\n      }   \n    }\n\n    // Handle right click (buttonPins[2])\n    if (digitalRead(buttonPins[2]) == LOW) {\n      Mouse.press(MOUSE_RIGHT);\n    } else {\n      Mouse.release(MOUSE_RIGHT);\n    }\n\n    // Handle joystick button click\n    if (digitalRead(buttonPins[3]) == LOW || digitalRead(joystickClickPin) == LOW) {\n      Mouse.press(MOUSE_LEFT); // Joystick button now triggers left click\n      Serial.println(&quot;Joystick button pressed - Left click&quot;);\n    } else {\n      Mouse.release(MOUSE_LEFT);\n    }    \n\n    // NOTE: This is the inconsistent button so I just made it scroll as well above\n    // if (digitalRead(buttonPins[1]) == LOW) {\n    //     Keyboard.press(KEY_LEFT_GUI); // Press the SUPER/Windows/Command key\n    //     Keyboard.press(&#x27; &#x27;);          // Press the SPACE key\n    //     delay(100);                   // Optional: small delay to ensure both keys are registered\n    //     Keyboard.releaseAll();        // Release all keys\n    //     Serial.println(&quot;SUPER + SPACE triggered&quot;);\n    // }    \n\n    // // Handle left click (buttonPins[3])\n    // if (digitalRead(buttonPins[3]) == LOW) {\n    //   Mouse.press(MOUSE_LEFT);\n    // } \n    // else {\n    //   Mouse.release(MOUSE_LEFT);\n    // }\n  }\n\n  // Optional: Debug information\n  Serial.print(&quot;X: &quot;);\n  Serial.print(xValue);\n  Serial.print(&quot; Y: &quot;);\n  Serial.print(yValue);\n  Serial.print(&quot; DX: &quot;);\n  Serial.print(deltaX);\n  Serial.print(&quot; DY: &quot;);\n  Serial.println(deltaY);\n\n  delay(10); // Small delay to control mouse speed\n}\n</code></pre>","scope":{"slug":"mouse","title":"Joystick Mouse With Zoom and Scroll","date":"2024-11-28","author":"bebrws","tags":["Arduino","Mouse","USB","HID"]}}},"__N_SSG":true}