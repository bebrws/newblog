{"pageProps":{"title":"Creating a Snake Game Clone with Rust/Bevy","dateString":"2024-02-19","slug":"bevy-snake","description":"","tags":["Rust","bevy","WASM","WebAssembly","game"],"author":"bebrws","source":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Rust Practice with Bevy\"), mdx(\"p\", null, \"Bevy has an amazing dependency injection system that makes its \\\"ECS\\\" (Entity Component System) architecture very easy and ituitive to use.\\nReally the DI system is one of the most amazing Rust feats that I have seen so far.\"), mdx(\"p\", null, \"Someone has taken the time to document how to create your own \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://promethia-27.github.io/dependency_injection_like_bevy_from_scratch/chapter1/system.html\"\n  }, \"Bevy based DI system here which is a great read\")), mdx(\"p\", null, \"There is also an unofficial Bevy book that is really helpful \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://bevy-cheatbook.github.io/programming/intro-data.html\"\n  }, \"here\")), mdx(\"h2\", null, \"Bevy and ECS\"), mdx(\"p\", null, \"ECS is documented \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://bevyengine.org/learn/quick-start/getting-started/ecs/\"\n  }, \"here\"), \"\\nIt describes some of the basic concepts of how the Bevy game engine works. Combined with a powerful dependency injection (DI) system, Bevy is powerful, easy to work with, and fun to use.\"), mdx(\"p\", null, \"For my snake game I only needed the concept of three entities really: the snake, the food, and the snake's body.\"), mdx(\"p\", null, \"This is done by the C part of ECS. I create a Component for each. This allows me to, later on, using the DI/query system executed on each game loop, to find all the entities of a certain type and do something with them.\"), mdx(\"p\", null, \"On setup, I create the snake and the food using a spawn command. It takes a tuple where I can provide multiple Components that make up whatever entity I am creating.\"), mdx(\"p\", null, \"Each of the described objects above have a visual aspect for example, so each have a 2D mesh (which includes a transform/translation aka location).\"), mdx(\"p\", null, \"Here is where I create the SnakeHead for example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"    let head_mesh = Mesh2dHandle(meshes.add(Rectangle::new(OBJECT_SIZE, OBJECT_SIZE)));\\n    let box_color = Color::rgb(0.8, 0.2, 0.1);\\n    commands.spawn((\\n        MaterialMesh2dBundle {\\n            mesh: head_mesh,\\n            material: materials.add(box_color),\\n            transform: Transform::from_translation(Vec3::new(0.0, 0.0, 0.0)),\\n            ..default()\\n        },\\n        SnakeHead {\\n            direction: Direction::Up,\\n        },\\n    ));\\n\")), mdx(\"p\", null, \"The most amazing part of Bevy though that I have found so far is its \\\"query\\\"/DI system. With types and traits, I can query for all the entities of a certain type and do something with them each step of the game loop.\"), mdx(\"p\", null, \"This is the function signature I have for checking for collisions for ex:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"fn check_collisions(\\n    mut commands: Commands,\\n    mut meshes: ResMut<Assets<Mesh>>,\\n    mut materials: ResMut<Assets<ColorMaterial>>,\\n    mut apple_query: Query<(&mut Transform), (With<Apple>, Without<SnakeHead>, Without<SnakeBody>)>,\\n    mut snake_head_query: Query<(&mut Transform, &mut SnakeHead)>,\\n    mut snake_body_query: Query<(&mut Transform, Entity), (With<SnakeBody>, Without<SnakeHead>)>,\\n\")), mdx(\"p\", null, \"This function signature can be however long.\"), mdx(\"p\", null, \"The DI system will provide me with whatever objects I need. Commands, meshes, materials, etc.. As well as decipher a simple to work with type system to provide me with all the entities that match a specific query.\"), mdx(\"p\", null, \"For example, with the snake body. I want to be able to move each one and also remove them if the snake crashes. To move them I just need their Transform (part of what was provided from the MaterialMesh2dBundle during setup) and the Entity itself so I can send a command to despawn them or remove body parts from the game.\"), mdx(\"p\", null, \"The DI system that powers all this is amazing to me. I had no idea this could be accomplished in Rust until someone from the Bevy Discord chat kindly pointed me to this documentation which breaks down \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://promethia-27.github.io/dependency_injection_like_bevy_from_scratch/chapter1/system.html\"\n  }, \"how it all works\"), \".\"), mdx(\"h2\", null, \"Reading and Learning the Complicated Macros from the DI System Mentioned Above\"), mdx(\"p\", null, \"If you take the example from the end of page 3 in the DI like Bevy from Scratch book, you can use cargo expand to see what the macro is doing.\"), mdx(\"p\", null, \"I created a new project and added the macro to the main.rs file. Then I ran cargo expand and it showed me the expanded macro created unsugared Rust code which made understanding the macros and the documentation much easier to understand.\"), mdx(\"p\", null, \"To install cargo expand run: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo install cargo-expand\")), mdx(\"p\", null, \"The code I ran\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo expand > expanded.rs\"), \"\\non is:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"struct FunctionSystem<Input, F> {\\n    f: F,\\n    marker: PhantomData<fn() -> Input>,\\n}\\n\\ntrait System {\\n    fn run(&mut self, resources: &mut HashMap<TypeId, Box<dyn Any>>);\\n}\\n\\nmacro_rules! impl_system {\\n    (\\n        $(\\n            $($params:ident),+\\n        )?\\n    ) => {\\n        #[allow(non_snake_case, unused)]\\n        impl<\\n            F: FnMut(\\n                $( $($params),+ )?\\n            )\\n            $(, $($params: 'static),+ )?\\n        > System for FunctionSystem<($( $($params,)+ )?), F> {\\n            fn run(&mut self, resources: &mut HashMap<TypeId, Box<dyn Any>>) {\\n                $($(\\n                    let $params = *resources.remove(&TypeId::of::<$params>()).unwrap().downcast::<$params>().unwrap();\\n                )+)?\\n\\n                (self.f)(\\n                    $($($params),+)?\\n                );\\n            }\\n        }\\n    }\\n}\\n\\nimpl_system!();\\nimpl_system!(T1);\\nimpl_system!(T1, T2);\\nimpl_system!(T1, T2, T3);\\nimpl_system!(T1, T2, T3, T4);\\n\\ntrait IntoSystem<Input> {\\n    type System: System;\\n\\n    fn into_system(self) -> Self::System;\\n}\\n\\nmacro_rules! impl_into_system {\\n    (\\n        $($(\\n                $params:ident\\n        ),+)?\\n    ) => {\\n        impl<F: FnMut($($($params),+)?) $(, $($params: 'static),+ )?> IntoSystem<( $($($params,)+)? )> for F {\\n            type System = FunctionSystem<( $($($params,)+)? ), Self>;\\n\\n            fn into_system(self) -> Self::System {\\n                FunctionSystem {\\n                    f: self,\\n                    marker: Default::default(),\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nimpl_into_system!();\\nimpl_into_system!(T1);\\nimpl_into_system!(T1, T2);\\nimpl_into_system!(T1, T2, T3);\\nimpl_into_system!(T1, T2, T3, T4);\\n\\ntype StoredSystem = Box<dyn System>;\\n\\nstruct Scheduler {\\n    systems: Vec<StoredSystem>,\\n    resources: HashMap<TypeId, Box<dyn Any>>,\\n}\\n\\nimpl Scheduler {\\n    pub fn run(&mut self) {\\n        for system in self.systems.iter_mut() {\\n            system.run(&mut self.resources);\\n        }\\n    }\\n\\n    pub fn add_system<I, S: System + 'static>(&mut self, system: impl IntoSystem<I, System = S>) {\\n        self.systems.push(Box::new(system.into_system()));\\n    }\\n\\n    pub fn add_resource<R: 'static>(&mut self, res: R) {\\n        self.resources.insert(TypeId::of::<R>(), Box::new(res));\\n    }\\n}\\n\\nfn main() {\\n    let mut scheduler = Scheduler {\\n        systems: vec![],\\n        resources: HashMap::default(),\\n    };\\n\\n    scheduler.add_system(foo);\\n    scheduler.add_resource(12i32);\\n\\n    scheduler.run();\\n}\\n\\nfn foo(int: i32) {\\n    println!(\\\"int! {int}\\\");\\n}\\n\")), mdx(\"h1\", null, \"My Snake Clone\"), mdx(\"p\", null, \"Can be found \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/bebrws/bevy-snake\"\n  }, \"here\")), mdx(\"h1\", null, \"And Compiled to WASM and Played Here! (Only on WASM supported browsers - so no mobile)\"), mdx(React.Fragment, null, mdx(\"canvas\", {\n    id: \"bevy-portal\",\n    tabindex: \"0\",\n    \"data-raw-handle\": \"1\",\n    alt: \"app\",\n    cursor: \"auto\"\n  })));\n}\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<h1>Rust Practice with Bevy</h1><p>Bevy has an amazing dependency injection system that makes its &quot;ECS&quot; (Entity Component System) architecture very easy and ituitive to use.\nReally the DI system is one of the most amazing Rust feats that I have seen so far.</p><p>Someone has taken the time to document how to create your own <a href=\"https://promethia-27.github.io/dependency_injection_like_bevy_from_scratch/chapter1/system.html\">Bevy based DI system here which is a great read</a></p><p>There is also an unofficial Bevy book that is really helpful <a href=\"https://bevy-cheatbook.github.io/programming/intro-data.html\">here</a></p><h2>Bevy and ECS</h2><p>ECS is documented <a href=\"https://bevyengine.org/learn/quick-start/getting-started/ecs/\">here</a>\nIt describes some of the basic concepts of how the Bevy game engine works. Combined with a powerful dependency injection (DI) system, Bevy is powerful, easy to work with, and fun to use.</p><p>For my snake game I only needed the concept of three entities really: the snake, the food, and the snake&#x27;s body.</p><p>This is done by the C part of ECS. I create a Component for each. This allows me to, later on, using the DI/query system executed on each game loop, to find all the entities of a certain type and do something with them.</p><p>On setup, I create the snake and the food using a spawn command. It takes a tuple where I can provide multiple Components that make up whatever entity I am creating.</p><p>Each of the described objects above have a visual aspect for example, so each have a 2D mesh (which includes a transform/translation aka location).</p><p>Here is where I create the SnakeHead for example:</p><pre><code>    let head_mesh = Mesh2dHandle(meshes.add(Rectangle::new(OBJECT_SIZE, OBJECT_SIZE)));\n    let box_color = Color::rgb(0.8, 0.2, 0.1);\n    commands.spawn((\n        MaterialMesh2dBundle {\n            mesh: head_mesh,\n            material: materials.add(box_color),\n            transform: Transform::from_translation(Vec3::new(0.0, 0.0, 0.0)),\n            ..default()\n        },\n        SnakeHead {\n            direction: Direction::Up,\n        },\n    ));\n</code></pre><p>The most amazing part of Bevy though that I have found so far is its &quot;query&quot;/DI system. With types and traits, I can query for all the entities of a certain type and do something with them each step of the game loop.</p><p>This is the function signature I have for checking for collisions for ex:</p><pre><code>fn check_collisions(\n    mut commands: Commands,\n    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,\n    mut materials: ResMut&lt;Assets&lt;ColorMaterial&gt;&gt;,\n    mut apple_query: Query&lt;(&amp;mut Transform), (With&lt;Apple&gt;, Without&lt;SnakeHead&gt;, Without&lt;SnakeBody&gt;)&gt;,\n    mut snake_head_query: Query&lt;(&amp;mut Transform, &amp;mut SnakeHead)&gt;,\n    mut snake_body_query: Query&lt;(&amp;mut Transform, Entity), (With&lt;SnakeBody&gt;, Without&lt;SnakeHead&gt;)&gt;,\n</code></pre><p>This function signature can be however long.</p><p>The DI system will provide me with whatever objects I need. Commands, meshes, materials, etc.. As well as decipher a simple to work with type system to provide me with all the entities that match a specific query.</p><p>For example, with the snake body. I want to be able to move each one and also remove them if the snake crashes. To move them I just need their Transform (part of what was provided from the MaterialMesh2dBundle during setup) and the Entity itself so I can send a command to despawn them or remove body parts from the game.</p><p>The DI system that powers all this is amazing to me. I had no idea this could be accomplished in Rust until someone from the Bevy Discord chat kindly pointed me to this documentation which breaks down <a href=\"https://promethia-27.github.io/dependency_injection_like_bevy_from_scratch/chapter1/system.html\">how it all works</a>.</p><h2>Reading and Learning the Complicated Macros from the DI System Mentioned Above</h2><p>If you take the example from the end of page 3 in the DI like Bevy from Scratch book, you can use cargo expand to see what the macro is doing.</p><p>I created a new project and added the macro to the main.rs file. Then I ran cargo expand and it showed me the expanded macro created unsugared Rust code which made understanding the macros and the documentation much easier to understand.</p><p>To install cargo expand run: <code>cargo install cargo-expand</code></p><p>The code I ran\n<code>cargo expand &gt; expanded.rs</code>\non is:</p><pre><code>struct FunctionSystem&lt;Input, F&gt; {\n    f: F,\n    marker: PhantomData&lt;fn() -&gt; Input&gt;,\n}\n\ntrait System {\n    fn run(&amp;mut self, resources: &amp;mut HashMap&lt;TypeId, Box&lt;dyn Any&gt;&gt;);\n}\n\nmacro_rules! impl_system {\n    (\n        $(\n            $($params:ident),+\n        )?\n    ) =&gt; {\n        #[allow(non_snake_case, unused)]\n        impl&lt;\n            F: FnMut(\n                $( $($params),+ )?\n            )\n            $(, $($params: &#x27;static),+ )?\n        &gt; System for FunctionSystem&lt;($( $($params,)+ )?), F&gt; {\n            fn run(&amp;mut self, resources: &amp;mut HashMap&lt;TypeId, Box&lt;dyn Any&gt;&gt;) {\n                $($(\n                    let $params = *resources.remove(&amp;TypeId::of::&lt;$params&gt;()).unwrap().downcast::&lt;$params&gt;().unwrap();\n                )+)?\n\n                (self.f)(\n                    $($($params),+)?\n                );\n            }\n        }\n    }\n}\n\nimpl_system!();\nimpl_system!(T1);\nimpl_system!(T1, T2);\nimpl_system!(T1, T2, T3);\nimpl_system!(T1, T2, T3, T4);\n\ntrait IntoSystem&lt;Input&gt; {\n    type System: System;\n\n    fn into_system(self) -&gt; Self::System;\n}\n\nmacro_rules! impl_into_system {\n    (\n        $($(\n                $params:ident\n        ),+)?\n    ) =&gt; {\n        impl&lt;F: FnMut($($($params),+)?) $(, $($params: &#x27;static),+ )?&gt; IntoSystem&lt;( $($($params,)+)? )&gt; for F {\n            type System = FunctionSystem&lt;( $($($params,)+)? ), Self&gt;;\n\n            fn into_system(self) -&gt; Self::System {\n                FunctionSystem {\n                    f: self,\n                    marker: Default::default(),\n                }\n            }\n        }\n    }\n}\n\nimpl_into_system!();\nimpl_into_system!(T1);\nimpl_into_system!(T1, T2);\nimpl_into_system!(T1, T2, T3);\nimpl_into_system!(T1, T2, T3, T4);\n\ntype StoredSystem = Box&lt;dyn System&gt;;\n\nstruct Scheduler {\n    systems: Vec&lt;StoredSystem&gt;,\n    resources: HashMap&lt;TypeId, Box&lt;dyn Any&gt;&gt;,\n}\n\nimpl Scheduler {\n    pub fn run(&amp;mut self) {\n        for system in self.systems.iter_mut() {\n            system.run(&amp;mut self.resources);\n        }\n    }\n\n    pub fn add_system&lt;I, S: System + &#x27;static&gt;(&amp;mut self, system: impl IntoSystem&lt;I, System = S&gt;) {\n        self.systems.push(Box::new(system.into_system()));\n    }\n\n    pub fn add_resource&lt;R: &#x27;static&gt;(&amp;mut self, res: R) {\n        self.resources.insert(TypeId::of::&lt;R&gt;(), Box::new(res));\n    }\n}\n\nfn main() {\n    let mut scheduler = Scheduler {\n        systems: vec![],\n        resources: HashMap::default(),\n    };\n\n    scheduler.add_system(foo);\n    scheduler.add_resource(12i32);\n\n    scheduler.run();\n}\n\nfn foo(int: i32) {\n    println!(&quot;int! {int}&quot;);\n}\n</code></pre><h1>My Snake Clone</h1><p>Can be found <a href=\"https://github.com/bebrws/bevy-snake\">here</a></p><h1>And Compiled to WASM and Played Here! (Only on WASM supported browsers - so no mobile)</h1><canvas id=\"bevy-portal\" tabindex=\"0\" data-raw-handle=\"1\" alt=\"app\" cursor=\"auto\"></canvas>","scope":{"slug":"bevy-snake","title":"Creating a Snake Game Clone with Rust/Bevy","date":"2024-02-19","author":"bebrws","tags":["Rust","bevy","WASM","WebAssembly","game"]}}},"__N_SSG":true}