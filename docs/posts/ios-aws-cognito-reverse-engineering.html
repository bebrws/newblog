<!DOCTYPE html><html><head><script type="text/javascript" class="jsx-707554062">
          
          function loadBevySnake() {
            setTimeout(function() {
            var element = document.getElementById('bevy-portal');
                  if (element) {
                    console.log('Element with id "bevy-portal" exists. Adding script tag.');

                  var script = document.createElement('script');
                  script.type = 'module';
                  script.src = '../static/load-bevy-snake.js';
                  document.head.appendChild(script);
            } else {
                    console.log('Element with id "bevy-portal" does not exist.');
                    loadBevySnake();
            }
          }, 500);
        }

        loadBevySnake();
      </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=UA-154810525-2" class="jsx-707554062"></script><script type="text/javascript" class="jsx-707554062">
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'UA-154810525-2');
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-BZKS5D8HPF" class="jsx-707554062"></script><script type="text/javascript" class="jsx-707554062">
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-BZKS5D8HPF');
        </script><meta charSet="utf-8" class="jsx-707554062"/><meta name="viewport" content="width=device-width, initial-scale=1" class="jsx-707554062"/><link rel="manifest" href="/site.webmanifest" class="jsx-707554062"/><link rel="apple-touch-icon" href="/icon.png" class="jsx-707554062"/><meta name="theme-color" content="#fff" class="jsx-707554062"/><title>Reverse engineering an iOS application to allow for integration with shortcuts and Siri - Recreate AWS Cognito authentication and sending fake UITouch events | Brad Barrows&#x27; Blog</title><meta name="description" content="Brad Barrows&#x27; Blog"/><link rel="canonical" href="https://bbarrows.com/posts/ios-aws-cognito-reverse-engineering"/><meta property="og:site_name" content="Brad Barrows&#x27; Blog"/><meta property="og:url" content="https://bbarrows.com/posts/ios-aws-cognito-reverse-engineering"/><meta property="og:title" content="Reverse engineering an iOS application to allow for integration with shortcuts and Siri - Recreate AWS Cognito authentication and sending fake UITouch events | Brad Barrows&#x27; Blog"/><meta property="og:description" content="Brad Barrows&#x27; Blog"/><meta property="og:image" content="https://bbarrows.com/og_image.png"/><meta property="og:type" content="article"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":"https://bbarrows.com/posts/ios-aws-cognito-reverse-engineering","headline":"Reverse engineering an iOS application to allow for integration with shortcuts and Siri - Recreate AWS Cognito authentication and sending fake UITouch events","datePublished":"2023-05-12T00:00:00-07:00","author":"Brad Barrows","description":""}</script><meta name="next-head-count" content="20"/><link rel="preload" href="/_next/static/css/8e11f38ccf46f6277e39.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e11f38ccf46f6277e39.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e884486185169a1848b2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e884486185169a1848b2.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-f47d69457824065d04c3.js" defer=""></script><script src="/_next/static/chunks/framework-895f067827ebe11ffe45.js" defer=""></script><script src="/_next/static/chunks/main-d32200c037819e7e8fa0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-eae7af63eb651790e0a7.js" defer=""></script><script src="/_next/static/chunks/962-b2e3b32260744832b5cf.js" defer=""></script><script src="/_next/static/chunks/295-d2a92dd57ddb2277243a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpost%5D-554a7f2db08ad8e20c9d.js" defer=""></script><script src="/_next/static/lATzPuzq9Tes3x9uwms3o/_buildManifest.js" defer=""></script><script src="/_next/static/lATzPuzq9Tes3x9uwms3o/_ssgManifest.js" defer=""></script><style id="__jsx-3058196896">.container.jsx-3058196896{position:fixed;width:38px;height:38px;cursor:pointer;top:1rem;left:1.25rem;z-index:2;background-color:rgba(255,255,255,0.7);}.meat.jsx-3058196896{position:absolute;width:28px;height:2px;background:#222;top:calc(50% - 2px / 2);left:calc(50% - 28px / 2);-webkit-transition:all 150ms ease-in;transition:all 150ms ease-in;}.meat-1.jsx-3058196896{-webkit-transform:translateY(-10px);-ms-transform:translateY(-10px);transform:translateY(-10px);}.meat-2.jsx-3058196896{width:calc(28px - 6px);}.meat-3.jsx-3058196896{-webkit-transform:translateY(10px);-ms-transform:translateY(10px);transform:translateY(10px);}.active.jsx-3058196896 .meat-1.jsx-3058196896{-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);transform:rotate(45deg);}.active.jsx-3058196896 .meat-2.jsx-3058196896{opacity:0;}.active.jsx-3058196896 .meat-3.jsx-3058196896{-webkit-transform:rotate(-45deg);-ms-transform:rotate(-45deg);transform:rotate(-45deg);}@media (min-width:769px){.container.jsx-3058196896{display:none;}}</style><style id="__jsx-4138737674">.container.jsx-4138737674{width:0;}ul.jsx-4138737674{opacity:0;width:100%;height:100vh;text-align:right;list-style:none;margin:0;padding:0;position:fixed;top:0;background-color:#fff;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;z-index:1;-webkit-transform:translateY(100%);-ms-transform:translateY(100%);transform:translateY(100%);-webkit-transition:opacity 200ms;transition:opacity 200ms;}.active.jsx-4138737674 ul.jsx-4138737674{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);transform:translateY(0);}li.jsx-4138737674{margin-bottom:1.75rem;font-size:2rem;padding:0 1.5rem 0 0;}li.jsx-4138737674:last-child{margin-bottom:0;}.active.jsx-4138737674{color:#222;}@media (min-width:769px){.container.jsx-4138737674{width:7rem;display:block;}ul.jsx-4138737674{opacity:1;width:7rem;top:auto;display:block;-webkit-transform:translateY(0);-ms-transform:translateY(0);transform:translateY(0);}li.jsx-4138737674{font-size:1rem;padding:0;}}</style><style id="__jsx-3674465219">span.jsx-3674465219{color:#9b9b9b;}</style><style id="__jsx-255066894">a.jsx-255066894{display:inline-block;}a.jsx-255066894:not(:last-child){margin-right:2em;}</style><style id="__jsx-3618008669">p.jsx-3618008669{font-size:0.75rem;text-align:center;}</style><style id="__jsx-4153080612">.container.jsx-3387257903{display:block;max-width:60rem;width:100%;margin:0 auto;padding:0 1.5rem;box-sizing:border-box;z-index:0;}.metadata.jsx-3387257903 div.jsx-3387257903{display:inline-block;margin-right:0.5rem;}article.jsx-3387257903{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;}h1.jsx-3387257903{margin:0 0 0.5rem;font-size:2.25rem;}.tag-list.jsx-3387257903{list-style:none;text-align:right;margin:1.75rem 0 0 0;padding:0;}.tag-list.jsx-3387257903 li.jsx-3387257903{display:inline-block;margin-left:0.5rem;}.social-list.jsx-3387257903{margin-top:3rem;text-align:center;}@media (min-width:769px){.container.jsx-3387257903{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}</style><style id="__jsx-1699270818">.token.comment,.token.prolog,.token.doctype,.token.cdata,.token.plain-text{color:#6a737d;}.token.atrule,.token.attr-value,.token.keyword,.token.operator{color:#d73a49;}.token.property,.token.tag,.token.boolean,.token.number,.token.constant,.token.symbol,.token.deleted{color:#22863a;}.token.selector,.token.attr-name,.token.string,.token.char,.token.builtin,.token.inserted{color:#032f62;}.token.function,.token.class-name{color:#6f42c1;}.language-jsx .token.punctuation,.language-jsx .token.tag .token.punctuation,.language-jsx .token.tag .token.script,.language-jsx .token.plain-text{color:#24292e;}.language-jsx .token.tag .token.attr-name{color:#6f42c1;}.language-jsx .token.tag .token.class-name{color:#005cc5;}.language-jsx .token.tag .token.script-punctuation,.language-jsx .token.attr-value .token.punctuation:first-child{color:#d73a49;}.language-jsx .token.attr-value{color:#032f62;}.language-jsx span[class="comment"]{color:pink;}.language-html .token.tag .token.punctuation{color:#24292e;}.language-html .token.tag .token.attr-name{color:#6f42c1;}.language-html .token.tag .token.attr-value,.language-html .token.tag .token.attr-value .token.punctuation:not(:first-child){color:#032f62;}.language-css .token.selector{color:#6f42c1;}.language-css .token.property{color:#005cc5;}</style><style id="__jsx-707554062">.root.jsx-707554062{display:block;padding:4rem 0;box-sizing:border-box;height:100%;}main.jsx-707554062{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;min-height:100%;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}@media (min-width:769px){.root.jsx-707554062{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;}main.jsx-707554062{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;}}</style></head><body><div id="__next"><div class="jsx-707554062 root"><nav class="jsx-707554062"><div class="jsx-3058196896 container "><div class="jsx-3058196896 meat meat-1"></div><div class="jsx-3058196896 meat meat-2"></div><div class="jsx-3058196896 meat meat-3"></div></div><div class="jsx-4138737674 container "><ul class="jsx-4138737674"><li class="jsx-4138737674"><a class="jsx-4138737674 " href="/">about</a></li><li class="jsx-4138737674"><a class="jsx-4138737674 " href="/projects">projects</a></li><li class="jsx-4138737674"><a class="jsx-4138737674 active" href="/posts">blog</a></li></ul></div></nav><main class="jsx-707554062"><div class="jsx-3387257903 container"><article class="jsx-3387257903"><header class="jsx-3387257903"><h1 class="jsx-3387257903">Reverse engineering an iOS application to allow for integration with shortcuts and Siri - Recreate AWS Cognito authentication and sending fake UITouch events</h1><div class="jsx-3387257903 metadata"><div class="jsx-3387257903"><time dateTime="2023-05-12T00:00:00-07:00" class="jsx-3674465219"><span class="jsx-3674465219">May 12, 2023</span></time></div><div class="jsx-3387257903"><span class="jsx-3674465219">Brad Barrows</span></div></div></header><div class="jsx-3387257903 content_content__1yuPc"><div><h1>Stuck With a Smart Lock That Only Works With Google or Alexa? Let&#x27;s Fix That!</h1><p>I should have written this up sooner while it was still fresh in my mind. Apologies for the scattered information, but the AWS Cognito example might be helpful to some. Additionally, the Frida Gadget scripting to add a URL Scheme could be beneficial.</p><p>I am going to make another post for how I was able to use a library by <a href="https://github.com/lyft/Hammer">Lyft called Hammer</a> to send fake UITouch events as well next.. and maybe one on just all the lldb commands I learned and what I thought was really helpful.</p><h2>Why the Obscure Blog Post and Code?</h2><p>Apologies, but I’ve obscured company names and details. Unfortunately, you won’t be able to directly use this work if you have the same door lock as me, but if you’re smart enough to recognize the same libraries and network requests, you should be able to gather the necessary information and recreate a useful server/tool to control your door as you wish.</p><h2>Introduction - IOS URLScheme and Frida and some lldb</h2><p>I moved into a new apartment with a smart lock that has an iOS app, which is convenient. However, it takes a while to load the app and press the button to lock and unlock the door. I really just wanted to be able to tell Siri to do it if my hands were full. Plus, I enjoy exploring iOS.</p><p>I’ll try to go through my process in the order I followed (mostly) because I learned a lot along the way, recreating this blog post from my notes.</p><p>To summarize, as someone suggested, the easiest way to achieve this would be to sniff the network traffic and recreate it. But I wanted to learn more about iOS and reverse engineering, so I initially took the harder route.</p><p>I started by using software like Charles Proxy to examine the network traffic. What did I find? A straightforward JSON API that uses a JWT token for authentication to lock and unlock the door.</p><p>To demonstrate how easy it initially seemed to use this API, here’s a cURL command showing me using the API to lock the door:</p><pre><code class="language-bash">curl -X PATCH &quot;https://$SOMECOMPANYID.execute-api.us-east-1.amazonaws.com/prod_v1/devices/$PROBMYDEVICEID/status&quot; -H &quot;User-Agent: AppName/5 CFNetwork/1404.0.5 Darwin/22.3.0&quot; -H &quot;Content-Type: application/json&quot; -H &quot;Accept: application/json&quot; -H &quot;Accept-Language: en-US,en;q=0.9&quot; -H &quot;Authorization: Bearer $KBEARER&quot; -H &quot;Accept-Encoding: gzip, deflate, br&quot; -d &quot;{\&quot;action\&quot;: \&quot;lock\&quot;, \&quot;source\&quot;: \&quot;{\\\&quot;name\\\&quot;:\\\&quot;$MYNAME\\\&quot;,\\\&quot;device\\\&quot;:\\\&quot;iPhone\\\&quot;}\&quot;}&quot;
</code></pre><p>So all I need to do is send the JSON below to some URL with an AUTH token basically.</p><pre><code>{&quot;action&quot;: &quot;lock&quot;, &quot;source&quot;: &quot;{\&quot;name\&quot;:\&quot;Brad\&quot;,\&quot;device\&quot;:\&quot;iPhone\&quot;}&quot;}
</code></pre><p>As I continued to examine the intercepted HTTPS traffic, I saw that there were multiple requests before this one, and one of them contained the AUTH token. I realized there was a process happening to obtain the JWT, which looked a bit complicated.</p><p>At first, I hoped I could just find some object in the heap that contained the AUTH token and use that via Frida (and its amazing API with functionality like pulling all objects of any type from memory!). However, none of the AUTH tokens I found were working.</p><p>I should also mention that my original plan was to add an iOS URL Scheme to the application so I could create a Siri Shortcut that would open a URL to lock and unlock my door.</p><p>I tried several things, such as creating iOS tweaks, making a custom dylib in Xcode, and manually adding it to the main executable using install_name_tool, then swizzling it to add new functionality.</p><p>For those who may need an explanation: a dylib is a dynamically linked library, meaning it’s a binary that the operating system (or more specifically, dyld) loads into memory when an application starts.</p><p>So, I needed a decrypted copy of the application I was going to modify/debug/etc. Some websites surprisingly provide this service, but I found my old iPhone 6s and was able to use Checkra1n and Palera1n on an iPhone 7 to get them jailbroken. At this point, what worked best for me was frida-ios-dump.</p><p>Instead of installing usbmuxd/iproxy, if you’re on the same network, you can just use the IP address:</p><pre><code>./dump.py -H 192.168.1.87 -p 22 AppName
</code></pre><p>NOTE: From here on out, I’ll refer to the iOS app as AppName.</p><p>After running this dump, you should end up with an unencrypted “.ipa” file in the same folder. An ipa file type is a zip file that contains the application and all its data/metadata.</p><p>You can change the extension from .ipa to .zip and unzip it right there.</p><p>Inside, you’ll find a folder named Payload, and inside that, there will be AppName.App.</p><p>Just like a .App on macOS, you can right-click and show package contents to see what the app really contains.</p><p>The most important file will be the binary itself, which is normally also named AppName (with no file extension) and will be an arm64 binary built for iOS.</p><p>There is also a Frameworks folder that will contain a number of frameworks, which are essentially dylibs with additional information, like header files, that the binary loads at runtime.</p><p>Any executable will have a list of dynamically linked libraries it loads at runtime. You can list those with:</p><pre><code>otool -L $EXE_NAME_HERE
</code></pre><p>or to get a more detailed breakdown that includes information such as the path where the binary will look for the dylibs:</p><pre><code>otool -l $EXE_NAME_HERE
</code></pre><p>It’s important to use the lowercase -l option so you can see where rpath points in some cases. In most cases, it will just be the Frameworks directory.</p><p>So, if you’re going to add your own dylib, you could, for example, use a tool like insert_dylib.</p><p>For example, I built my own dylib, which initially attempted to swizzle the older handleURL methods on the iOS AppDelegate (this no longer works, by the way).</p><p>To insert your dylib, you would do something like:</p><pre><code>insert_dylib --strip-codesig --inplace &#x27;@executable_path/Frameworks/libhandleURLSwizzleObjC.dylib&#x27; ~/Payload/AppName.app/AppName
cp ~/libhandleURLSwizzleObjC.dylib ~/Payload/AppName.app/Frameworks
</code></pre><p>In your dylib code (you can create a dylib in Xcode by creating a static library and then changing the library type to dynamic in build options; you may also want to change the extension from .a to .dylib), you will want to add a constructor function.</p><p>This function is called when the dylib is loaded into memory, and it’s your chance to “swizzle” or replace existing functions with your own, allowing you to add or modify existing functionality in an application.</p><p>These days, you can use a tool called objection to handle signing everything and converting your Payload folder into an ipa for you.</p><p>Then, you can use another tool, ios-deploy, to send the app to your iPhone, whether jailbroken or not, and start a debugging session with LLDB. Objection by default injects Frida, so you can connect to Frida and poke around as well!</p><p>It’s all very user-friendly and pretty easy to get started with.</p><h2>Getting IOS URLScheme to Work</h2><p>Even though I didn’t end up going this route, I finally figured out a cool way to make it work and wanted to document it. With the newer iOS SDKs and SwiftUI, the older handleURL method on AppDelegate is no longer called (I believe) with a URL Scheme.</p><p>First off, I needed to update my iOS app’s plist file so it would handle URLs like AppName://unlockdoor.</p><p>To do so, I scripted:</p><pre><code>head -n4 ~/Payload/AppName.app/Info.plist &gt; ~/Payload/AppName.app/Info.plist-2
echo &quot;&quot;&quot;    &lt;key&gt;CFBundleURLTypes&lt;/key&gt;
    &lt;array&gt;
        &lt;dict&gt;
            &lt;key&gt;CFBundleURLSchemes&lt;/key&gt;
            &lt;array&gt;
                &lt;string&gt;AppName&lt;/string&gt;
            &lt;/array&gt;
            &lt;key&gt;CFBundleURLName&lt;/key&gt;
            &lt;string&gt;com.AppName.ble-wifi&lt;/string&gt;
        &lt;/dict&gt;
    &lt;/array&gt;&quot;&quot;&quot; &gt;&gt; ~/Payload/AppName.app/Info.plist-2
tail -n+5 ~/Payload/AppName.app/Info.plist &gt;&gt; ~/Payload/AppName.app/Info.plist-2
mv ~/Payload/AppName.app/Info.plist-2 ~/Payload/AppName.app/Info.plist
</code></pre><p>The important part is that the CFBundleURLSchemes contains the string for the url proto if I remember right and then the CFBundleURLName has to have the same Bundle of the App.
There is a lot of documentation on this part too so I won&#x27;t go into too much detail here.</p><p>What I think is really cool is that the Frida Gadget, the Frida dylib, that is injected into the App will look for a script to run. So you can create apps with Frida injected and a script included in the Payload/App folder so that you don&#x27;t need to write a dylib in objective-c or something and can create deployable packagable apps using Frida for tweaks! Pretty amazing.</p><p>The documentation for <a href="https://frida.re/docs/gadget/">Frida Gadgets is here</a>. Definately check that out. It&#x27;s a great feature I never knew about.</p><p>So along with using this feature or Frida I ended up figuring out which method I needed to implement to handle IOS URLSchemes with ios 15.7.2 and probably later.</p><p>You have to find the UIWindowScene and add a method &quot;- scene:openURLContexts:&quot;. This is actually what is trigger with IOS URLSchemes on these newer iOS versions.</p><p>I have a super hacky way of finding the UIWindowScene.. and I don&#x27;t know why I didn&#x27;t just use ObjC.choose or something.. But this is my Frida Gagdet script:</p><pre><code>rpc.exports = {
    init(stage, parameters) {
        console.error(&#x27;[init]&#x27;, stage, JSON.stringify(parameters));

        var globalar = null;

        var NSLog = new NativeFunction(Module.findExportByName(&#x27;Foundation&#x27;, &#x27;NSLog&#x27;), &#x27;void&#x27;, [&#x27;pointer&#x27;, &#x27;...&#x27;]);
        var NSString = ObjC.classes.NSString;
        var str = NSString.stringWithFormat_(&quot;[*] BRAD IN FRIDA GADGET&quot;);
        NSLog(str);
        console.error(&quot;[*] BRAD IN FRIDA GADGET&quot;);


        var NSJSONSerialization = ObjC.classes.NSJSONSerialization;
        var NSUTF8StringEncoding = 4;

        var NSURL = ObjC.classes.NSURL;
        // var NSError = ObjC.classes.NSError;

        function convertNSObjectToJSString(obj) {
            var valid = NSJSONSerialization.isValidJSONObject_(obj);
            if (!valid) return null;
            const NSJSONWritingPrettyPrinted = 1;
            var errorPtr = Memory.alloc(Process.pointerSize);
            Memory.writePointer(errorPtr, NULL); // initialize to NULL
            var data = NSJSONSerialization.dataWithJSONObject_options_error_(obj, NSJSONWritingPrettyPrinted, errorPtr);
            var error = Memory.readPointer(errorPtr);
            if (error.isNull()) {
                var str = NSString.alloc().initWithData_encoding_(data, NSUTF8StringEncoding);
                return str.toString();
            } else {
                var errorObj = new ObjC.Object(error); // now you can treat errorObj as an NSError instance
                console.error(errorObj.toString());
                return null;
            }
        }


        function getCurrentJWT() {
            var awsMobileClientPtr = Number(ObjC.chooseSync(ObjC.classes[&quot;AWSMobileClient.AWSMobileClient&quot;])[0].handle);
            var awsMobileClientDictPtrStr = Number(awsMobileClientPtr + 0x0000000000000088).toString(16);
            var awsMobileClientDictPtr = new NativePointer(&quot;0x&quot; + awsMobileClientDictPtrStr);
            var dictPtr = awsMobileClientDictPtr.readPointer()
            var dictObj = new ObjC.Object(dictPtr);
            var dstr = dictObj.toString();
            console.error(&quot;String argument: &quot; + dstr);
            var regex = /.*(&quot;eyJ.*&quot;).*/;
            var jwt = JSON.parse(dstr.match(regex)[1]);
            return jwt;
        }

        function lockUnlockDoor(action) {
            var jwt = getCurrentJWT();
            console.error(&quot;Got JWT: &quot; + jwt);

            var actionParsed = (action == &quot;lock&quot; || action == &quot;unlock&quot;) ? action : &quot;lock&quot;;
            var url = &quot;https://SOMECOMPANYID.execute-api.us-east-1.amazonaws.com/prod_v1/devices/PROBMYDEVICEID/status&quot;;
            var nsurl = NSURL.alloc().initWithString_(url);
            var urlRequest = ObjC.classes.NSMutableURLRequest.alloc().initWithURL_(nsurl);

            var actString = &quot;{\&quot;action\&quot;: \&quot;&quot; + actionParsed + &quot;\&quot;, \&quot;source\&quot;: \&quot;{\\\&quot;name\\\&quot;:\\\&quot;Brad\\\&quot;,\\\&quot;device\\\&quot;:\\\&quot;iPhone\\\&quot;}\&quot;}&quot;;
            console.error(`\n\nBEB - actString: ${actString} ${actString.length}\n\n`);
            var userUpdate = NSString.stringWithFormat_(actString);
            console.error(`\n\nBEB - userUpdate: ${userUpdate.toString()} ${userUpdate.length()}\n\n`);

            urlRequest.setHTTPMethod_(&quot;PATCH&quot;);
            urlRequest.setValue_forHTTPHeaderField_(&quot;Bearer &quot; + jwt, &quot;Authorization&quot;);
            urlRequest.setValue_forHTTPHeaderField_(`${actString.length}`, &quot;Content-Length&quot;);
            urlRequest.setValue_forHTTPHeaderField_(&quot;application/json&quot;, &quot;Content-Type&quot;);
            urlRequest.setValue_forHTTPHeaderField_(&quot;application/json&quot;, &quot;Accept&quot;);
            urlRequest.setValue_forHTTPHeaderField_(&quot;en-US,en;q=0.9&quot;, &quot;Accept-Language&quot;);
            urlRequest.setValue_forHTTPHeaderField_(&quot;gzip, deflate, br&quot;, &quot;Accept-Encoding&quot;);
            urlRequest.setValue_forHTTPHeaderField_(&quot;appName/5 CFNetwork/1404.0.5 Darwin/22.3.0&quot;, &quot;User-Agent&quot;);
            urlRequest.setValue_forHTTPHeaderField_(&quot;keep-alive&quot;, &quot;Connection&quot;);

            var data1 = userUpdate.dataUsingEncoding_(NSUTF8StringEncoding);

            urlRequest.setHTTPBody_(data1);

            var session = ObjC.classes.NSURLSession.sharedSession();

            console.error(&quot;Setup request and is about to make it&quot;);
            var dataTask = session.dataTaskWithRequest_completionHandler_(urlRequest, new ObjC.Block({
                retType: &#x27;void&#x27;,
                argTypes: [&#x27;pointer&#x27;, &#x27;pointer&#x27;, &#x27;pointer&#x27;],
                implementation: function (data, response, error) {
                    var dataStr = NSString.alloc().initWithData_encoding_(data, NSUTF8StringEncoding);
                    var respObj = new ObjC.Object(response);
                    var errorObj = new ObjC.Object(error);
                    console.error(&quot;data: &quot;, dataStr);
                    console.error(&quot;response code: &quot;, respObj.statusCode());
                    console.error(&quot;error: &quot;, errorObj.toString());

                    // var respObj = new ObjC.Object(response);
                    // console.error(&quot;data as JSON string: &quot;, convertNSObjectToJSString(data));

                }
            }));
            dataTask.resume();
        }


        function setIntercept() {
            var scenes = ObjC.classes.UIApplication.sharedApplication().connectedScenes();

            var winSceneRegex = /UIWindowScene: (0x[a-fA-F0-9]+)/
            var scenesPtr = ptr(scenes.toString().match(winSceneRegex)[1]);
            var windowScene = ObjC.Object(scenesPtr);
            try {
                if (!scenes) {
                    console.error(&quot;Couldn&#x27;t file UIWindowScene on sharedApplication&quot;);
                } else {
                    Interceptor.attach(windowScene.delegate()[&quot;- scene:openURLContexts:&quot;].implementation, {
                        onEnter(args) {
                            // ObjC: args[0] = self, args[1] = selector, args[2-n] = arguments
                            const arg2Str = new ObjC.Object(args[2]);
                            console.error(&quot;String argument: &quot; + arg2Str.toString());
                            NSLog(NSString.stringWithFormat_(&quot;[*] BRAD scene:openURLContexts: argument 2: &quot; + arg2Str.toString()));

                            const arg3Str = new ObjC.Object(args[3]);
                            console.error(&quot;String argument: &quot; + arg3Str.toString());
                            NSLog(NSString.stringWithFormat_(&quot;[*] BRAD scene:openURLContexts: argument 3: &quot; + arg3Str.toString()));

                            globalar = arg3Str;
                            var appNameActionFromURLRegex = /URL: appName:\/\/(\S+)/; ///.*URL: appName: \/\/([a-z]*);.*/;
                            console.error(arg3Str.toString().match(appNameActionFromURLRegex));
                            var action = arg3Str.toString().match(appNameActionFromURLRegex)[1];

                            lockUnlockDoor(action);
                        }
                    });
                    console.error(&quot;[*]WindowScene() intercept placed&quot;);
                    NSLog(NSString.stringWithFormat_(&quot;[*]WindowScene() intercept placed&quot;));
                }
            }
            catch (err) {
                console.error(&quot;[*]BRAD Exception: &quot; + err.message);
                NSLog(NSString.stringWithFormat_(&quot;[*]BRAD Exception: &quot; + err.message));
            }
        }

        setTimeout(setIntercept, 1000); // IDK why I wanted to wait to add this method. I was thinking maybe it could take a while for the UIWindowScene to get created
        console.error(&quot;[*]BRAD SETTIMEOUT&quot;);
        NSLog(NSString.stringWithFormat_(&quot;[*]BRAD SETTIMEOUT&quot;));


    },
    dispose() {
        console.error(&#x27;[dispose]&#x27;);
    }
};

</code></pre><p>I save this as appName.js in the Frameworks folder.</p><p>In the Frameworks folder I ALSO create the Frida Gadget config to run the script. It is a file named: FridaGadget.config</p><pre><code>{
  &quot;interaction&quot;: {
    &quot;type&quot;: &quot;script&quot;,
    &quot;path&quot;: &quot;appName.js&quot;,
    &quot;on_change&quot;: &quot;reload&quot;
  }
}
</code></pre><p>I figure this code could be useful if someone wants to try something similar.</p><p>NOTE: That if you are trying to get the JWT from AWS like I was in the code above. It probably won&#x27;t work often unless the app refreshes it&#x27;s token often.</p><p>The app I was using DIDNT. So this route didn&#x27;t work. And triggering the app to run its refresh token code was taking forever to figure out.</p><p>So now back to actually getting something working.</p><h2>AWS Cognito Reverse engineering</h2><p>So this app actually uses an AWS service called Cognito that handles the all the auth. The 2FA and JWT related work is all handled by Cognito.</p><p>The documentation for AWS Cognito was IMO actually pretty bad. Especially when it came to less conventional uses like the way I could tell this iOS application was using it.</p><p>I couldn&#x27;t even find any working examples of using AWS Cognito as a client and I thought this might be helpful for someone trying to do something similar. My code maybe messy but it works and I have invested too much time in it as it is so I am calling it good. You&#x27;re gonna have to deal with the mess the code and thig post is until I get a lot of time on my hands.</p><p>So first off. I used Frida to poke around. And I see that AWS and something called AWS Cognito is being used from the loaded Frameworks. I findout that Cognito is used for auth. Also I saw in the decoded JWT via <a href="https://jwt.io/">https://jwt.io/</a> that scope of the jwt is &quot;aws.cognito.signin.user.admin&quot;. So I know now that this app is using Cognito for auth.</p><p>Then I think I was just using Frida&#x27;s ObjC.chooseSync and grabbing objects and I found some useful information. I also was using lldb and found some information I needed later for basically re creating the AWS Cognito login flow.</p><p>So when I run the iod-deploy I used the configuration that automatically starts the app and gives you an lldb session.</p><p>I think I started by looking at what I could break on that was AWSCognito related with the command:</p><pre><code>image lookup -r -n .*AWSCognito.*
</code></pre><p>This uses regex to search for anything AWSCognito related. Any methods on the classes that have the string AWSCognito will be listed.</p><p>I think I realized by looking at other AWS Cognito client implementations that didn&#x27;t work that I needed to get a few bits of information.</p><p>So I set breakpoints in lldb (using Frida again would have probably been easier but I am just documenting stuff I learned here)</p><pre><code>breakpoint set -r &#x27;\[AWSCognitoIdentityUserPoolConfiguration .*\]$
breakpoint set -r &#x27;\[AWSCognitoIdentityUserPool .*\]$
</code></pre><p>I am pretty sure I hit the following breakpoint:</p><pre><code>
  Summary: AWSAppSync`AWSAppSync.AWSCognitoUserPoolsAuthProviderAsync.getLatestAuthToken() -&gt; Swift.String        Address: AWSAppSync[0x0000000000027200] (AWSAppSync.__TEXT.__text + 131900)
</code></pre><p>And then I started printing out arguments to this method call:</p><pre><code>
po (SEL)$arg2

po $arg1

expression -l objc -O -- [$arg1 userPoolConfiguration]

expression -l objc -O -- [[$arg1 userPoolConfiguration] poolId]

</code></pre><p>The last one of these got me the poolId for AWSCognito account I needed to login with to get a JWT and refresh token so I could send lock and unlock commands.</p><p>NOTE: That the poolId will probably be in a format like this:</p><pre><code>us-east-1_6B31234KN
</code></pre><p>Then I also needed something called the clientID. This can actually be found in the requests from the HTTPS requests I dumped to JSON.</p><p><strong>Ironically</strong> I found just MITM this whole thing to be the easiest way to reverse engineer everything. But I wanted to practice my lldb/debugger skills anyway so I spent plenty of time trying to force that route.</p><p>I also needed to find this information which I got with Frida:</p><pre><code>var awsccp = [];
ObjC.choose(ObjC.classes[&#x27;AWSCognitoCredentialsProvider&#x27;], {
  onMatch: function (serv) {
    console.log(&#x27;Found AWSCognitoCredentialsProvider&#x27;, serv);
    awsccp.push(serv);
  },
  onComplete: function () {
    console.log(&#x27;Finished AWSCognitoCredentialsProvider search&#x27;);
  }
});

console.log(awsccp);


console.log(awsccp.getIdentityId())
&lt;AWSTask: 0x2867bf380; completed = YES; cancelled = NO; faulted = NO; result = us-east-1:47021234-ffff-4fff-afff-ffffbca71a1c&gt;

</code></pre><p>And then I had enough info to basically re create the server that the iPhone app used to send my login credentials to which would talk with AWS Cognito and get a JWT and refresh token. I wanted to have my own so that I could get a JWT whenever I want. And I found out that I can just basically refresh my JWT forever so I really just need to get that JWT and I refresh every 30 minutes I beleive it was. The code is below:</p><pre><code>const fullUserPoolId = &#x27;us-east-1_5F3ufo6uFF&#x27;
const userPoolId = &#x27;5F3ufo6uFF&#x27;
const ClientId = &#x27;ffuabckjpfffd1ab7881m6g88s&#x27;
const username = &quot;myemail@gmail.com&quot;;
const password = &quot;MyPassword&quot;;

import * as AWS from &#x27;aws-sdk&#x27;;
import AmazonCognitoIdentity, { CognitoRefreshToken, CognitoAccessToken } from &#x27;amazon-cognito-identity-js&#x27;;

import * as readline from &#x27;node:readline/promises&#x27;;
import { stdin as input, stdout as output } from &#x27;node:process&#x27;;

import * as http from &#x27;http&#x27;;
import * as url from &#x27;url&#x27;;



const rl = readline.createInterface({ input, output });


// // import type { ICognitoUserData } from &#x27;amazon-cognito-identity-js&#x27;;

// const cognitoUserPool = ;

// const cognitoUserData /*: ICognitoUserData*/ = {
//     Username: username,
//     Pool: cognitoUserPool,
//     Storage: undefined // ICognitoStorage ?
// }

var cognitoRefreshToken = null;
var cognitoAccessToken = null;

var authenticationData = {
    Username: username,
    Password: password,
};
var authenticationDetails = new AmazonCognitoIdentity.AuthenticationDetails(
    authenticationData
);
var poolData = {
    UserPoolId: fullUserPoolId, // Your user pool id here
    ClientId: ClientId, // Your client id here
};
var userPool = new AmazonCognitoIdentity.CognitoUserPool(poolData);
var userData = {
    Username: username,
    Pool: userPool,
};
var cognitoUser = new AmazonCognitoIdentity.CognitoUser(userData);

cognitoUser.setAuthenticationFlowType(&#x27;CUSTOM_AUTH&#x27;);



function refreshToken() {
    const refreshFromGlobal = (cognitoRefreshToken || process.env.APPNAME_REFRESH_TOKEN);
    console.log(&quot;Refreshing tokens. What I have globally and in env is:&quot;, refreshFromGlobal)
    if (refreshFromGlobal) {
        cognitoUser.refreshSession(cognitoRefreshToken || new CognitoRefreshToken({ RefreshToken: process.env.APPNAME_REFRESH_TOKEN }), (err, session) =&gt; {
            if (err) {
                console.error(&quot;Error refreshing tokens&quot;, err)
            } else {
                console.log(&quot;Refreshed tokens&quot;, session)
                // SO LAME, now accessToken and refreshToken are lower case to start..
                const { accessToken, refreshToken } = session;
                if (refreshToken) {
                    cognitoRefreshToken = refreshToken;
                } else {
                    console.log(&quot;No refresh token after refresh&quot;);
                }
                if (accessToken) {
                    cognitoAccessToken = accessToken;
                } else {
                    console.log(&quot;No access token after refresh&quot;);
                }
            }
        })
    } else {
        console.error(&quot;No refresh token to refresh&quot;, refreshFromGlobal)
    }
}

function startHTTPServer() {

    setInterval(() =&gt; {
        refreshToken();
    }, 1000 * 60 * 30)

    console.log(`Starting HTTP Server`)
    // Configure our HTTP server to respond with Hello World to all requests.
    var server = http.createServer(function (request, response) {
        console.log(`HTTP handling request: ${request}\n\n\n\nWith response: ${response}`)
        //    var name=request.getParameter(&#x27;name&#x27;);
        //    console.log(name);
        const action = url.parse(request.url, true).query[&#x27;action&#x27;];
        if (action) {
            const actionParsed = (action == &#x27;lock&#x27; || action == &#x27;unlock&#x27;) ? action : &#x27;lock&#x27;;
            sendLockUnlockRequest(actionParsed).then((res) =&gt; {
                response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
                response.end(`Handling action for ${actionParsed}. Response: ${JSON.stringify(res)}\n`);
            })
        } else {
            response.writeHead(500, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
            response.end(`Invalid request\n`);
        }
    });
    // Listen on port 8000, IP defaults to 127.0.0.1
    server.listen(8000);
}


async function sendLockUnlockRequest(action) {
    if (action != &#x27;lock&#x27; &amp;&amp; action != &#x27;unlock&#x27;) {
        console.error(`Invalid action: ${action} sent to sendLockUnlockRequest`);
        return
    }

    console.log(&quot;Makeing request with:&quot;, {
        method: &quot;PATCH&quot;, // *GET, POST, PUT, DELETE, etc.
        headers: {
            &#x27;Accept&#x27;: &#x27;application/json&#x27;,
            &#x27;Accept-Language&#x27;: &#x27;en-US,en;q=0.9&#x27;,
            &#x27;Authorization&#x27;: `Bearer ${cognitoAccessToken.getJwtToken()}`,
            &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate, br&#x27;
        },
        body: &quot;{\&quot;action\&quot;: \&quot;&quot; + action + &quot;\&quot;, \&quot;source\&quot;: \&quot;{\\\&quot;name\\\&quot;:\\\&quot;Brad\\\&quot;,\\\&quot;device\\\&quot;:\\\&quot;iPhone\\\&quot;}\&quot;}&quot;
    });
    console.log(&quot;body: &quot;, &quot;{\&quot;action\&quot;: \&quot;&quot; + action + &quot;\&quot;, \&quot;source\&quot;: \&quot;{\\\&quot;name\\\&quot;:\\\&quot;Brad\\\&quot;,\\\&quot;device\\\&quot;:\\\&quot;iPhone\\\&quot;}\&quot;}&quot;)
    const response = await fetch(&#x27;https://COMPANYID.execute-api.us-east-1.amazonaws.com/prod_v1/devices/PROBMYDEVICEID/status&#x27;, {
        method: &quot;PATCH&quot;, // *GET, POST, PUT, DELETE, etc.
        headers: {
            &#x27;Accept&#x27;: &#x27;application/json&#x27;,
            &#x27;Accept-Language&#x27;: &#x27;en-US,en;q=0.9&#x27;,
            &#x27;Authorization&#x27;: `Bearer ${cognitoAccessToken.getJwtToken()}`,
            &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate, br&#x27;
        },
        body: `{&quot;action&quot;: &quot;${action}&quot;, &quot;source&quot;: &quot;{\\&quot;name\\\&quot;:\\\&quot;Bradley\\\&quot;,\\\&quot;device\\\&quot;:\\\&quot;iPhone\\\&quot;}&quot;}`
    });
    const responseFromAppName = await response.json();
    console.log(&quot;response from lock/unlock:&quot;, responseFromAppName);
    return responseFromAppName;
}

async function emailAuthCode(smsCode) {
    return new Promise((resolve, reject) =&gt; {
        cognitoUser.sendCustomChallengeAnswer(&#x27;answerType:verifyCode,medium:phone,codeType:login,code:&#x27; + smsCode, {
            mfaRequired: function (result) {
                console.log(&quot;result from mfaRequired 2:&quot;, result);
            },
            selectMFAType: function (result) {
                console.log(&quot;result from selectMFAType 2:&quot;, result);
            },
            mfaSetup: function (result) {
                console.log(&quot;result from mfaSetup 2:&quot;, result);
            },
            totpRequired: function (result) {
                console.log(&quot;result from totpRequired 2:&quot;, result);
            },
            newPasswordRequired: function (result) {
                console.log(&quot;result from newPasswordRequired 2:&quot;, result);
            },
            associateSecretCode: function (result) {
                console.log(&quot;result from associateSecretCode 2:&quot;, result);
            },
            inputVerificationCode: function (result) {
                console.log(&quot;result from inputVerificationCode 2:&quot;, result);
            },
            associateSecretCode: function (result) {
                console.log(&quot;result from associateSecretCode 2:&quot;, result);
            },
            onSuccess: function (cognitoUserSession) {
                console.log(&quot;result from sending Custom Answer 2:&quot;, cognitoUserSession);
                cognitoAccessToken = cognitoUserSession.getAccessToken();
                cognitoRefreshToken = cognitoUserSession.getRefreshToken();
                console.log(&#x27;Got tokens: &#x27;, cognitoUserSession);
                startHTTPServer();
                // TODO: Send curl to open door form here with
            },
            onFailure: function (err) {
                console.log(&quot;err:&quot;, err)
            },
            customChallenge: function (challengeParameters) {
                // TODO: From here do I initAuth again for PASSWORD_VERIFIER
                console.log(&quot;challengeParameters from sending Custom Answer 2:&quot;, challengeParameters)
            }
        });
    })
}

async function emailAuthInit() {
    return new Promise((resolve, reject) =&gt; {
        cognitoUser.authenticateUser(authenticationDetails, {

            customChallenge: function (challengeParameters) {
                console.log(&quot;challengeParameters:&quot;, challengeParameters)
                cognitoUser.sendCustomChallengeAnswer(&#x27;answerType:generateCode,medium:phone,codeType:login&#x27;, {
                    onSuccess: function (result) {
                        console.log(&quot;result from sending Custom Answer 1:&quot;, result)
                    },
                    onFailure: function (err) {
                        console.log(&quot;err:&quot;, err)
                    },
                    customChallenge: function (challengeParameters) {
                        console.log(&quot;challengeParameters from sending Custom Answer:&quot;, challengeParameters)
                        resolve(challengeParameters);
                        // TODO This code I think comes from SMS!


                    }
                });

            },

            onSuccess: function (result) {
                var accessToken = result.getAccessToken().getJwtToken();

                console.log(`\naccessToken from cogintoUser authenticateUser: ${accessToken}\n`);

                //POTENTIAL: Region needs to be set if not already set previously elsewhere.
                AWS.config.region = &#x27;us-east-1&#x27;;
                const k = `cognito-idp.&lt;region&gt;.amazonaws.com/${userPoolId}`;
                AWS.config.credentials = new AWS.CognitoIdentityCredentials({
                    IdentityId: &#x27;us-east-1:ffff0a60-ffff-4fff-fffc-ffffbca71ffc&#x27;, // your identity pool id here
                    Logins: {
                        // Change the key below according to the specific region your user pool is in.
                        // cognito-idp.us-east-1.amazonaws.com
                        [k]: result
                            .getIdToken()
                            .getJwtToken(),
                    },
                });

                console.log(`sessionToken:  ${AWS.config.credentials.sessionToken}`);
                console.log(`secretAccessKey:  ${AWS.config.credentials.secretAccessKey}`);
                //refreshes credentials using AWS.CognitoIdentity.getCredentialsForIdentity()
                // AWS.config.credentials.refresh(error =&gt; {
                //     if (error) {
                //         console.error(error);
                //     } else {
                //         // Instantiate aws sdk service objects now that the credentials have been updated.
                //         // example: var s3 = new AWS.S3();
                //         console.log(&#x27;Successfully logged!&#x27;);
                //     }
                // });
            },

            onFailure: function (err) {
                console.log(err.message || JSON.stringify(err));
            },
        });
    });
}

if (process.env[&#x27;APPNAME_ACCESS_TOKEN&#x27;] &amp;&amp; process.env[&#x27;APPNAME_REFRESH_TOKEN&#x27;]) {
    cognitoAccessToken = new CognitoAccessToken({ AccessToken: process.env[&#x27;APPNAME_ACCESS_TOKEN&#x27;] });
    cognitoRefreshToken = new CognitoRefreshToken({ RefreshToken: process.env[&#x27;APPNAME_REFRESH_TOKEN&#x27;] });
    console.log(`Got tokens from env: `, cognitoAccessToken.getJwtToken(), &quot;\nRefresh:&quot;, cognitoRefreshToken.getToken());
    startHTTPServer();
} else {
    console.log(`No tokens in ENV getting them via Cognito`);
    await emailAuthInit();
    const smsCode = await rl.question(&#x27;What is the SMS Code: &#x27;);
    await emailAuthCode(smsCode);
}
</code></pre><p>The really tricky part was looking at the HTTPS dumped requests and figuring out what kind of AWS Cogntio requests I needed to make and what strings to pass. But this was all reverse engineerable from the information in the request bodies and by reading the AWS Cognito library source code.</p><p>Basically if you find yourself trying to write something similar where you want to recreate an AWS Cognito login flow and see requests that have in the body:</p><ol><li>A request with AuthFlow: CUSTOM_AUTH</li><li>Then a request with ChallengeName: PASSWORD_VERIFIER</li><li>Then a request with ChallengeResponses: PASSWORD_CLAIM_SECRET_BLOCK</li><li>Then ChallengeName: CUSTOM_CHALLENGE</li><li>ChallengeResponses: \&quot;ANSWER\&quot;:\&quot;answerType:generateCode,medium:phone,codeType:login\&quot;</li><li>&quot;{\&quot;ChallengeName\&quot;:\&quot;CUSTOM_CHALLENGE\&quot;,\&quot;ChallengeParameters\&quot;:{\&quot;challengeType\&quot;:\&quot;code\&quot;}</li></ol><p>Then the above code should be hackable to get something working for you.</p><p>My auth flow required authorizing via my username and password then doing 2fa using my phone number which was already in their system somehow.
Because I started getting a text with a code after I passed the first part of the Cogntio verification with the email and password.</p><p>Hopefully my Cognito client code above is helpful for someone.</p><p>I figured out a bunch of other interesting stuff that I think is useful but I&#x27;ll have to put that into another post.. this post is already a mess of information and is probably hard to follow.</p><p>I did figure out how to send fake touch events. So in this case I could script having the app open then wait a second for the app to load and send touch event to the middle of the screen just to hit the lock or unlock button.</p><p>The hackiest of hacks but it&#x27;s really cool sending these fake touch events. I&#x27;ll write a post about that next.</p><h3>Just some lldb notes:</h3><p>Ever be steppin and you step INTO a jump/function call and just want to get back to where you were?</p><pre><code>thread step-out
</code></pre><p>will get you back!</p><p>And you can use it to jump over call or bl instructions as well.</p><p>So my LLDB flow was mostly:</p><ol><li>Search for possible places to set breakpoints with:</li></ol><pre><code>image lookup -r -n .*AWSCognito.*
</code></pre><p>AWSCognito being something related to whatever you want to learn more about. Maybe its refreshToken or something..</p><ol start="2"><li>Then I check that list it generates and see how ridiculously long it is. If I am going to be setting to many breakpoints I work that regex down to be more specific and then set breakpoints with:</li></ol><pre><code>br set -r  .*refreshToken.*
</code></pre><p>Then when I hit a breakpoint I would read all the variables and pointers I could. I would check the backtrace to see whats going on:</p><pre><code>bt
</code></pre><p>and from there I could select different &quot;frames&quot; or functions called to get to my breakpoint:</p><pre><code>frame select SOMENUMBERHERE
</code></pre><p>I would check the registers at each frame:</p><pre><code>register read --all
</code></pre><p>Although they obviously made the most sense down at the frame you break into.</p><p>For each frame your in if you want to see the full dissassembly of the current function run:</p><pre><code>di -f
</code></pre><ol start="3"><li>Just start printing out all the info.</li></ol><p>LLDB has nice aliases for the registers that contain function call arguments and can be printed out with:</p><pre><code>po $arg1
po $arg2
etc...
</code></pre><ol start="4"><li>Accessing data on objects I found:</li></ol><pre><code>expression -l objc -O -- [$arg1 userPoolConfiguration]
</code></pre><ol start="5"><li>Creating variables in LLDB:</li></ol><pre><code>expression -l objc -O -- NSURL *$url = [NSURL URLWithString:@&quot;appName://&quot;];
</code></pre><p>Would create an NSUrl with the lldb variable name $url.
Then I could test that my method was in fact swizzed correctly with:</p><pre><code>expression -l objc -O -- [[UIApplication sharedApplication].delegate application:[UIApplication sharedApplication] handleOpenURL:$url];
</code></pre><p>More examples of variables:</p><pre><code>expression id $delegate = (id)[[UIApplication sharedApplication] delegate]
expression id $keyWindow= (id)[$delegate window]
expression id $root = (id)[$keyWindow rootViewController]
po $root
</code></pre><ol start="6"><li>Got a sneaking suspicion some address is really a pointer? Want to see if its an object?
Cast it as an (id) and po it:</li></ol><pre><code>po (id)0x7facaada2c80
</code></pre><ol start="7"><li>IMPORTANT - You can use</li></ol><pre><code>command script import lldb.macosx.heap
</code></pre><p>in lldb to get access to some realllllly helpful heap functions. Similar to what Frida provides for searching the heap for objects. Huuuuuuge for me.</p><ol start="8"><li>My .lldbinit file:</li></ol><pre><code>command script import lldb.macosx.heap
type summary add --category swift --summary-string &quot;Unmanaged Contains: ${var._value%@}&quot; Swift.Unmanaged&lt;AnyObject&gt;
command script import /Users/bbarrows/lldb/load_swift.py
# to run lldb &quot;shell&quot; scripts
command alias shsource command source
# to run a shell command, like `open`
command alias shellcmd platform shell
# tell lldb to assume swift, not objc
settings set target.language Swift
command alias clear-lang settings clear target.language
command alias swiftui_script load_swift /Users/bbarrows/lldb/helpers.swift
#command script import  /Users/bbarrows/repos/MyLLDB/python/sbt.py
command alias eco expression -l objective-c -O --
command alias ecs expression -l swift -O --
command alias br breakpoint
command alias rr register read
command alias rra register read
command regex ims &#x27;s/(.+)/image lookup -rn %1/&#x27;
command regex z &#x27;s/(.+)/breakpoint set -r %1/&#x27;
command regex mr &#x27;s/(.+) (.+)/memory read --size 8 --format x --count %2 %1/&#x27;
command regex pos  &#x27;s/(.+)/po (const char *)%1/&#x27;
command regex posc  &#x27;s/(.+)/expression -l swift -O -- unsafeBitCast(0x7f8c7b002b30, to: %1.self)/&#x27;
</code></pre><h3>Useful tools</h3><p>Best tool I think for dumping headers these days is <a href="https://github.com/cxnder/ktool">ktool</a>
Really nice GUI too and handles the MachO sections that are causing the older header dump tools to fail.</p><p>I also probably learned the most and got the farthest just using lldb and Frida BUT attaching xCode to your running process and then using the xCode Memory Graph was super helpful to figure out what was related to what and what information I could find. For example, I had some Swift class with private properties or whatever that I couldn&#x27;t access but I was able to figure out the offset from the object handle and get a reference to its JWT that way.</p><p>For me Frida and lldb are the most useful tools other then, in this case, just using a tool like Charles Proxy for dumping the https session. I actually was using another tool called Quantum I think but same idea and I can&#x27;t remember the name now. Surge 5 also works fine.. But it&#x27;s pretty buggy and has poort documentation especially if your trying to do stuff like have your mac control it on your phone.</p><h1>Summary</h1><p>I poked around a lot trying a lot of different things. I was hoping to just hook or add and implementation for handling IOS URLSchemes so I could script opening the app and have it lock and unlock the door.</p><p>I couldn&#x27;t find a good way to get a JWT that was always valid. The application will run some Swift code that I wasn&#x27;t able to track down in a relatively sane amount of time so I gave up on getting the JWT and refresh token from the heap/app.</p><p>I ended up looking at the HTTPS requests. Figuring out it was using AWS Cognito. And then re creating my own service that just mimicks whats the lock company does to get me a JWT for their lock control server.</p><p>Now I have a service running that I logged into once, it refreshes the JWT every 30 min, and I can send HTTPS requests to it to lock and unlock my door with a Siri/Shortcut I created.</p></div></div></article><footer class="jsx-3387257903"><div class="jsx-3387257903 social-list"><div class="jsx-255066894"><a title="LinkedIn" href="https://www.linkedin.com/in/bbarrows/}" target="_blank" rel="noopener" class="jsx-255066894"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#222"><path fill="#444" d="M5.453 11.099v15.484H.297V11.099h5.156zm.328-4.781q.016 1.141-.789 1.906t-2.117.766h-.031q-1.281 0-2.063-.766T0 6.318q0-1.156.805-1.914t2.102-.758 2.078.758.797 1.914zM24 17.708v8.875h-5.141v-8.281q0-1.641-.633-2.57t-1.977-.93q-.984 0-1.648.539t-.992 1.336q-.172.469-.172 1.266v8.641H8.296q.031-6.234.031-10.109t-.016-4.625l-.016-.75h5.141v2.25h-.031q.312-.5.641-.875t.883-.812 1.359-.68 1.789-.242q2.672 0 4.297 1.773t1.625 5.195z"></path></svg></a><a title="GitHub" href="https://github.com/bebrws/" target="_blank" rel="noopener" class="jsx-255066894"><svg viewBox="0 0 11 11" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2" width="24" height="24" fill="#222"><path d="M10.5 5.63a4.992 4.992 0 01-.977 3.016A5.018 5.018 0 016.998 10.5c-.12.022-.207.007-.263-.047a.267.267 0 01-.083-.2v-1.41c0-.432-.116-.748-.347-.948.253-.027.481-.067.683-.12.203-.054.412-.14.627-.26.216-.121.396-.27.54-.445.145-.176.263-.41.354-.702.091-.291.137-.626.137-1.005a1.95 1.95 0 00-.527-1.376c.164-.405.147-.86-.053-1.363-.125-.04-.305-.015-.54.074a3.59 3.59 0 00-.614.294l-.254.16a4.727 4.727 0 00-1.28-.174c-.44 0-.867.058-1.28.174a5.931 5.931 0 00-.284-.18 3.995 3.995 0 00-.557-.258c-.254-.1-.445-.13-.574-.09-.195.504-.211.958-.046 1.363a1.95 1.95 0 00-.527 1.376c0 .379.045.713.136 1.002.092.29.208.523.35.702.143.178.322.327.537.447.216.12.425.207.627.26.203.054.43.094.684.12-.178.161-.287.39-.327.689a1.32 1.32 0 01-.3.1 1.885 1.885 0 01-.38.034A.785.785 0 013 8.573a1.177 1.177 0 01-.37-.418 1.077 1.077 0 00-.324-.347.973.973 0 00-.33-.16l-.133-.02a.432.432 0 00-.194.03c-.035.02-.046.045-.033.077a.487.487 0 00.147.174l.046.033c.098.044.195.129.29.254.096.124.166.238.21.34l.067.154c.058.17.156.306.294.41.138.105.287.172.447.201.16.029.314.045.463.047a1.96 1.96 0 00.37-.024l.154-.026a62.026 62.026 0 00.007.955c0 .08-.03.147-.087.2-.058.054-.147.07-.267.047a5.018 5.018 0 01-2.524-1.854A4.992 4.992 0 01.255 5.63c0-.93.23-1.789.687-2.575a5.103 5.103 0 011.865-1.867A5.005 5.005 0 015.377.5c.93 0 1.787.23 2.572.688a5.103 5.103 0 011.864 1.867c.458.786.687 1.645.687 2.575z" fill="#444" fill-rule="nonzero"></path></svg></a></div></div><p class="jsx-3618008669">© 2021</p></footer></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Reverse engineering an iOS application to allow for integration with shortcuts and Siri - Recreate AWS Cognito authentication and sending fake UITouch events","dateString":"2023-05-12","slug":"ios-aws-cognito-reverse-engineering","description":"","tags":["Reverse engineering","iOS","aws","cognito","frida","lldb","osx","Siri","shortcuts","UITouch","SwiftUI","Deep linking","IOS URLScheme"],"author":"bebrws","source":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i \u003c arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i \u003c sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i \u003c sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Stuck With a Smart Lock That Only Works With Google or Alexa? Let's Fix That!\"), mdx(\"p\", null, \"I should have written this up sooner while it was still fresh in my mind. Apologies for the scattered information, but the AWS Cognito example might be helpful to some. Additionally, the Frida Gadget scripting to add a URL Scheme could be beneficial.\"), mdx(\"p\", null, \"I am going to make another post for how I was able to use a library by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/lyft/Hammer\"\n  }, \"Lyft called Hammer\"), \" to send fake UITouch events as well next.. and maybe one on just all the lldb commands I learned and what I thought was really helpful.\"), mdx(\"h2\", null, \"Why the Obscure Blog Post and Code?\"), mdx(\"p\", null, \"Apologies, but I\\u2019ve obscured company names and details. Unfortunately, you won\\u2019t be able to directly use this work if you have the same door lock as me, but if you\\u2019re smart enough to recognize the same libraries and network requests, you should be able to gather the necessary information and recreate a useful server/tool to control your door as you wish.\"), mdx(\"h2\", null, \"Introduction - IOS URLScheme and Frida and some lldb\"), mdx(\"p\", null, \"I moved into a new apartment with a smart lock that has an iOS app, which is convenient. However, it takes a while to load the app and press the button to lock and unlock the door. I really just wanted to be able to tell Siri to do it if my hands were full. Plus, I enjoy exploring iOS.\"), mdx(\"p\", null, \"I\\u2019ll try to go through my process in the order I followed (mostly) because I learned a lot along the way, recreating this blog post from my notes.\"), mdx(\"p\", null, \"To summarize, as someone suggested, the easiest way to achieve this would be to sniff the network traffic and recreate it. But I wanted to learn more about iOS and reverse engineering, so I initially took the harder route.\"), mdx(\"p\", null, \"I started by using software like Charles Proxy to examine the network traffic. What did I find? A straightforward JSON API that uses a JWT token for authentication to lock and unlock the door.\"), mdx(\"p\", null, \"To demonstrate how easy it initially seemed to use this API, here\\u2019s a cURL command showing me using the API to lock the door:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"curl -X PATCH \\\"https://$SOMECOMPANYID.execute-api.us-east-1.amazonaws.com/prod_v1/devices/$PROBMYDEVICEID/status\\\" -H \\\"User-Agent: AppName/5 CFNetwork/1404.0.5 Darwin/22.3.0\\\" -H \\\"Content-Type: application/json\\\" -H \\\"Accept: application/json\\\" -H \\\"Accept-Language: en-US,en;q=0.9\\\" -H \\\"Authorization: Bearer $KBEARER\\\" -H \\\"Accept-Encoding: gzip, deflate, br\\\" -d \\\"{\\\\\\\"action\\\\\\\": \\\\\\\"lock\\\\\\\", \\\\\\\"source\\\\\\\": \\\\\\\"{\\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"$MYNAME\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"device\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"iPhone\\\\\\\\\\\\\\\"}\\\\\\\"}\\\"\\n\")), mdx(\"p\", null, \"So all I need to do is send the JSON below to some URL with an AUTH token basically.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"{\\\"action\\\": \\\"lock\\\", \\\"source\\\": \\\"{\\\\\\\"name\\\\\\\":\\\\\\\"Brad\\\\\\\",\\\\\\\"device\\\\\\\":\\\\\\\"iPhone\\\\\\\"}\\\"}\\n\")), mdx(\"p\", null, \"As I continued to examine the intercepted HTTPS traffic, I saw that there were multiple requests before this one, and one of them contained the AUTH token. I realized there was a process happening to obtain the JWT, which looked a bit complicated.\"), mdx(\"p\", null, \"At first, I hoped I could just find some object in the heap that contained the AUTH token and use that via Frida (and its amazing API with functionality like pulling all objects of any type from memory!). However, none of the AUTH tokens I found were working.\"), mdx(\"p\", null, \"I should also mention that my original plan was to add an iOS URL Scheme to the application so I could create a Siri Shortcut that would open a URL to lock and unlock my door.\"), mdx(\"p\", null, \"I tried several things, such as creating iOS tweaks, making a custom dylib in Xcode, and manually adding it to the main executable using install_name_tool, then swizzling it to add new functionality.\"), mdx(\"p\", null, \"For those who may need an explanation: a dylib is a dynamically linked library, meaning it\\u2019s a binary that the operating system (or more specifically, dyld) loads into memory when an application starts.\"), mdx(\"p\", null, \"So, I needed a decrypted copy of the application I was going to modify/debug/etc. Some websites surprisingly provide this service, but I found my old iPhone 6s and was able to use Checkra1n and Palera1n on an iPhone 7 to get them jailbroken. At this point, what worked best for me was frida-ios-dump.\"), mdx(\"p\", null, \"Instead of installing usbmuxd/iproxy, if you\\u2019re on the same network, you can just use the IP address:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"./dump.py -H 192.168.1.87 -p 22 AppName\\n\")), mdx(\"p\", null, \"NOTE: From here on out, I\\u2019ll refer to the iOS app as AppName.\"), mdx(\"p\", null, \"After running this dump, you should end up with an unencrypted \\u201C.ipa\\u201D file in the same folder. An ipa file type is a zip file that contains the application and all its data/metadata.\"), mdx(\"p\", null, \"You can change the extension from .ipa to .zip and unzip it right there.\"), mdx(\"p\", null, \"Inside, you\\u2019ll find a folder named Payload, and inside that, there will be AppName.App.\"), mdx(\"p\", null, \"Just like a .App on macOS, you can right-click and show package contents to see what the app really contains.\"), mdx(\"p\", null, \"The most important file will be the binary itself, which is normally also named AppName (with no file extension) and will be an arm64 binary built for iOS.\"), mdx(\"p\", null, \"There is also a Frameworks folder that will contain a number of frameworks, which are essentially dylibs with additional information, like header files, that the binary loads at runtime.\"), mdx(\"p\", null, \"Any executable will have a list of dynamically linked libraries it loads at runtime. You can list those with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"otool -L $EXE_NAME_HERE\\n\")), mdx(\"p\", null, \"or to get a more detailed breakdown that includes information such as the path where the binary will look for the dylibs:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"otool -l $EXE_NAME_HERE\\n\")), mdx(\"p\", null, \"It\\u2019s important to use the lowercase -l option so you can see where rpath points in some cases. In most cases, it will just be the Frameworks directory.\"), mdx(\"p\", null, \"So, if you\\u2019re going to add your own dylib, you could, for example, use a tool like insert_dylib.\"), mdx(\"p\", null, \"For example, I built my own dylib, which initially attempted to swizzle the older handleURL methods on the iOS AppDelegate (this no longer works, by the way).\"), mdx(\"p\", null, \"To insert your dylib, you would do something like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"insert_dylib --strip-codesig --inplace '@executable_path/Frameworks/libhandleURLSwizzleObjC.dylib' ~/Payload/AppName.app/AppName\\ncp ~/libhandleURLSwizzleObjC.dylib ~/Payload/AppName.app/Frameworks\\n\")), mdx(\"p\", null, \"In your dylib code (you can create a dylib in Xcode by creating a static library and then changing the library type to dynamic in build options; you may also want to change the extension from .a to .dylib), you will want to add a constructor function.\"), mdx(\"p\", null, \"This function is called when the dylib is loaded into memory, and it\\u2019s your chance to \\u201Cswizzle\\u201D or replace existing functions with your own, allowing you to add or modify existing functionality in an application.\"), mdx(\"p\", null, \"These days, you can use a tool called objection to handle signing everything and converting your Payload folder into an ipa for you.\"), mdx(\"p\", null, \"Then, you can use another tool, ios-deploy, to send the app to your iPhone, whether jailbroken or not, and start a debugging session with LLDB. Objection by default injects Frida, so you can connect to Frida and poke around as well!\"), mdx(\"p\", null, \"It\\u2019s all very user-friendly and pretty easy to get started with.\"), mdx(\"h2\", null, \"Getting IOS URLScheme to Work\"), mdx(\"p\", null, \"Even though I didn\\u2019t end up going this route, I finally figured out a cool way to make it work and wanted to document it. With the newer iOS SDKs and SwiftUI, the older handleURL method on AppDelegate is no longer called (I believe) with a URL Scheme.\"), mdx(\"p\", null, \"First off, I needed to update my iOS app\\u2019s plist file so it would handle URLs like AppName://unlockdoor.\"), mdx(\"p\", null, \"To do so, I scripted:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"head -n4 ~/Payload/AppName.app/Info.plist \u003e ~/Payload/AppName.app/Info.plist-2\\necho \\\"\\\"\\\"    \u003ckey\u003eCFBundleURLTypes\u003c/key\u003e\\n    \u003carray\u003e\\n        \u003cdict\u003e\\n            \u003ckey\u003eCFBundleURLSchemes\u003c/key\u003e\\n            \u003carray\u003e\\n                \u003cstring\u003eAppName\u003c/string\u003e\\n            \u003c/array\u003e\\n            \u003ckey\u003eCFBundleURLName\u003c/key\u003e\\n            \u003cstring\u003ecom.AppName.ble-wifi\u003c/string\u003e\\n        \u003c/dict\u003e\\n    \u003c/array\u003e\\\"\\\"\\\" \u003e\u003e ~/Payload/AppName.app/Info.plist-2\\ntail -n+5 ~/Payload/AppName.app/Info.plist \u003e\u003e ~/Payload/AppName.app/Info.plist-2\\nmv ~/Payload/AppName.app/Info.plist-2 ~/Payload/AppName.app/Info.plist\\n\")), mdx(\"p\", null, \"The important part is that the CFBundleURLSchemes contains the string for the url proto if I remember right and then the CFBundleURLName has to have the same Bundle of the App.\\nThere is a lot of documentation on this part too so I won't go into too much detail here.\"), mdx(\"p\", null, \"What I think is really cool is that the Frida Gadget, the Frida dylib, that is injected into the App will look for a script to run. So you can create apps with Frida injected and a script included in the Payload/App folder so that you don't need to write a dylib in objective-c or something and can create deployable packagable apps using Frida for tweaks! Pretty amazing.\"), mdx(\"p\", null, \"The documentation for \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://frida.re/docs/gadget/\"\n  }, \"Frida Gadgets is here\"), \". Definately check that out. It's a great feature I never knew about.\"), mdx(\"p\", null, \"So along with using this feature or Frida I ended up figuring out which method I needed to implement to handle IOS URLSchemes with ios 15.7.2 and probably later.\"), mdx(\"p\", null, \"You have to find the UIWindowScene and add a method \\\"- scene:openURLContexts:\\\". This is actually what is trigger with IOS URLSchemes on these newer iOS versions.\"), mdx(\"p\", null, \"I have a super hacky way of finding the UIWindowScene.. and I don't know why I didn't just use ObjC.choose or something.. But this is my Frida Gagdet script:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"rpc.exports = {\\n    init(stage, parameters) {\\n        console.error('[init]', stage, JSON.stringify(parameters));\\n\\n        var globalar = null;\\n\\n        var NSLog = new NativeFunction(Module.findExportByName('Foundation', 'NSLog'), 'void', ['pointer', '...']);\\n        var NSString = ObjC.classes.NSString;\\n        var str = NSString.stringWithFormat_(\\\"[*] BRAD IN FRIDA GADGET\\\");\\n        NSLog(str);\\n        console.error(\\\"[*] BRAD IN FRIDA GADGET\\\");\\n\\n\\n        var NSJSONSerialization = ObjC.classes.NSJSONSerialization;\\n        var NSUTF8StringEncoding = 4;\\n\\n        var NSURL = ObjC.classes.NSURL;\\n        // var NSError = ObjC.classes.NSError;\\n\\n        function convertNSObjectToJSString(obj) {\\n            var valid = NSJSONSerialization.isValidJSONObject_(obj);\\n            if (!valid) return null;\\n            const NSJSONWritingPrettyPrinted = 1;\\n            var errorPtr = Memory.alloc(Process.pointerSize);\\n            Memory.writePointer(errorPtr, NULL); // initialize to NULL\\n            var data = NSJSONSerialization.dataWithJSONObject_options_error_(obj, NSJSONWritingPrettyPrinted, errorPtr);\\n            var error = Memory.readPointer(errorPtr);\\n            if (error.isNull()) {\\n                var str = NSString.alloc().initWithData_encoding_(data, NSUTF8StringEncoding);\\n                return str.toString();\\n            } else {\\n                var errorObj = new ObjC.Object(error); // now you can treat errorObj as an NSError instance\\n                console.error(errorObj.toString());\\n                return null;\\n            }\\n        }\\n\\n\\n        function getCurrentJWT() {\\n            var awsMobileClientPtr = Number(ObjC.chooseSync(ObjC.classes[\\\"AWSMobileClient.AWSMobileClient\\\"])[0].handle);\\n            var awsMobileClientDictPtrStr = Number(awsMobileClientPtr + 0x0000000000000088).toString(16);\\n            var awsMobileClientDictPtr = new NativePointer(\\\"0x\\\" + awsMobileClientDictPtrStr);\\n            var dictPtr = awsMobileClientDictPtr.readPointer()\\n            var dictObj = new ObjC.Object(dictPtr);\\n            var dstr = dictObj.toString();\\n            console.error(\\\"String argument: \\\" + dstr);\\n            var regex = /.*(\\\"eyJ.*\\\").*/;\\n            var jwt = JSON.parse(dstr.match(regex)[1]);\\n            return jwt;\\n        }\\n\\n        function lockUnlockDoor(action) {\\n            var jwt = getCurrentJWT();\\n            console.error(\\\"Got JWT: \\\" + jwt);\\n\\n            var actionParsed = (action == \\\"lock\\\" || action == \\\"unlock\\\") ? action : \\\"lock\\\";\\n            var url = \\\"https://SOMECOMPANYID.execute-api.us-east-1.amazonaws.com/prod_v1/devices/PROBMYDEVICEID/status\\\";\\n            var nsurl = NSURL.alloc().initWithString_(url);\\n            var urlRequest = ObjC.classes.NSMutableURLRequest.alloc().initWithURL_(nsurl);\\n\\n            var actString = \\\"{\\\\\\\"action\\\\\\\": \\\\\\\"\\\" + actionParsed + \\\"\\\\\\\", \\\\\\\"source\\\\\\\": \\\\\\\"{\\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Brad\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"device\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"iPhone\\\\\\\\\\\\\\\"}\\\\\\\"}\\\";\\n            console.error(`\\\\n\\\\nBEB - actString: ${actString} ${actString.length}\\\\n\\\\n`);\\n            var userUpdate = NSString.stringWithFormat_(actString);\\n            console.error(`\\\\n\\\\nBEB - userUpdate: ${userUpdate.toString()} ${userUpdate.length()}\\\\n\\\\n`);\\n\\n            urlRequest.setHTTPMethod_(\\\"PATCH\\\");\\n            urlRequest.setValue_forHTTPHeaderField_(\\\"Bearer \\\" + jwt, \\\"Authorization\\\");\\n            urlRequest.setValue_forHTTPHeaderField_(`${actString.length}`, \\\"Content-Length\\\");\\n            urlRequest.setValue_forHTTPHeaderField_(\\\"application/json\\\", \\\"Content-Type\\\");\\n            urlRequest.setValue_forHTTPHeaderField_(\\\"application/json\\\", \\\"Accept\\\");\\n            urlRequest.setValue_forHTTPHeaderField_(\\\"en-US,en;q=0.9\\\", \\\"Accept-Language\\\");\\n            urlRequest.setValue_forHTTPHeaderField_(\\\"gzip, deflate, br\\\", \\\"Accept-Encoding\\\");\\n            urlRequest.setValue_forHTTPHeaderField_(\\\"appName/5 CFNetwork/1404.0.5 Darwin/22.3.0\\\", \\\"User-Agent\\\");\\n            urlRequest.setValue_forHTTPHeaderField_(\\\"keep-alive\\\", \\\"Connection\\\");\\n\\n            var data1 = userUpdate.dataUsingEncoding_(NSUTF8StringEncoding);\\n\\n            urlRequest.setHTTPBody_(data1);\\n\\n            var session = ObjC.classes.NSURLSession.sharedSession();\\n\\n            console.error(\\\"Setup request and is about to make it\\\");\\n            var dataTask = session.dataTaskWithRequest_completionHandler_(urlRequest, new ObjC.Block({\\n                retType: 'void',\\n                argTypes: ['pointer', 'pointer', 'pointer'],\\n                implementation: function (data, response, error) {\\n                    var dataStr = NSString.alloc().initWithData_encoding_(data, NSUTF8StringEncoding);\\n                    var respObj = new ObjC.Object(response);\\n                    var errorObj = new ObjC.Object(error);\\n                    console.error(\\\"data: \\\", dataStr);\\n                    console.error(\\\"response code: \\\", respObj.statusCode());\\n                    console.error(\\\"error: \\\", errorObj.toString());\\n\\n                    // var respObj = new ObjC.Object(response);\\n                    // console.error(\\\"data as JSON string: \\\", convertNSObjectToJSString(data));\\n\\n                }\\n            }));\\n            dataTask.resume();\\n        }\\n\\n\\n        function setIntercept() {\\n            var scenes = ObjC.classes.UIApplication.sharedApplication().connectedScenes();\\n\\n            var winSceneRegex = /UIWindowScene: (0x[a-fA-F0-9]+)/\\n            var scenesPtr = ptr(scenes.toString().match(winSceneRegex)[1]);\\n            var windowScene = ObjC.Object(scenesPtr);\\n            try {\\n                if (!scenes) {\\n                    console.error(\\\"Couldn't file UIWindowScene on sharedApplication\\\");\\n                } else {\\n                    Interceptor.attach(windowScene.delegate()[\\\"- scene:openURLContexts:\\\"].implementation, {\\n                        onEnter(args) {\\n                            // ObjC: args[0] = self, args[1] = selector, args[2-n] = arguments\\n                            const arg2Str = new ObjC.Object(args[2]);\\n                            console.error(\\\"String argument: \\\" + arg2Str.toString());\\n                            NSLog(NSString.stringWithFormat_(\\\"[*] BRAD scene:openURLContexts: argument 2: \\\" + arg2Str.toString()));\\n\\n                            const arg3Str = new ObjC.Object(args[3]);\\n                            console.error(\\\"String argument: \\\" + arg3Str.toString());\\n                            NSLog(NSString.stringWithFormat_(\\\"[*] BRAD scene:openURLContexts: argument 3: \\\" + arg3Str.toString()));\\n\\n                            globalar = arg3Str;\\n                            var appNameActionFromURLRegex = /URL: appName:\\\\/\\\\/(\\\\S+)/; ///.*URL: appName: \\\\/\\\\/([a-z]*);.*/;\\n                            console.error(arg3Str.toString().match(appNameActionFromURLRegex));\\n                            var action = arg3Str.toString().match(appNameActionFromURLRegex)[1];\\n\\n                            lockUnlockDoor(action);\\n                        }\\n                    });\\n                    console.error(\\\"[*]WindowScene() intercept placed\\\");\\n                    NSLog(NSString.stringWithFormat_(\\\"[*]WindowScene() intercept placed\\\"));\\n                }\\n            }\\n            catch (err) {\\n                console.error(\\\"[*]BRAD Exception: \\\" + err.message);\\n                NSLog(NSString.stringWithFormat_(\\\"[*]BRAD Exception: \\\" + err.message));\\n            }\\n        }\\n\\n        setTimeout(setIntercept, 1000); // IDK why I wanted to wait to add this method. I was thinking maybe it could take a while for the UIWindowScene to get created\\n        console.error(\\\"[*]BRAD SETTIMEOUT\\\");\\n        NSLog(NSString.stringWithFormat_(\\\"[*]BRAD SETTIMEOUT\\\"));\\n\\n\\n    },\\n    dispose() {\\n        console.error('[dispose]');\\n    }\\n};\\n\\n\")), mdx(\"p\", null, \"I save this as appName.js in the Frameworks folder.\"), mdx(\"p\", null, \"In the Frameworks folder I ALSO create the Frida Gadget config to run the script. It is a file named: FridaGadget.config\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"{\\n  \\\"interaction\\\": {\\n    \\\"type\\\": \\\"script\\\",\\n    \\\"path\\\": \\\"appName.js\\\",\\n    \\\"on_change\\\": \\\"reload\\\"\\n  }\\n}\\n\")), mdx(\"p\", null, \"I figure this code could be useful if someone wants to try something similar.\"), mdx(\"p\", null, \"NOTE: That if you are trying to get the JWT from AWS like I was in the code above. It probably won't work often unless the app refreshes it's token often.\"), mdx(\"p\", null, \"The app I was using DIDNT. So this route didn't work. And triggering the app to run its refresh token code was taking forever to figure out.\"), mdx(\"p\", null, \"So now back to actually getting something working.\"), mdx(\"h2\", null, \"AWS Cognito Reverse engineering\"), mdx(\"p\", null, \"So this app actually uses an AWS service called Cognito that handles the all the auth. The 2FA and JWT related work is all handled by Cognito.\"), mdx(\"p\", null, \"The documentation for AWS Cognito was IMO actually pretty bad. Especially when it came to less conventional uses like the way I could tell this iOS application was using it.\"), mdx(\"p\", null, \"I couldn't even find any working examples of using AWS Cognito as a client and I thought this might be helpful for someone trying to do something similar. My code maybe messy but it works and I have invested too much time in it as it is so I am calling it good. You're gonna have to deal with the mess the code and thig post is until I get a lot of time on my hands.\"), mdx(\"p\", null, \"So first off. I used Frida to poke around. And I see that AWS and something called AWS Cognito is being used from the loaded Frameworks. I findout that Cognito is used for auth. Also I saw in the decoded JWT via \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://jwt.io/\"\n  }, \"https://jwt.io/\"), \" that scope of the jwt is \\\"aws.cognito.signin.user.admin\\\". So I know now that this app is using Cognito for auth.\"), mdx(\"p\", null, \"Then I think I was just using Frida's ObjC.chooseSync and grabbing objects and I found some useful information. I also was using lldb and found some information I needed later for basically re creating the AWS Cognito login flow.\"), mdx(\"p\", null, \"So when I run the iod-deploy I used the configuration that automatically starts the app and gives you an lldb session.\"), mdx(\"p\", null, \"I think I started by looking at what I could break on that was AWSCognito related with the command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"image lookup -r -n .*AWSCognito.*\\n\")), mdx(\"p\", null, \"This uses regex to search for anything AWSCognito related. Any methods on the classes that have the string AWSCognito will be listed.\"), mdx(\"p\", null, \"I think I realized by looking at other AWS Cognito client implementations that didn't work that I needed to get a few bits of information.\"), mdx(\"p\", null, \"So I set breakpoints in lldb (using Frida again would have probably been easier but I am just documenting stuff I learned here)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"breakpoint set -r '\\\\[AWSCognitoIdentityUserPoolConfiguration .*\\\\]$\\nbreakpoint set -r '\\\\[AWSCognitoIdentityUserPool .*\\\\]$\\n\")), mdx(\"p\", null, \"I am pretty sure I hit the following breakpoint:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\n  Summary: AWSAppSync`AWSAppSync.AWSCognitoUserPoolsAuthProviderAsync.getLatestAuthToken() -\u003e Swift.String        Address: AWSAppSync[0x0000000000027200] (AWSAppSync.__TEXT.__text + 131900)\\n\")), mdx(\"p\", null, \"And then I started printing out arguments to this method call:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\npo (SEL)$arg2\\n\\npo $arg1\\n\\nexpression -l objc -O -- [$arg1 userPoolConfiguration]\\n\\nexpression -l objc -O -- [[$arg1 userPoolConfiguration] poolId]\\n\\n\")), mdx(\"p\", null, \"The last one of these got me the poolId for AWSCognito account I needed to login with to get a JWT and refresh token so I could send lock and unlock commands.\"), mdx(\"p\", null, \"NOTE: That the poolId will probably be in a format like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"us-east-1_6B31234KN\\n\")), mdx(\"p\", null, \"Then I also needed something called the clientID. This can actually be found in the requests from the HTTPS requests I dumped to JSON.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Ironically\"), \" I found just MITM this whole thing to be the easiest way to reverse engineer everything. But I wanted to practice my lldb/debugger skills anyway so I spent plenty of time trying to force that route.\"), mdx(\"p\", null, \"I also needed to find this information which I got with Frida:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"var awsccp = [];\\nObjC.choose(ObjC.classes['AWSCognitoCredentialsProvider'], {\\n  onMatch: function (serv) {\\n    console.log('Found AWSCognitoCredentialsProvider', serv);\\n    awsccp.push(serv);\\n  },\\n  onComplete: function () {\\n    console.log('Finished AWSCognitoCredentialsProvider search');\\n  }\\n});\\n\\nconsole.log(awsccp);\\n\\n\\nconsole.log(awsccp.getIdentityId())\\n\u003cAWSTask: 0x2867bf380; completed = YES; cancelled = NO; faulted = NO; result = us-east-1:47021234-ffff-4fff-afff-ffffbca71a1c\u003e\\n\\n\")), mdx(\"p\", null, \"And then I had enough info to basically re create the server that the iPhone app used to send my login credentials to which would talk with AWS Cognito and get a JWT and refresh token. I wanted to have my own so that I could get a JWT whenever I want. And I found out that I can just basically refresh my JWT forever so I really just need to get that JWT and I refresh every 30 minutes I beleive it was. The code is below:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const fullUserPoolId = 'us-east-1_5F3ufo6uFF'\\nconst userPoolId = '5F3ufo6uFF'\\nconst ClientId = 'ffuabckjpfffd1ab7881m6g88s'\\nconst username = \\\"myemail@gmail.com\\\";\\nconst password = \\\"MyPassword\\\";\\n\\nimport * as AWS from 'aws-sdk';\\nimport AmazonCognitoIdentity, { CognitoRefreshToken, CognitoAccessToken } from 'amazon-cognito-identity-js';\\n\\nimport * as readline from 'node:readline/promises';\\nimport { stdin as input, stdout as output } from 'node:process';\\n\\nimport * as http from 'http';\\nimport * as url from 'url';\\n\\n\\n\\nconst rl = readline.createInterface({ input, output });\\n\\n\\n// // import type { ICognitoUserData } from 'amazon-cognito-identity-js';\\n\\n// const cognitoUserPool = ;\\n\\n// const cognitoUserData /*: ICognitoUserData*/ = {\\n//     Username: username,\\n//     Pool: cognitoUserPool,\\n//     Storage: undefined // ICognitoStorage ?\\n// }\\n\\nvar cognitoRefreshToken = null;\\nvar cognitoAccessToken = null;\\n\\nvar authenticationData = {\\n    Username: username,\\n    Password: password,\\n};\\nvar authenticationDetails = new AmazonCognitoIdentity.AuthenticationDetails(\\n    authenticationData\\n);\\nvar poolData = {\\n    UserPoolId: fullUserPoolId, // Your user pool id here\\n    ClientId: ClientId, // Your client id here\\n};\\nvar userPool = new AmazonCognitoIdentity.CognitoUserPool(poolData);\\nvar userData = {\\n    Username: username,\\n    Pool: userPool,\\n};\\nvar cognitoUser = new AmazonCognitoIdentity.CognitoUser(userData);\\n\\ncognitoUser.setAuthenticationFlowType('CUSTOM_AUTH');\\n\\n\\n\\nfunction refreshToken() {\\n    const refreshFromGlobal = (cognitoRefreshToken || process.env.APPNAME_REFRESH_TOKEN);\\n    console.log(\\\"Refreshing tokens. What I have globally and in env is:\\\", refreshFromGlobal)\\n    if (refreshFromGlobal) {\\n        cognitoUser.refreshSession(cognitoRefreshToken || new CognitoRefreshToken({ RefreshToken: process.env.APPNAME_REFRESH_TOKEN }), (err, session) =\u003e {\\n            if (err) {\\n                console.error(\\\"Error refreshing tokens\\\", err)\\n            } else {\\n                console.log(\\\"Refreshed tokens\\\", session)\\n                // SO LAME, now accessToken and refreshToken are lower case to start..\\n                const { accessToken, refreshToken } = session;\\n                if (refreshToken) {\\n                    cognitoRefreshToken = refreshToken;\\n                } else {\\n                    console.log(\\\"No refresh token after refresh\\\");\\n                }\\n                if (accessToken) {\\n                    cognitoAccessToken = accessToken;\\n                } else {\\n                    console.log(\\\"No access token after refresh\\\");\\n                }\\n            }\\n        })\\n    } else {\\n        console.error(\\\"No refresh token to refresh\\\", refreshFromGlobal)\\n    }\\n}\\n\\nfunction startHTTPServer() {\\n\\n    setInterval(() =\u003e {\\n        refreshToken();\\n    }, 1000 * 60 * 30)\\n\\n    console.log(`Starting HTTP Server`)\\n    // Configure our HTTP server to respond with Hello World to all requests.\\n    var server = http.createServer(function (request, response) {\\n        console.log(`HTTP handling request: ${request}\\\\n\\\\n\\\\n\\\\nWith response: ${response}`)\\n        //    var name=request.getParameter('name');\\n        //    console.log(name);\\n        const action = url.parse(request.url, true).query['action'];\\n        if (action) {\\n            const actionParsed = (action == 'lock' || action == 'unlock') ? action : 'lock';\\n            sendLockUnlockRequest(actionParsed).then((res) =\u003e {\\n                response.writeHead(200, { \\\"Content-Type\\\": \\\"text/plain\\\" });\\n                response.end(`Handling action for ${actionParsed}. Response: ${JSON.stringify(res)}\\\\n`);\\n            })\\n        } else {\\n            response.writeHead(500, { \\\"Content-Type\\\": \\\"text/plain\\\" });\\n            response.end(`Invalid request\\\\n`);\\n        }\\n    });\\n    // Listen on port 8000, IP defaults to 127.0.0.1\\n    server.listen(8000);\\n}\\n\\n\\nasync function sendLockUnlockRequest(action) {\\n    if (action != 'lock' \u0026\u0026 action != 'unlock') {\\n        console.error(`Invalid action: ${action} sent to sendLockUnlockRequest`);\\n        return\\n    }\\n\\n    console.log(\\\"Makeing request with:\\\", {\\n        method: \\\"PATCH\\\", // *GET, POST, PUT, DELETE, etc.\\n        headers: {\\n            'Accept': 'application/json',\\n            'Accept-Language': 'en-US,en;q=0.9',\\n            'Authorization': `Bearer ${cognitoAccessToken.getJwtToken()}`,\\n            'Accept-Encoding': 'gzip, deflate, br'\\n        },\\n        body: \\\"{\\\\\\\"action\\\\\\\": \\\\\\\"\\\" + action + \\\"\\\\\\\", \\\\\\\"source\\\\\\\": \\\\\\\"{\\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Brad\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"device\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"iPhone\\\\\\\\\\\\\\\"}\\\\\\\"}\\\"\\n    });\\n    console.log(\\\"body: \\\", \\\"{\\\\\\\"action\\\\\\\": \\\\\\\"\\\" + action + \\\"\\\\\\\", \\\\\\\"source\\\\\\\": \\\\\\\"{\\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Brad\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"device\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"iPhone\\\\\\\\\\\\\\\"}\\\\\\\"}\\\")\\n    const response = await fetch('https://COMPANYID.execute-api.us-east-1.amazonaws.com/prod_v1/devices/PROBMYDEVICEID/status', {\\n        method: \\\"PATCH\\\", // *GET, POST, PUT, DELETE, etc.\\n        headers: {\\n            'Accept': 'application/json',\\n            'Accept-Language': 'en-US,en;q=0.9',\\n            'Authorization': `Bearer ${cognitoAccessToken.getJwtToken()}`,\\n            'Accept-Encoding': 'gzip, deflate, br'\\n        },\\n        body: `{\\\"action\\\": \\\"${action}\\\", \\\"source\\\": \\\"{\\\\\\\\\\\"name\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Bradley\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"device\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"iPhone\\\\\\\\\\\\\\\"}\\\"}`\\n    });\\n    const responseFromAppName = await response.json();\\n    console.log(\\\"response from lock/unlock:\\\", responseFromAppName);\\n    return responseFromAppName;\\n}\\n\\nasync function emailAuthCode(smsCode) {\\n    return new Promise((resolve, reject) =\u003e {\\n        cognitoUser.sendCustomChallengeAnswer('answerType:verifyCode,medium:phone,codeType:login,code:' + smsCode, {\\n            mfaRequired: function (result) {\\n                console.log(\\\"result from mfaRequired 2:\\\", result);\\n            },\\n            selectMFAType: function (result) {\\n                console.log(\\\"result from selectMFAType 2:\\\", result);\\n            },\\n            mfaSetup: function (result) {\\n                console.log(\\\"result from mfaSetup 2:\\\", result);\\n            },\\n            totpRequired: function (result) {\\n                console.log(\\\"result from totpRequired 2:\\\", result);\\n            },\\n            newPasswordRequired: function (result) {\\n                console.log(\\\"result from newPasswordRequired 2:\\\", result);\\n            },\\n            associateSecretCode: function (result) {\\n                console.log(\\\"result from associateSecretCode 2:\\\", result);\\n            },\\n            inputVerificationCode: function (result) {\\n                console.log(\\\"result from inputVerificationCode 2:\\\", result);\\n            },\\n            associateSecretCode: function (result) {\\n                console.log(\\\"result from associateSecretCode 2:\\\", result);\\n            },\\n            onSuccess: function (cognitoUserSession) {\\n                console.log(\\\"result from sending Custom Answer 2:\\\", cognitoUserSession);\\n                cognitoAccessToken = cognitoUserSession.getAccessToken();\\n                cognitoRefreshToken = cognitoUserSession.getRefreshToken();\\n                console.log('Got tokens: ', cognitoUserSession);\\n                startHTTPServer();\\n                // TODO: Send curl to open door form here with\\n            },\\n            onFailure: function (err) {\\n                console.log(\\\"err:\\\", err)\\n            },\\n            customChallenge: function (challengeParameters) {\\n                // TODO: From here do I initAuth again for PASSWORD_VERIFIER\\n                console.log(\\\"challengeParameters from sending Custom Answer 2:\\\", challengeParameters)\\n            }\\n        });\\n    })\\n}\\n\\nasync function emailAuthInit() {\\n    return new Promise((resolve, reject) =\u003e {\\n        cognitoUser.authenticateUser(authenticationDetails, {\\n\\n            customChallenge: function (challengeParameters) {\\n                console.log(\\\"challengeParameters:\\\", challengeParameters)\\n                cognitoUser.sendCustomChallengeAnswer('answerType:generateCode,medium:phone,codeType:login', {\\n                    onSuccess: function (result) {\\n                        console.log(\\\"result from sending Custom Answer 1:\\\", result)\\n                    },\\n                    onFailure: function (err) {\\n                        console.log(\\\"err:\\\", err)\\n                    },\\n                    customChallenge: function (challengeParameters) {\\n                        console.log(\\\"challengeParameters from sending Custom Answer:\\\", challengeParameters)\\n                        resolve(challengeParameters);\\n                        // TODO This code I think comes from SMS!\\n\\n\\n                    }\\n                });\\n\\n            },\\n\\n            onSuccess: function (result) {\\n                var accessToken = result.getAccessToken().getJwtToken();\\n\\n                console.log(`\\\\naccessToken from cogintoUser authenticateUser: ${accessToken}\\\\n`);\\n\\n                //POTENTIAL: Region needs to be set if not already set previously elsewhere.\\n                AWS.config.region = 'us-east-1';\\n                const k = `cognito-idp.\u003cregion\u003e.amazonaws.com/${userPoolId}`;\\n                AWS.config.credentials = new AWS.CognitoIdentityCredentials({\\n                    IdentityId: 'us-east-1:ffff0a60-ffff-4fff-fffc-ffffbca71ffc', // your identity pool id here\\n                    Logins: {\\n                        // Change the key below according to the specific region your user pool is in.\\n                        // cognito-idp.us-east-1.amazonaws.com\\n                        [k]: result\\n                            .getIdToken()\\n                            .getJwtToken(),\\n                    },\\n                });\\n\\n                console.log(`sessionToken:  ${AWS.config.credentials.sessionToken}`);\\n                console.log(`secretAccessKey:  ${AWS.config.credentials.secretAccessKey}`);\\n                //refreshes credentials using AWS.CognitoIdentity.getCredentialsForIdentity()\\n                // AWS.config.credentials.refresh(error =\u003e {\\n                //     if (error) {\\n                //         console.error(error);\\n                //     } else {\\n                //         // Instantiate aws sdk service objects now that the credentials have been updated.\\n                //         // example: var s3 = new AWS.S3();\\n                //         console.log('Successfully logged!');\\n                //     }\\n                // });\\n            },\\n\\n            onFailure: function (err) {\\n                console.log(err.message || JSON.stringify(err));\\n            },\\n        });\\n    });\\n}\\n\\nif (process.env['APPNAME_ACCESS_TOKEN'] \u0026\u0026 process.env['APPNAME_REFRESH_TOKEN']) {\\n    cognitoAccessToken = new CognitoAccessToken({ AccessToken: process.env['APPNAME_ACCESS_TOKEN'] });\\n    cognitoRefreshToken = new CognitoRefreshToken({ RefreshToken: process.env['APPNAME_REFRESH_TOKEN'] });\\n    console.log(`Got tokens from env: `, cognitoAccessToken.getJwtToken(), \\\"\\\\nRefresh:\\\", cognitoRefreshToken.getToken());\\n    startHTTPServer();\\n} else {\\n    console.log(`No tokens in ENV getting them via Cognito`);\\n    await emailAuthInit();\\n    const smsCode = await rl.question('What is the SMS Code: ');\\n    await emailAuthCode(smsCode);\\n}\\n\")), mdx(\"p\", null, \"The really tricky part was looking at the HTTPS dumped requests and figuring out what kind of AWS Cogntio requests I needed to make and what strings to pass. But this was all reverse engineerable from the information in the request bodies and by reading the AWS Cognito library source code.\"), mdx(\"p\", null, \"Basically if you find yourself trying to write something similar where you want to recreate an AWS Cognito login flow and see requests that have in the body:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A request with AuthFlow: CUSTOM_AUTH\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Then a request with ChallengeName: PASSWORD_VERIFIER\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Then a request with ChallengeResponses: PASSWORD_CLAIM_SECRET_BLOCK\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Then ChallengeName: CUSTOM_CHALLENGE\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"ChallengeResponses: \\\\\\\"ANSWER\\\\\\\":\\\\\\\"answerType:generateCode,medium:phone,codeType:login\\\\\\\"\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\\\"{\\\\\\\"ChallengeName\\\\\\\":\\\\\\\"CUSTOM_CHALLENGE\\\\\\\",\\\\\\\"ChallengeParameters\\\\\\\":{\\\\\\\"challengeType\\\\\\\":\\\\\\\"code\\\\\\\"}\")), mdx(\"p\", null, \"Then the above code should be hackable to get something working for you.\"), mdx(\"p\", null, \"My auth flow required authorizing via my username and password then doing 2fa using my phone number which was already in their system somehow.\\nBecause I started getting a text with a code after I passed the first part of the Cogntio verification with the email and password.\"), mdx(\"p\", null, \"Hopefully my Cognito client code above is helpful for someone.\"), mdx(\"p\", null, \"I figured out a bunch of other interesting stuff that I think is useful but I'll have to put that into another post.. this post is already a mess of information and is probably hard to follow.\"), mdx(\"p\", null, \"I did figure out how to send fake touch events. So in this case I could script having the app open then wait a second for the app to load and send touch event to the middle of the screen just to hit the lock or unlock button.\"), mdx(\"p\", null, \"The hackiest of hacks but it's really cool sending these fake touch events. I'll write a post about that next.\"), mdx(\"h3\", null, \"Just some lldb notes:\"), mdx(\"p\", null, \"Ever be steppin and you step INTO a jump/function call and just want to get back to where you were?\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"thread step-out\\n\")), mdx(\"p\", null, \"will get you back!\"), mdx(\"p\", null, \"And you can use it to jump over call or bl instructions as well.\"), mdx(\"p\", null, \"So my LLDB flow was mostly:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Search for possible places to set breakpoints with:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"image lookup -r -n .*AWSCognito.*\\n\")), mdx(\"p\", null, \"AWSCognito being something related to whatever you want to learn more about. Maybe its refreshToken or something..\"), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Then I check that list it generates and see how ridiculously long it is. If I am going to be setting to many breakpoints I work that regex down to be more specific and then set breakpoints with:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"br set -r  .*refreshToken.*\\n\")), mdx(\"p\", null, \"Then when I hit a breakpoint I would read all the variables and pointers I could. I would check the backtrace to see whats going on:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"bt\\n\")), mdx(\"p\", null, \"and from there I could select different \\\"frames\\\" or functions called to get to my breakpoint:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"frame select SOMENUMBERHERE\\n\")), mdx(\"p\", null, \"I would check the registers at each frame:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"register read --all\\n\")), mdx(\"p\", null, \"Although they obviously made the most sense down at the frame you break into.\"), mdx(\"p\", null, \"For each frame your in if you want to see the full dissassembly of the current function run:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"di -f\\n\")), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Just start printing out all the info.\")), mdx(\"p\", null, \"LLDB has nice aliases for the registers that contain function call arguments and can be printed out with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"po $arg1\\npo $arg2\\netc...\\n\")), mdx(\"ol\", {\n    \"start\": 4\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Accessing data on objects I found:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"expression -l objc -O -- [$arg1 userPoolConfiguration]\\n\")), mdx(\"ol\", {\n    \"start\": 5\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Creating variables in LLDB:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"expression -l objc -O -- NSURL *$url = [NSURL URLWithString:@\\\"appName://\\\"];\\n\")), mdx(\"p\", null, \"Would create an NSUrl with the lldb variable name $url.\\nThen I could test that my method was in fact swizzed correctly with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"expression -l objc -O -- [[UIApplication sharedApplication].delegate application:[UIApplication sharedApplication] handleOpenURL:$url];\\n\")), mdx(\"p\", null, \"More examples of variables:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"expression id $delegate = (id)[[UIApplication sharedApplication] delegate]\\nexpression id $keyWindow= (id)[$delegate window]\\nexpression id $root = (id)[$keyWindow rootViewController]\\npo $root\\n\")), mdx(\"ol\", {\n    \"start\": 6\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Got a sneaking suspicion some address is really a pointer? Want to see if its an object?\\nCast it as an (id) and po it:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"po (id)0x7facaada2c80\\n\")), mdx(\"ol\", {\n    \"start\": 7\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"IMPORTANT - You can use\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"command script import lldb.macosx.heap\\n\")), mdx(\"p\", null, \"in lldb to get access to some realllllly helpful heap functions. Similar to what Frida provides for searching the heap for objects. Huuuuuuge for me.\"), mdx(\"ol\", {\n    \"start\": 8\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"My .lldbinit file:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"command script import lldb.macosx.heap\\ntype summary add --category swift --summary-string \\\"Unmanaged Contains: ${var._value%@}\\\" Swift.Unmanaged\u003cAnyObject\u003e\\ncommand script import /Users/bbarrows/lldb/load_swift.py\\n# to run lldb \\\"shell\\\" scripts\\ncommand alias shsource command source\\n# to run a shell command, like `open`\\ncommand alias shellcmd platform shell\\n# tell lldb to assume swift, not objc\\nsettings set target.language Swift\\ncommand alias clear-lang settings clear target.language\\ncommand alias swiftui_script load_swift /Users/bbarrows/lldb/helpers.swift\\n#command script import  /Users/bbarrows/repos/MyLLDB/python/sbt.py\\ncommand alias eco expression -l objective-c -O --\\ncommand alias ecs expression -l swift -O --\\ncommand alias br breakpoint\\ncommand alias rr register read\\ncommand alias rra register read\\ncommand regex ims 's/(.+)/image lookup -rn %1/'\\ncommand regex z 's/(.+)/breakpoint set -r %1/'\\ncommand regex mr 's/(.+) (.+)/memory read --size 8 --format x --count %2 %1/'\\ncommand regex pos  's/(.+)/po (const char *)%1/'\\ncommand regex posc  's/(.+)/expression -l swift -O -- unsafeBitCast(0x7f8c7b002b30, to: %1.self)/'\\n\")), mdx(\"h3\", null, \"Useful tools\"), mdx(\"p\", null, \"Best tool I think for dumping headers these days is \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/cxnder/ktool\"\n  }, \"ktool\"), \"\\nReally nice GUI too and handles the MachO sections that are causing the older header dump tools to fail.\"), mdx(\"p\", null, \"I also probably learned the most and got the farthest just using lldb and Frida BUT attaching xCode to your running process and then using the xCode Memory Graph was super helpful to figure out what was related to what and what information I could find. For example, I had some Swift class with private properties or whatever that I couldn't access but I was able to figure out the offset from the object handle and get a reference to its JWT that way.\"), mdx(\"p\", null, \"For me Frida and lldb are the most useful tools other then, in this case, just using a tool like Charles Proxy for dumping the https session. I actually was using another tool called Quantum I think but same idea and I can't remember the name now. Surge 5 also works fine.. But it's pretty buggy and has poort documentation especially if your trying to do stuff like have your mac control it on your phone.\"), mdx(\"h1\", null, \"Summary\"), mdx(\"p\", null, \"I poked around a lot trying a lot of different things. I was hoping to just hook or add and implementation for handling IOS URLSchemes so I could script opening the app and have it lock and unlock the door.\"), mdx(\"p\", null, \"I couldn't find a good way to get a JWT that was always valid. The application will run some Swift code that I wasn't able to track down in a relatively sane amount of time so I gave up on getting the JWT and refresh token from the heap/app.\"), mdx(\"p\", null, \"I ended up looking at the HTTPS requests. Figuring out it was using AWS Cognito. And then re creating my own service that just mimicks whats the lock company does to get me a JWT for their lock control server.\"), mdx(\"p\", null, \"Now I have a service running that I logged into once, it refreshes the JWT every 30 min, and I can send HTTPS requests to it to lock and unlock my door with a Siri/Shortcut I created.\"));\n}\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"\u003ch1\u003eStuck With a Smart Lock That Only Works With Google or Alexa? Let\u0026#x27;s Fix That!\u003c/h1\u003e\u003cp\u003eI should have written this up sooner while it was still fresh in my mind. Apologies for the scattered information, but the AWS Cognito example might be helpful to some. Additionally, the Frida Gadget scripting to add a URL Scheme could be beneficial.\u003c/p\u003e\u003cp\u003eI am going to make another post for how I was able to use a library by \u003ca href=\"https://github.com/lyft/Hammer\"\u003eLyft called Hammer\u003c/a\u003e to send fake UITouch events as well next.. and maybe one on just all the lldb commands I learned and what I thought was really helpful.\u003c/p\u003e\u003ch2\u003eWhy the Obscure Blog Post and Code?\u003c/h2\u003e\u003cp\u003eApologies, but I’ve obscured company names and details. Unfortunately, you won’t be able to directly use this work if you have the same door lock as me, but if you’re smart enough to recognize the same libraries and network requests, you should be able to gather the necessary information and recreate a useful server/tool to control your door as you wish.\u003c/p\u003e\u003ch2\u003eIntroduction - IOS URLScheme and Frida and some lldb\u003c/h2\u003e\u003cp\u003eI moved into a new apartment with a smart lock that has an iOS app, which is convenient. However, it takes a while to load the app and press the button to lock and unlock the door. I really just wanted to be able to tell Siri to do it if my hands were full. Plus, I enjoy exploring iOS.\u003c/p\u003e\u003cp\u003eI’ll try to go through my process in the order I followed (mostly) because I learned a lot along the way, recreating this blog post from my notes.\u003c/p\u003e\u003cp\u003eTo summarize, as someone suggested, the easiest way to achieve this would be to sniff the network traffic and recreate it. But I wanted to learn more about iOS and reverse engineering, so I initially took the harder route.\u003c/p\u003e\u003cp\u003eI started by using software like Charles Proxy to examine the network traffic. What did I find? A straightforward JSON API that uses a JWT token for authentication to lock and unlock the door.\u003c/p\u003e\u003cp\u003eTo demonstrate how easy it initially seemed to use this API, here’s a cURL command showing me using the API to lock the door:\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ecurl -X PATCH \u0026quot;https://$SOMECOMPANYID.execute-api.us-east-1.amazonaws.com/prod_v1/devices/$PROBMYDEVICEID/status\u0026quot; -H \u0026quot;User-Agent: AppName/5 CFNetwork/1404.0.5 Darwin/22.3.0\u0026quot; -H \u0026quot;Content-Type: application/json\u0026quot; -H \u0026quot;Accept: application/json\u0026quot; -H \u0026quot;Accept-Language: en-US,en;q=0.9\u0026quot; -H \u0026quot;Authorization: Bearer $KBEARER\u0026quot; -H \u0026quot;Accept-Encoding: gzip, deflate, br\u0026quot; -d \u0026quot;{\\\u0026quot;action\\\u0026quot;: \\\u0026quot;lock\\\u0026quot;, \\\u0026quot;source\\\u0026quot;: \\\u0026quot;{\\\\\\\u0026quot;name\\\\\\\u0026quot;:\\\\\\\u0026quot;$MYNAME\\\\\\\u0026quot;,\\\\\\\u0026quot;device\\\\\\\u0026quot;:\\\\\\\u0026quot;iPhone\\\\\\\u0026quot;}\\\u0026quot;}\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo all I need to do is send the JSON below to some URL with an AUTH token basically.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e{\u0026quot;action\u0026quot;: \u0026quot;lock\u0026quot;, \u0026quot;source\u0026quot;: \u0026quot;{\\\u0026quot;name\\\u0026quot;:\\\u0026quot;Brad\\\u0026quot;,\\\u0026quot;device\\\u0026quot;:\\\u0026quot;iPhone\\\u0026quot;}\u0026quot;}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs I continued to examine the intercepted HTTPS traffic, I saw that there were multiple requests before this one, and one of them contained the AUTH token. I realized there was a process happening to obtain the JWT, which looked a bit complicated.\u003c/p\u003e\u003cp\u003eAt first, I hoped I could just find some object in the heap that contained the AUTH token and use that via Frida (and its amazing API with functionality like pulling all objects of any type from memory!). However, none of the AUTH tokens I found were working.\u003c/p\u003e\u003cp\u003eI should also mention that my original plan was to add an iOS URL Scheme to the application so I could create a Siri Shortcut that would open a URL to lock and unlock my door.\u003c/p\u003e\u003cp\u003eI tried several things, such as creating iOS tweaks, making a custom dylib in Xcode, and manually adding it to the main executable using install_name_tool, then swizzling it to add new functionality.\u003c/p\u003e\u003cp\u003eFor those who may need an explanation: a dylib is a dynamically linked library, meaning it’s a binary that the operating system (or more specifically, dyld) loads into memory when an application starts.\u003c/p\u003e\u003cp\u003eSo, I needed a decrypted copy of the application I was going to modify/debug/etc. Some websites surprisingly provide this service, but I found my old iPhone 6s and was able to use Checkra1n and Palera1n on an iPhone 7 to get them jailbroken. At this point, what worked best for me was frida-ios-dump.\u003c/p\u003e\u003cp\u003eInstead of installing usbmuxd/iproxy, if you’re on the same network, you can just use the IP address:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e./dump.py -H 192.168.1.87 -p 22 AppName\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNOTE: From here on out, I’ll refer to the iOS app as AppName.\u003c/p\u003e\u003cp\u003eAfter running this dump, you should end up with an unencrypted “.ipa” file in the same folder. An ipa file type is a zip file that contains the application and all its data/metadata.\u003c/p\u003e\u003cp\u003eYou can change the extension from .ipa to .zip and unzip it right there.\u003c/p\u003e\u003cp\u003eInside, you’ll find a folder named Payload, and inside that, there will be AppName.App.\u003c/p\u003e\u003cp\u003eJust like a .App on macOS, you can right-click and show package contents to see what the app really contains.\u003c/p\u003e\u003cp\u003eThe most important file will be the binary itself, which is normally also named AppName (with no file extension) and will be an arm64 binary built for iOS.\u003c/p\u003e\u003cp\u003eThere is also a Frameworks folder that will contain a number of frameworks, which are essentially dylibs with additional information, like header files, that the binary loads at runtime.\u003c/p\u003e\u003cp\u003eAny executable will have a list of dynamically linked libraries it loads at runtime. You can list those with:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eotool -L $EXE_NAME_HERE\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eor to get a more detailed breakdown that includes information such as the path where the binary will look for the dylibs:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eotool -l $EXE_NAME_HERE\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt’s important to use the lowercase -l option so you can see where rpath points in some cases. In most cases, it will just be the Frameworks directory.\u003c/p\u003e\u003cp\u003eSo, if you’re going to add your own dylib, you could, for example, use a tool like insert_dylib.\u003c/p\u003e\u003cp\u003eFor example, I built my own dylib, which initially attempted to swizzle the older handleURL methods on the iOS AppDelegate (this no longer works, by the way).\u003c/p\u003e\u003cp\u003eTo insert your dylib, you would do something like:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003einsert_dylib --strip-codesig --inplace \u0026#x27;@executable_path/Frameworks/libhandleURLSwizzleObjC.dylib\u0026#x27; ~/Payload/AppName.app/AppName\ncp ~/libhandleURLSwizzleObjC.dylib ~/Payload/AppName.app/Frameworks\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn your dylib code (you can create a dylib in Xcode by creating a static library and then changing the library type to dynamic in build options; you may also want to change the extension from .a to .dylib), you will want to add a constructor function.\u003c/p\u003e\u003cp\u003eThis function is called when the dylib is loaded into memory, and it’s your chance to “swizzle” or replace existing functions with your own, allowing you to add or modify existing functionality in an application.\u003c/p\u003e\u003cp\u003eThese days, you can use a tool called objection to handle signing everything and converting your Payload folder into an ipa for you.\u003c/p\u003e\u003cp\u003eThen, you can use another tool, ios-deploy, to send the app to your iPhone, whether jailbroken or not, and start a debugging session with LLDB. Objection by default injects Frida, so you can connect to Frida and poke around as well!\u003c/p\u003e\u003cp\u003eIt’s all very user-friendly and pretty easy to get started with.\u003c/p\u003e\u003ch2\u003eGetting IOS URLScheme to Work\u003c/h2\u003e\u003cp\u003eEven though I didn’t end up going this route, I finally figured out a cool way to make it work and wanted to document it. With the newer iOS SDKs and SwiftUI, the older handleURL method on AppDelegate is no longer called (I believe) with a URL Scheme.\u003c/p\u003e\u003cp\u003eFirst off, I needed to update my iOS app’s plist file so it would handle URLs like AppName://unlockdoor.\u003c/p\u003e\u003cp\u003eTo do so, I scripted:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ehead -n4 ~/Payload/AppName.app/Info.plist \u0026gt; ~/Payload/AppName.app/Info.plist-2\necho \u0026quot;\u0026quot;\u0026quot;    \u0026lt;key\u0026gt;CFBundleURLTypes\u0026lt;/key\u0026gt;\n    \u0026lt;array\u0026gt;\n        \u0026lt;dict\u0026gt;\n            \u0026lt;key\u0026gt;CFBundleURLSchemes\u0026lt;/key\u0026gt;\n            \u0026lt;array\u0026gt;\n                \u0026lt;string\u0026gt;AppName\u0026lt;/string\u0026gt;\n            \u0026lt;/array\u0026gt;\n            \u0026lt;key\u0026gt;CFBundleURLName\u0026lt;/key\u0026gt;\n            \u0026lt;string\u0026gt;com.AppName.ble-wifi\u0026lt;/string\u0026gt;\n        \u0026lt;/dict\u0026gt;\n    \u0026lt;/array\u0026gt;\u0026quot;\u0026quot;\u0026quot; \u0026gt;\u0026gt; ~/Payload/AppName.app/Info.plist-2\ntail -n+5 ~/Payload/AppName.app/Info.plist \u0026gt;\u0026gt; ~/Payload/AppName.app/Info.plist-2\nmv ~/Payload/AppName.app/Info.plist-2 ~/Payload/AppName.app/Info.plist\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe important part is that the CFBundleURLSchemes contains the string for the url proto if I remember right and then the CFBundleURLName has to have the same Bundle of the App.\nThere is a lot of documentation on this part too so I won\u0026#x27;t go into too much detail here.\u003c/p\u003e\u003cp\u003eWhat I think is really cool is that the Frida Gadget, the Frida dylib, that is injected into the App will look for a script to run. So you can create apps with Frida injected and a script included in the Payload/App folder so that you don\u0026#x27;t need to write a dylib in objective-c or something and can create deployable packagable apps using Frida for tweaks! Pretty amazing.\u003c/p\u003e\u003cp\u003eThe documentation for \u003ca href=\"https://frida.re/docs/gadget/\"\u003eFrida Gadgets is here\u003c/a\u003e. Definately check that out. It\u0026#x27;s a great feature I never knew about.\u003c/p\u003e\u003cp\u003eSo along with using this feature or Frida I ended up figuring out which method I needed to implement to handle IOS URLSchemes with ios 15.7.2 and probably later.\u003c/p\u003e\u003cp\u003eYou have to find the UIWindowScene and add a method \u0026quot;- scene:openURLContexts:\u0026quot;. This is actually what is trigger with IOS URLSchemes on these newer iOS versions.\u003c/p\u003e\u003cp\u003eI have a super hacky way of finding the UIWindowScene.. and I don\u0026#x27;t know why I didn\u0026#x27;t just use ObjC.choose or something.. But this is my Frida Gagdet script:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003erpc.exports = {\n    init(stage, parameters) {\n        console.error(\u0026#x27;[init]\u0026#x27;, stage, JSON.stringify(parameters));\n\n        var globalar = null;\n\n        var NSLog = new NativeFunction(Module.findExportByName(\u0026#x27;Foundation\u0026#x27;, \u0026#x27;NSLog\u0026#x27;), \u0026#x27;void\u0026#x27;, [\u0026#x27;pointer\u0026#x27;, \u0026#x27;...\u0026#x27;]);\n        var NSString = ObjC.classes.NSString;\n        var str = NSString.stringWithFormat_(\u0026quot;[*] BRAD IN FRIDA GADGET\u0026quot;);\n        NSLog(str);\n        console.error(\u0026quot;[*] BRAD IN FRIDA GADGET\u0026quot;);\n\n\n        var NSJSONSerialization = ObjC.classes.NSJSONSerialization;\n        var NSUTF8StringEncoding = 4;\n\n        var NSURL = ObjC.classes.NSURL;\n        // var NSError = ObjC.classes.NSError;\n\n        function convertNSObjectToJSString(obj) {\n            var valid = NSJSONSerialization.isValidJSONObject_(obj);\n            if (!valid) return null;\n            const NSJSONWritingPrettyPrinted = 1;\n            var errorPtr = Memory.alloc(Process.pointerSize);\n            Memory.writePointer(errorPtr, NULL); // initialize to NULL\n            var data = NSJSONSerialization.dataWithJSONObject_options_error_(obj, NSJSONWritingPrettyPrinted, errorPtr);\n            var error = Memory.readPointer(errorPtr);\n            if (error.isNull()) {\n                var str = NSString.alloc().initWithData_encoding_(data, NSUTF8StringEncoding);\n                return str.toString();\n            } else {\n                var errorObj = new ObjC.Object(error); // now you can treat errorObj as an NSError instance\n                console.error(errorObj.toString());\n                return null;\n            }\n        }\n\n\n        function getCurrentJWT() {\n            var awsMobileClientPtr = Number(ObjC.chooseSync(ObjC.classes[\u0026quot;AWSMobileClient.AWSMobileClient\u0026quot;])[0].handle);\n            var awsMobileClientDictPtrStr = Number(awsMobileClientPtr + 0x0000000000000088).toString(16);\n            var awsMobileClientDictPtr = new NativePointer(\u0026quot;0x\u0026quot; + awsMobileClientDictPtrStr);\n            var dictPtr = awsMobileClientDictPtr.readPointer()\n            var dictObj = new ObjC.Object(dictPtr);\n            var dstr = dictObj.toString();\n            console.error(\u0026quot;String argument: \u0026quot; + dstr);\n            var regex = /.*(\u0026quot;eyJ.*\u0026quot;).*/;\n            var jwt = JSON.parse(dstr.match(regex)[1]);\n            return jwt;\n        }\n\n        function lockUnlockDoor(action) {\n            var jwt = getCurrentJWT();\n            console.error(\u0026quot;Got JWT: \u0026quot; + jwt);\n\n            var actionParsed = (action == \u0026quot;lock\u0026quot; || action == \u0026quot;unlock\u0026quot;) ? action : \u0026quot;lock\u0026quot;;\n            var url = \u0026quot;https://SOMECOMPANYID.execute-api.us-east-1.amazonaws.com/prod_v1/devices/PROBMYDEVICEID/status\u0026quot;;\n            var nsurl = NSURL.alloc().initWithString_(url);\n            var urlRequest = ObjC.classes.NSMutableURLRequest.alloc().initWithURL_(nsurl);\n\n            var actString = \u0026quot;{\\\u0026quot;action\\\u0026quot;: \\\u0026quot;\u0026quot; + actionParsed + \u0026quot;\\\u0026quot;, \\\u0026quot;source\\\u0026quot;: \\\u0026quot;{\\\\\\\u0026quot;name\\\\\\\u0026quot;:\\\\\\\u0026quot;Brad\\\\\\\u0026quot;,\\\\\\\u0026quot;device\\\\\\\u0026quot;:\\\\\\\u0026quot;iPhone\\\\\\\u0026quot;}\\\u0026quot;}\u0026quot;;\n            console.error(`\\n\\nBEB - actString: ${actString} ${actString.length}\\n\\n`);\n            var userUpdate = NSString.stringWithFormat_(actString);\n            console.error(`\\n\\nBEB - userUpdate: ${userUpdate.toString()} ${userUpdate.length()}\\n\\n`);\n\n            urlRequest.setHTTPMethod_(\u0026quot;PATCH\u0026quot;);\n            urlRequest.setValue_forHTTPHeaderField_(\u0026quot;Bearer \u0026quot; + jwt, \u0026quot;Authorization\u0026quot;);\n            urlRequest.setValue_forHTTPHeaderField_(`${actString.length}`, \u0026quot;Content-Length\u0026quot;);\n            urlRequest.setValue_forHTTPHeaderField_(\u0026quot;application/json\u0026quot;, \u0026quot;Content-Type\u0026quot;);\n            urlRequest.setValue_forHTTPHeaderField_(\u0026quot;application/json\u0026quot;, \u0026quot;Accept\u0026quot;);\n            urlRequest.setValue_forHTTPHeaderField_(\u0026quot;en-US,en;q=0.9\u0026quot;, \u0026quot;Accept-Language\u0026quot;);\n            urlRequest.setValue_forHTTPHeaderField_(\u0026quot;gzip, deflate, br\u0026quot;, \u0026quot;Accept-Encoding\u0026quot;);\n            urlRequest.setValue_forHTTPHeaderField_(\u0026quot;appName/5 CFNetwork/1404.0.5 Darwin/22.3.0\u0026quot;, \u0026quot;User-Agent\u0026quot;);\n            urlRequest.setValue_forHTTPHeaderField_(\u0026quot;keep-alive\u0026quot;, \u0026quot;Connection\u0026quot;);\n\n            var data1 = userUpdate.dataUsingEncoding_(NSUTF8StringEncoding);\n\n            urlRequest.setHTTPBody_(data1);\n\n            var session = ObjC.classes.NSURLSession.sharedSession();\n\n            console.error(\u0026quot;Setup request and is about to make it\u0026quot;);\n            var dataTask = session.dataTaskWithRequest_completionHandler_(urlRequest, new ObjC.Block({\n                retType: \u0026#x27;void\u0026#x27;,\n                argTypes: [\u0026#x27;pointer\u0026#x27;, \u0026#x27;pointer\u0026#x27;, \u0026#x27;pointer\u0026#x27;],\n                implementation: function (data, response, error) {\n                    var dataStr = NSString.alloc().initWithData_encoding_(data, NSUTF8StringEncoding);\n                    var respObj = new ObjC.Object(response);\n                    var errorObj = new ObjC.Object(error);\n                    console.error(\u0026quot;data: \u0026quot;, dataStr);\n                    console.error(\u0026quot;response code: \u0026quot;, respObj.statusCode());\n                    console.error(\u0026quot;error: \u0026quot;, errorObj.toString());\n\n                    // var respObj = new ObjC.Object(response);\n                    // console.error(\u0026quot;data as JSON string: \u0026quot;, convertNSObjectToJSString(data));\n\n                }\n            }));\n            dataTask.resume();\n        }\n\n\n        function setIntercept() {\n            var scenes = ObjC.classes.UIApplication.sharedApplication().connectedScenes();\n\n            var winSceneRegex = /UIWindowScene: (0x[a-fA-F0-9]+)/\n            var scenesPtr = ptr(scenes.toString().match(winSceneRegex)[1]);\n            var windowScene = ObjC.Object(scenesPtr);\n            try {\n                if (!scenes) {\n                    console.error(\u0026quot;Couldn\u0026#x27;t file UIWindowScene on sharedApplication\u0026quot;);\n                } else {\n                    Interceptor.attach(windowScene.delegate()[\u0026quot;- scene:openURLContexts:\u0026quot;].implementation, {\n                        onEnter(args) {\n                            // ObjC: args[0] = self, args[1] = selector, args[2-n] = arguments\n                            const arg2Str = new ObjC.Object(args[2]);\n                            console.error(\u0026quot;String argument: \u0026quot; + arg2Str.toString());\n                            NSLog(NSString.stringWithFormat_(\u0026quot;[*] BRAD scene:openURLContexts: argument 2: \u0026quot; + arg2Str.toString()));\n\n                            const arg3Str = new ObjC.Object(args[3]);\n                            console.error(\u0026quot;String argument: \u0026quot; + arg3Str.toString());\n                            NSLog(NSString.stringWithFormat_(\u0026quot;[*] BRAD scene:openURLContexts: argument 3: \u0026quot; + arg3Str.toString()));\n\n                            globalar = arg3Str;\n                            var appNameActionFromURLRegex = /URL: appName:\\/\\/(\\S+)/; ///.*URL: appName: \\/\\/([a-z]*);.*/;\n                            console.error(arg3Str.toString().match(appNameActionFromURLRegex));\n                            var action = arg3Str.toString().match(appNameActionFromURLRegex)[1];\n\n                            lockUnlockDoor(action);\n                        }\n                    });\n                    console.error(\u0026quot;[*]WindowScene() intercept placed\u0026quot;);\n                    NSLog(NSString.stringWithFormat_(\u0026quot;[*]WindowScene() intercept placed\u0026quot;));\n                }\n            }\n            catch (err) {\n                console.error(\u0026quot;[*]BRAD Exception: \u0026quot; + err.message);\n                NSLog(NSString.stringWithFormat_(\u0026quot;[*]BRAD Exception: \u0026quot; + err.message));\n            }\n        }\n\n        setTimeout(setIntercept, 1000); // IDK why I wanted to wait to add this method. I was thinking maybe it could take a while for the UIWindowScene to get created\n        console.error(\u0026quot;[*]BRAD SETTIMEOUT\u0026quot;);\n        NSLog(NSString.stringWithFormat_(\u0026quot;[*]BRAD SETTIMEOUT\u0026quot;));\n\n\n    },\n    dispose() {\n        console.error(\u0026#x27;[dispose]\u0026#x27;);\n    }\n};\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI save this as appName.js in the Frameworks folder.\u003c/p\u003e\u003cp\u003eIn the Frameworks folder I ALSO create the Frida Gadget config to run the script. It is a file named: FridaGadget.config\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e{\n  \u0026quot;interaction\u0026quot;: {\n    \u0026quot;type\u0026quot;: \u0026quot;script\u0026quot;,\n    \u0026quot;path\u0026quot;: \u0026quot;appName.js\u0026quot;,\n    \u0026quot;on_change\u0026quot;: \u0026quot;reload\u0026quot;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI figure this code could be useful if someone wants to try something similar.\u003c/p\u003e\u003cp\u003eNOTE: That if you are trying to get the JWT from AWS like I was in the code above. It probably won\u0026#x27;t work often unless the app refreshes it\u0026#x27;s token often.\u003c/p\u003e\u003cp\u003eThe app I was using DIDNT. So this route didn\u0026#x27;t work. And triggering the app to run its refresh token code was taking forever to figure out.\u003c/p\u003e\u003cp\u003eSo now back to actually getting something working.\u003c/p\u003e\u003ch2\u003eAWS Cognito Reverse engineering\u003c/h2\u003e\u003cp\u003eSo this app actually uses an AWS service called Cognito that handles the all the auth. The 2FA and JWT related work is all handled by Cognito.\u003c/p\u003e\u003cp\u003eThe documentation for AWS Cognito was IMO actually pretty bad. Especially when it came to less conventional uses like the way I could tell this iOS application was using it.\u003c/p\u003e\u003cp\u003eI couldn\u0026#x27;t even find any working examples of using AWS Cognito as a client and I thought this might be helpful for someone trying to do something similar. My code maybe messy but it works and I have invested too much time in it as it is so I am calling it good. You\u0026#x27;re gonna have to deal with the mess the code and thig post is until I get a lot of time on my hands.\u003c/p\u003e\u003cp\u003eSo first off. I used Frida to poke around. And I see that AWS and something called AWS Cognito is being used from the loaded Frameworks. I findout that Cognito is used for auth. Also I saw in the decoded JWT via \u003ca href=\"https://jwt.io/\"\u003ehttps://jwt.io/\u003c/a\u003e that scope of the jwt is \u0026quot;aws.cognito.signin.user.admin\u0026quot;. So I know now that this app is using Cognito for auth.\u003c/p\u003e\u003cp\u003eThen I think I was just using Frida\u0026#x27;s ObjC.chooseSync and grabbing objects and I found some useful information. I also was using lldb and found some information I needed later for basically re creating the AWS Cognito login flow.\u003c/p\u003e\u003cp\u003eSo when I run the iod-deploy I used the configuration that automatically starts the app and gives you an lldb session.\u003c/p\u003e\u003cp\u003eI think I started by looking at what I could break on that was AWSCognito related with the command:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eimage lookup -r -n .*AWSCognito.*\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis uses regex to search for anything AWSCognito related. Any methods on the classes that have the string AWSCognito will be listed.\u003c/p\u003e\u003cp\u003eI think I realized by looking at other AWS Cognito client implementations that didn\u0026#x27;t work that I needed to get a few bits of information.\u003c/p\u003e\u003cp\u003eSo I set breakpoints in lldb (using Frida again would have probably been easier but I am just documenting stuff I learned here)\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ebreakpoint set -r \u0026#x27;\\[AWSCognitoIdentityUserPoolConfiguration .*\\]$\nbreakpoint set -r \u0026#x27;\\[AWSCognitoIdentityUserPool .*\\]$\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI am pretty sure I hit the following breakpoint:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\n  Summary: AWSAppSync`AWSAppSync.AWSCognitoUserPoolsAuthProviderAsync.getLatestAuthToken() -\u0026gt; Swift.String        Address: AWSAppSync[0x0000000000027200] (AWSAppSync.__TEXT.__text + 131900)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd then I started printing out arguments to this method call:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\npo (SEL)$arg2\n\npo $arg1\n\nexpression -l objc -O -- [$arg1 userPoolConfiguration]\n\nexpression -l objc -O -- [[$arg1 userPoolConfiguration] poolId]\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe last one of these got me the poolId for AWSCognito account I needed to login with to get a JWT and refresh token so I could send lock and unlock commands.\u003c/p\u003e\u003cp\u003eNOTE: That the poolId will probably be in a format like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eus-east-1_6B31234KN\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen I also needed something called the clientID. This can actually be found in the requests from the HTTPS requests I dumped to JSON.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eIronically\u003c/strong\u003e I found just MITM this whole thing to be the easiest way to reverse engineer everything. But I wanted to practice my lldb/debugger skills anyway so I spent plenty of time trying to force that route.\u003c/p\u003e\u003cp\u003eI also needed to find this information which I got with Frida:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003evar awsccp = [];\nObjC.choose(ObjC.classes[\u0026#x27;AWSCognitoCredentialsProvider\u0026#x27;], {\n  onMatch: function (serv) {\n    console.log(\u0026#x27;Found AWSCognitoCredentialsProvider\u0026#x27;, serv);\n    awsccp.push(serv);\n  },\n  onComplete: function () {\n    console.log(\u0026#x27;Finished AWSCognitoCredentialsProvider search\u0026#x27;);\n  }\n});\n\nconsole.log(awsccp);\n\n\nconsole.log(awsccp.getIdentityId())\n\u0026lt;AWSTask: 0x2867bf380; completed = YES; cancelled = NO; faulted = NO; result = us-east-1:47021234-ffff-4fff-afff-ffffbca71a1c\u0026gt;\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd then I had enough info to basically re create the server that the iPhone app used to send my login credentials to which would talk with AWS Cognito and get a JWT and refresh token. I wanted to have my own so that I could get a JWT whenever I want. And I found out that I can just basically refresh my JWT forever so I really just need to get that JWT and I refresh every 30 minutes I beleive it was. The code is below:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003econst fullUserPoolId = \u0026#x27;us-east-1_5F3ufo6uFF\u0026#x27;\nconst userPoolId = \u0026#x27;5F3ufo6uFF\u0026#x27;\nconst ClientId = \u0026#x27;ffuabckjpfffd1ab7881m6g88s\u0026#x27;\nconst username = \u0026quot;myemail@gmail.com\u0026quot;;\nconst password = \u0026quot;MyPassword\u0026quot;;\n\nimport * as AWS from \u0026#x27;aws-sdk\u0026#x27;;\nimport AmazonCognitoIdentity, { CognitoRefreshToken, CognitoAccessToken } from \u0026#x27;amazon-cognito-identity-js\u0026#x27;;\n\nimport * as readline from \u0026#x27;node:readline/promises\u0026#x27;;\nimport { stdin as input, stdout as output } from \u0026#x27;node:process\u0026#x27;;\n\nimport * as http from \u0026#x27;http\u0026#x27;;\nimport * as url from \u0026#x27;url\u0026#x27;;\n\n\n\nconst rl = readline.createInterface({ input, output });\n\n\n// // import type { ICognitoUserData } from \u0026#x27;amazon-cognito-identity-js\u0026#x27;;\n\n// const cognitoUserPool = ;\n\n// const cognitoUserData /*: ICognitoUserData*/ = {\n//     Username: username,\n//     Pool: cognitoUserPool,\n//     Storage: undefined // ICognitoStorage ?\n// }\n\nvar cognitoRefreshToken = null;\nvar cognitoAccessToken = null;\n\nvar authenticationData = {\n    Username: username,\n    Password: password,\n};\nvar authenticationDetails = new AmazonCognitoIdentity.AuthenticationDetails(\n    authenticationData\n);\nvar poolData = {\n    UserPoolId: fullUserPoolId, // Your user pool id here\n    ClientId: ClientId, // Your client id here\n};\nvar userPool = new AmazonCognitoIdentity.CognitoUserPool(poolData);\nvar userData = {\n    Username: username,\n    Pool: userPool,\n};\nvar cognitoUser = new AmazonCognitoIdentity.CognitoUser(userData);\n\ncognitoUser.setAuthenticationFlowType(\u0026#x27;CUSTOM_AUTH\u0026#x27;);\n\n\n\nfunction refreshToken() {\n    const refreshFromGlobal = (cognitoRefreshToken || process.env.APPNAME_REFRESH_TOKEN);\n    console.log(\u0026quot;Refreshing tokens. What I have globally and in env is:\u0026quot;, refreshFromGlobal)\n    if (refreshFromGlobal) {\n        cognitoUser.refreshSession(cognitoRefreshToken || new CognitoRefreshToken({ RefreshToken: process.env.APPNAME_REFRESH_TOKEN }), (err, session) =\u0026gt; {\n            if (err) {\n                console.error(\u0026quot;Error refreshing tokens\u0026quot;, err)\n            } else {\n                console.log(\u0026quot;Refreshed tokens\u0026quot;, session)\n                // SO LAME, now accessToken and refreshToken are lower case to start..\n                const { accessToken, refreshToken } = session;\n                if (refreshToken) {\n                    cognitoRefreshToken = refreshToken;\n                } else {\n                    console.log(\u0026quot;No refresh token after refresh\u0026quot;);\n                }\n                if (accessToken) {\n                    cognitoAccessToken = accessToken;\n                } else {\n                    console.log(\u0026quot;No access token after refresh\u0026quot;);\n                }\n            }\n        })\n    } else {\n        console.error(\u0026quot;No refresh token to refresh\u0026quot;, refreshFromGlobal)\n    }\n}\n\nfunction startHTTPServer() {\n\n    setInterval(() =\u0026gt; {\n        refreshToken();\n    }, 1000 * 60 * 30)\n\n    console.log(`Starting HTTP Server`)\n    // Configure our HTTP server to respond with Hello World to all requests.\n    var server = http.createServer(function (request, response) {\n        console.log(`HTTP handling request: ${request}\\n\\n\\n\\nWith response: ${response}`)\n        //    var name=request.getParameter(\u0026#x27;name\u0026#x27;);\n        //    console.log(name);\n        const action = url.parse(request.url, true).query[\u0026#x27;action\u0026#x27;];\n        if (action) {\n            const actionParsed = (action == \u0026#x27;lock\u0026#x27; || action == \u0026#x27;unlock\u0026#x27;) ? action : \u0026#x27;lock\u0026#x27;;\n            sendLockUnlockRequest(actionParsed).then((res) =\u0026gt; {\n                response.writeHead(200, { \u0026quot;Content-Type\u0026quot;: \u0026quot;text/plain\u0026quot; });\n                response.end(`Handling action for ${actionParsed}. Response: ${JSON.stringify(res)}\\n`);\n            })\n        } else {\n            response.writeHead(500, { \u0026quot;Content-Type\u0026quot;: \u0026quot;text/plain\u0026quot; });\n            response.end(`Invalid request\\n`);\n        }\n    });\n    // Listen on port 8000, IP defaults to 127.0.0.1\n    server.listen(8000);\n}\n\n\nasync function sendLockUnlockRequest(action) {\n    if (action != \u0026#x27;lock\u0026#x27; \u0026amp;\u0026amp; action != \u0026#x27;unlock\u0026#x27;) {\n        console.error(`Invalid action: ${action} sent to sendLockUnlockRequest`);\n        return\n    }\n\n    console.log(\u0026quot;Makeing request with:\u0026quot;, {\n        method: \u0026quot;PATCH\u0026quot;, // *GET, POST, PUT, DELETE, etc.\n        headers: {\n            \u0026#x27;Accept\u0026#x27;: \u0026#x27;application/json\u0026#x27;,\n            \u0026#x27;Accept-Language\u0026#x27;: \u0026#x27;en-US,en;q=0.9\u0026#x27;,\n            \u0026#x27;Authorization\u0026#x27;: `Bearer ${cognitoAccessToken.getJwtToken()}`,\n            \u0026#x27;Accept-Encoding\u0026#x27;: \u0026#x27;gzip, deflate, br\u0026#x27;\n        },\n        body: \u0026quot;{\\\u0026quot;action\\\u0026quot;: \\\u0026quot;\u0026quot; + action + \u0026quot;\\\u0026quot;, \\\u0026quot;source\\\u0026quot;: \\\u0026quot;{\\\\\\\u0026quot;name\\\\\\\u0026quot;:\\\\\\\u0026quot;Brad\\\\\\\u0026quot;,\\\\\\\u0026quot;device\\\\\\\u0026quot;:\\\\\\\u0026quot;iPhone\\\\\\\u0026quot;}\\\u0026quot;}\u0026quot;\n    });\n    console.log(\u0026quot;body: \u0026quot;, \u0026quot;{\\\u0026quot;action\\\u0026quot;: \\\u0026quot;\u0026quot; + action + \u0026quot;\\\u0026quot;, \\\u0026quot;source\\\u0026quot;: \\\u0026quot;{\\\\\\\u0026quot;name\\\\\\\u0026quot;:\\\\\\\u0026quot;Brad\\\\\\\u0026quot;,\\\\\\\u0026quot;device\\\\\\\u0026quot;:\\\\\\\u0026quot;iPhone\\\\\\\u0026quot;}\\\u0026quot;}\u0026quot;)\n    const response = await fetch(\u0026#x27;https://COMPANYID.execute-api.us-east-1.amazonaws.com/prod_v1/devices/PROBMYDEVICEID/status\u0026#x27;, {\n        method: \u0026quot;PATCH\u0026quot;, // *GET, POST, PUT, DELETE, etc.\n        headers: {\n            \u0026#x27;Accept\u0026#x27;: \u0026#x27;application/json\u0026#x27;,\n            \u0026#x27;Accept-Language\u0026#x27;: \u0026#x27;en-US,en;q=0.9\u0026#x27;,\n            \u0026#x27;Authorization\u0026#x27;: `Bearer ${cognitoAccessToken.getJwtToken()}`,\n            \u0026#x27;Accept-Encoding\u0026#x27;: \u0026#x27;gzip, deflate, br\u0026#x27;\n        },\n        body: `{\u0026quot;action\u0026quot;: \u0026quot;${action}\u0026quot;, \u0026quot;source\u0026quot;: \u0026quot;{\\\\\u0026quot;name\\\\\\\u0026quot;:\\\\\\\u0026quot;Bradley\\\\\\\u0026quot;,\\\\\\\u0026quot;device\\\\\\\u0026quot;:\\\\\\\u0026quot;iPhone\\\\\\\u0026quot;}\u0026quot;}`\n    });\n    const responseFromAppName = await response.json();\n    console.log(\u0026quot;response from lock/unlock:\u0026quot;, responseFromAppName);\n    return responseFromAppName;\n}\n\nasync function emailAuthCode(smsCode) {\n    return new Promise((resolve, reject) =\u0026gt; {\n        cognitoUser.sendCustomChallengeAnswer(\u0026#x27;answerType:verifyCode,medium:phone,codeType:login,code:\u0026#x27; + smsCode, {\n            mfaRequired: function (result) {\n                console.log(\u0026quot;result from mfaRequired 2:\u0026quot;, result);\n            },\n            selectMFAType: function (result) {\n                console.log(\u0026quot;result from selectMFAType 2:\u0026quot;, result);\n            },\n            mfaSetup: function (result) {\n                console.log(\u0026quot;result from mfaSetup 2:\u0026quot;, result);\n            },\n            totpRequired: function (result) {\n                console.log(\u0026quot;result from totpRequired 2:\u0026quot;, result);\n            },\n            newPasswordRequired: function (result) {\n                console.log(\u0026quot;result from newPasswordRequired 2:\u0026quot;, result);\n            },\n            associateSecretCode: function (result) {\n                console.log(\u0026quot;result from associateSecretCode 2:\u0026quot;, result);\n            },\n            inputVerificationCode: function (result) {\n                console.log(\u0026quot;result from inputVerificationCode 2:\u0026quot;, result);\n            },\n            associateSecretCode: function (result) {\n                console.log(\u0026quot;result from associateSecretCode 2:\u0026quot;, result);\n            },\n            onSuccess: function (cognitoUserSession) {\n                console.log(\u0026quot;result from sending Custom Answer 2:\u0026quot;, cognitoUserSession);\n                cognitoAccessToken = cognitoUserSession.getAccessToken();\n                cognitoRefreshToken = cognitoUserSession.getRefreshToken();\n                console.log(\u0026#x27;Got tokens: \u0026#x27;, cognitoUserSession);\n                startHTTPServer();\n                // TODO: Send curl to open door form here with\n            },\n            onFailure: function (err) {\n                console.log(\u0026quot;err:\u0026quot;, err)\n            },\n            customChallenge: function (challengeParameters) {\n                // TODO: From here do I initAuth again for PASSWORD_VERIFIER\n                console.log(\u0026quot;challengeParameters from sending Custom Answer 2:\u0026quot;, challengeParameters)\n            }\n        });\n    })\n}\n\nasync function emailAuthInit() {\n    return new Promise((resolve, reject) =\u0026gt; {\n        cognitoUser.authenticateUser(authenticationDetails, {\n\n            customChallenge: function (challengeParameters) {\n                console.log(\u0026quot;challengeParameters:\u0026quot;, challengeParameters)\n                cognitoUser.sendCustomChallengeAnswer(\u0026#x27;answerType:generateCode,medium:phone,codeType:login\u0026#x27;, {\n                    onSuccess: function (result) {\n                        console.log(\u0026quot;result from sending Custom Answer 1:\u0026quot;, result)\n                    },\n                    onFailure: function (err) {\n                        console.log(\u0026quot;err:\u0026quot;, err)\n                    },\n                    customChallenge: function (challengeParameters) {\n                        console.log(\u0026quot;challengeParameters from sending Custom Answer:\u0026quot;, challengeParameters)\n                        resolve(challengeParameters);\n                        // TODO This code I think comes from SMS!\n\n\n                    }\n                });\n\n            },\n\n            onSuccess: function (result) {\n                var accessToken = result.getAccessToken().getJwtToken();\n\n                console.log(`\\naccessToken from cogintoUser authenticateUser: ${accessToken}\\n`);\n\n                //POTENTIAL: Region needs to be set if not already set previously elsewhere.\n                AWS.config.region = \u0026#x27;us-east-1\u0026#x27;;\n                const k = `cognito-idp.\u0026lt;region\u0026gt;.amazonaws.com/${userPoolId}`;\n                AWS.config.credentials = new AWS.CognitoIdentityCredentials({\n                    IdentityId: \u0026#x27;us-east-1:ffff0a60-ffff-4fff-fffc-ffffbca71ffc\u0026#x27;, // your identity pool id here\n                    Logins: {\n                        // Change the key below according to the specific region your user pool is in.\n                        // cognito-idp.us-east-1.amazonaws.com\n                        [k]: result\n                            .getIdToken()\n                            .getJwtToken(),\n                    },\n                });\n\n                console.log(`sessionToken:  ${AWS.config.credentials.sessionToken}`);\n                console.log(`secretAccessKey:  ${AWS.config.credentials.secretAccessKey}`);\n                //refreshes credentials using AWS.CognitoIdentity.getCredentialsForIdentity()\n                // AWS.config.credentials.refresh(error =\u0026gt; {\n                //     if (error) {\n                //         console.error(error);\n                //     } else {\n                //         // Instantiate aws sdk service objects now that the credentials have been updated.\n                //         // example: var s3 = new AWS.S3();\n                //         console.log(\u0026#x27;Successfully logged!\u0026#x27;);\n                //     }\n                // });\n            },\n\n            onFailure: function (err) {\n                console.log(err.message || JSON.stringify(err));\n            },\n        });\n    });\n}\n\nif (process.env[\u0026#x27;APPNAME_ACCESS_TOKEN\u0026#x27;] \u0026amp;\u0026amp; process.env[\u0026#x27;APPNAME_REFRESH_TOKEN\u0026#x27;]) {\n    cognitoAccessToken = new CognitoAccessToken({ AccessToken: process.env[\u0026#x27;APPNAME_ACCESS_TOKEN\u0026#x27;] });\n    cognitoRefreshToken = new CognitoRefreshToken({ RefreshToken: process.env[\u0026#x27;APPNAME_REFRESH_TOKEN\u0026#x27;] });\n    console.log(`Got tokens from env: `, cognitoAccessToken.getJwtToken(), \u0026quot;\\nRefresh:\u0026quot;, cognitoRefreshToken.getToken());\n    startHTTPServer();\n} else {\n    console.log(`No tokens in ENV getting them via Cognito`);\n    await emailAuthInit();\n    const smsCode = await rl.question(\u0026#x27;What is the SMS Code: \u0026#x27;);\n    await emailAuthCode(smsCode);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe really tricky part was looking at the HTTPS dumped requests and figuring out what kind of AWS Cogntio requests I needed to make and what strings to pass. But this was all reverse engineerable from the information in the request bodies and by reading the AWS Cognito library source code.\u003c/p\u003e\u003cp\u003eBasically if you find yourself trying to write something similar where you want to recreate an AWS Cognito login flow and see requests that have in the body:\u003c/p\u003e\u003col\u003e\u003cli\u003eA request with AuthFlow: CUSTOM_AUTH\u003c/li\u003e\u003cli\u003eThen a request with ChallengeName: PASSWORD_VERIFIER\u003c/li\u003e\u003cli\u003eThen a request with ChallengeResponses: PASSWORD_CLAIM_SECRET_BLOCK\u003c/li\u003e\u003cli\u003eThen ChallengeName: CUSTOM_CHALLENGE\u003c/li\u003e\u003cli\u003eChallengeResponses: \\\u0026quot;ANSWER\\\u0026quot;:\\\u0026quot;answerType:generateCode,medium:phone,codeType:login\\\u0026quot;\u003c/li\u003e\u003cli\u003e\u0026quot;{\\\u0026quot;ChallengeName\\\u0026quot;:\\\u0026quot;CUSTOM_CHALLENGE\\\u0026quot;,\\\u0026quot;ChallengeParameters\\\u0026quot;:{\\\u0026quot;challengeType\\\u0026quot;:\\\u0026quot;code\\\u0026quot;}\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eThen the above code should be hackable to get something working for you.\u003c/p\u003e\u003cp\u003eMy auth flow required authorizing via my username and password then doing 2fa using my phone number which was already in their system somehow.\nBecause I started getting a text with a code after I passed the first part of the Cogntio verification with the email and password.\u003c/p\u003e\u003cp\u003eHopefully my Cognito client code above is helpful for someone.\u003c/p\u003e\u003cp\u003eI figured out a bunch of other interesting stuff that I think is useful but I\u0026#x27;ll have to put that into another post.. this post is already a mess of information and is probably hard to follow.\u003c/p\u003e\u003cp\u003eI did figure out how to send fake touch events. So in this case I could script having the app open then wait a second for the app to load and send touch event to the middle of the screen just to hit the lock or unlock button.\u003c/p\u003e\u003cp\u003eThe hackiest of hacks but it\u0026#x27;s really cool sending these fake touch events. I\u0026#x27;ll write a post about that next.\u003c/p\u003e\u003ch3\u003eJust some lldb notes:\u003c/h3\u003e\u003cp\u003eEver be steppin and you step INTO a jump/function call and just want to get back to where you were?\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ethread step-out\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewill get you back!\u003c/p\u003e\u003cp\u003eAnd you can use it to jump over call or bl instructions as well.\u003c/p\u003e\u003cp\u003eSo my LLDB flow was mostly:\u003c/p\u003e\u003col\u003e\u003cli\u003eSearch for possible places to set breakpoints with:\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003ccode\u003eimage lookup -r -n .*AWSCognito.*\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAWSCognito being something related to whatever you want to learn more about. Maybe its refreshToken or something..\u003c/p\u003e\u003col start=\"2\"\u003e\u003cli\u003eThen I check that list it generates and see how ridiculously long it is. If I am going to be setting to many breakpoints I work that regex down to be more specific and then set breakpoints with:\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003ccode\u003ebr set -r  .*refreshToken.*\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen when I hit a breakpoint I would read all the variables and pointers I could. I would check the backtrace to see whats going on:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ebt\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eand from there I could select different \u0026quot;frames\u0026quot; or functions called to get to my breakpoint:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eframe select SOMENUMBERHERE\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI would check the registers at each frame:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eregister read --all\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAlthough they obviously made the most sense down at the frame you break into.\u003c/p\u003e\u003cp\u003eFor each frame your in if you want to see the full dissassembly of the current function run:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003edi -f\n\u003c/code\u003e\u003c/pre\u003e\u003col start=\"3\"\u003e\u003cli\u003eJust start printing out all the info.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eLLDB has nice aliases for the registers that contain function call arguments and can be printed out with:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epo $arg1\npo $arg2\netc...\n\u003c/code\u003e\u003c/pre\u003e\u003col start=\"4\"\u003e\u003cli\u003eAccessing data on objects I found:\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003ccode\u003eexpression -l objc -O -- [$arg1 userPoolConfiguration]\n\u003c/code\u003e\u003c/pre\u003e\u003col start=\"5\"\u003e\u003cli\u003eCreating variables in LLDB:\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003ccode\u003eexpression -l objc -O -- NSURL *$url = [NSURL URLWithString:@\u0026quot;appName://\u0026quot;];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWould create an NSUrl with the lldb variable name $url.\nThen I could test that my method was in fact swizzed correctly with:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eexpression -l objc -O -- [[UIApplication sharedApplication].delegate application:[UIApplication sharedApplication] handleOpenURL:$url];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eMore examples of variables:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eexpression id $delegate = (id)[[UIApplication sharedApplication] delegate]\nexpression id $keyWindow= (id)[$delegate window]\nexpression id $root = (id)[$keyWindow rootViewController]\npo $root\n\u003c/code\u003e\u003c/pre\u003e\u003col start=\"6\"\u003e\u003cli\u003eGot a sneaking suspicion some address is really a pointer? Want to see if its an object?\nCast it as an (id) and po it:\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003ccode\u003epo (id)0x7facaada2c80\n\u003c/code\u003e\u003c/pre\u003e\u003col start=\"7\"\u003e\u003cli\u003eIMPORTANT - You can use\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003ccode\u003ecommand script import lldb.macosx.heap\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ein lldb to get access to some realllllly helpful heap functions. Similar to what Frida provides for searching the heap for objects. Huuuuuuge for me.\u003c/p\u003e\u003col start=\"8\"\u003e\u003cli\u003eMy .lldbinit file:\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003ccode\u003ecommand script import lldb.macosx.heap\ntype summary add --category swift --summary-string \u0026quot;Unmanaged Contains: ${var._value%@}\u0026quot; Swift.Unmanaged\u0026lt;AnyObject\u0026gt;\ncommand script import /Users/bbarrows/lldb/load_swift.py\n# to run lldb \u0026quot;shell\u0026quot; scripts\ncommand alias shsource command source\n# to run a shell command, like `open`\ncommand alias shellcmd platform shell\n# tell lldb to assume swift, not objc\nsettings set target.language Swift\ncommand alias clear-lang settings clear target.language\ncommand alias swiftui_script load_swift /Users/bbarrows/lldb/helpers.swift\n#command script import  /Users/bbarrows/repos/MyLLDB/python/sbt.py\ncommand alias eco expression -l objective-c -O --\ncommand alias ecs expression -l swift -O --\ncommand alias br breakpoint\ncommand alias rr register read\ncommand alias rra register read\ncommand regex ims \u0026#x27;s/(.+)/image lookup -rn %1/\u0026#x27;\ncommand regex z \u0026#x27;s/(.+)/breakpoint set -r %1/\u0026#x27;\ncommand regex mr \u0026#x27;s/(.+) (.+)/memory read --size 8 --format x --count %2 %1/\u0026#x27;\ncommand regex pos  \u0026#x27;s/(.+)/po (const char *)%1/\u0026#x27;\ncommand regex posc  \u0026#x27;s/(.+)/expression -l swift -O -- unsafeBitCast(0x7f8c7b002b30, to: %1.self)/\u0026#x27;\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eUseful tools\u003c/h3\u003e\u003cp\u003eBest tool I think for dumping headers these days is \u003ca href=\"https://github.com/cxnder/ktool\"\u003ektool\u003c/a\u003e\nReally nice GUI too and handles the MachO sections that are causing the older header dump tools to fail.\u003c/p\u003e\u003cp\u003eI also probably learned the most and got the farthest just using lldb and Frida BUT attaching xCode to your running process and then using the xCode Memory Graph was super helpful to figure out what was related to what and what information I could find. For example, I had some Swift class with private properties or whatever that I couldn\u0026#x27;t access but I was able to figure out the offset from the object handle and get a reference to its JWT that way.\u003c/p\u003e\u003cp\u003eFor me Frida and lldb are the most useful tools other then, in this case, just using a tool like Charles Proxy for dumping the https session. I actually was using another tool called Quantum I think but same idea and I can\u0026#x27;t remember the name now. Surge 5 also works fine.. But it\u0026#x27;s pretty buggy and has poort documentation especially if your trying to do stuff like have your mac control it on your phone.\u003c/p\u003e\u003ch1\u003eSummary\u003c/h1\u003e\u003cp\u003eI poked around a lot trying a lot of different things. I was hoping to just hook or add and implementation for handling IOS URLSchemes so I could script opening the app and have it lock and unlock the door.\u003c/p\u003e\u003cp\u003eI couldn\u0026#x27;t find a good way to get a JWT that was always valid. The application will run some Swift code that I wasn\u0026#x27;t able to track down in a relatively sane amount of time so I gave up on getting the JWT and refresh token from the heap/app.\u003c/p\u003e\u003cp\u003eI ended up looking at the HTTPS requests. Figuring out it was using AWS Cognito. And then re creating my own service that just mimicks whats the lock company does to get me a JWT for their lock control server.\u003c/p\u003e\u003cp\u003eNow I have a service running that I logged into once, it refreshes the JWT every 30 min, and I can send HTTPS requests to it to lock and unlock my door with a Siri/Shortcut I created.\u003c/p\u003e","scope":{"slug":"ios-aws-cognito-reverse-engineering","title":"Reverse engineering an iOS application to allow for integration with shortcuts and Siri - Recreate AWS Cognito authentication and sending fake UITouch events","date":"2023-05-12","author":"bebrws","tags":["Reverse engineering","iOS","aws","cognito","frida","lldb","osx","Siri","shortcuts","UITouch","SwiftUI","Deep linking","IOS URLScheme"]}}},"__N_SSG":true},"page":"/posts/[post]","query":{"post":"ios-aws-cognito-reverse-engineering"},"buildId":"lATzPuzq9Tes3x9uwms3o","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>