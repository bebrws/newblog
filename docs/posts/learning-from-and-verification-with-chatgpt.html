<!DOCTYPE html><html><head><script type="text/javascript" class="jsx-707554062">
          
          function loadBevySnake() {
            setTimeout(function() {
            var element = document.getElementById('bevy-portal');
                  if (element) {
                    console.log('Element with id "bevy-portal" exists. Adding script tag.');

                  var script = document.createElement('script');
                  script.type = 'module';
                  script.src = '../static/load-bevy-snake.js';
                  document.head.appendChild(script);
            } else {
                    console.log('Element with id "bevy-portal" does not exist.');
                    loadBevySnake();
            }
          }, 500);
        }

        loadBevySnake();
      </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=UA-154810525-2" class="jsx-707554062"></script><script type="text/javascript" class="jsx-707554062">
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'UA-154810525-2');
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-BZKS5D8HPF" class="jsx-707554062"></script><script type="text/javascript" class="jsx-707554062">
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-BZKS5D8HPF');
        </script><meta charSet="utf-8" class="jsx-707554062"/><meta name="viewport" content="width=device-width, initial-scale=1" class="jsx-707554062"/><link rel="manifest" href="/site.webmanifest" class="jsx-707554062"/><link rel="apple-touch-icon" href="/icon.png" class="jsx-707554062"/><meta name="theme-color" content="#fff" class="jsx-707554062"/><title>Learning From and Verification with ChatGPT | Brad Barrows&#x27; Blog</title><meta name="description" content="Brad Barrows&#x27; Blog"/><link rel="canonical" href="https://bbarrows.com/posts/learning-from-and-verification-with-chatgpt"/><meta property="og:site_name" content="Brad Barrows&#x27; Blog"/><meta property="og:url" content="https://bbarrows.com/posts/learning-from-and-verification-with-chatgpt"/><meta property="og:title" content="Learning From and Verification with ChatGPT | Brad Barrows&#x27; Blog"/><meta property="og:description" content="Brad Barrows&#x27; Blog"/><meta property="og:image" content="https://bbarrows.com/og_image.png"/><meta property="og:type" content="article"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":"https://bbarrows.com/posts/learning-from-and-verification-with-chatgpt","headline":"Learning From and Verification with ChatGPT","datePublished":"2023-02-06T00:00:00-08:00","author":"Brad Barrows","description":""}</script><meta name="next-head-count" content="20"/><link rel="preload" href="/_next/static/css/8e11f38ccf46f6277e39.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e11f38ccf46f6277e39.css" data-n-g=""/><link rel="preload" href="/_next/static/css/08c00d6a07e310229cb0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08c00d6a07e310229cb0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-f47d69457824065d04c3.js" defer=""></script><script src="/_next/static/chunks/framework-895f067827ebe11ffe45.js" defer=""></script><script src="/_next/static/chunks/main-d32200c037819e7e8fa0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-eae7af63eb651790e0a7.js" defer=""></script><script src="/_next/static/chunks/962-b2e3b32260744832b5cf.js" defer=""></script><script src="/_next/static/chunks/189-6fa1af65347fdf66ab7b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpost%5D-798896a96beb46d3eaba.js" defer=""></script><script src="/_next/static/nENEKRtsitJh7ixPHU9Bl/_buildManifest.js" defer=""></script><script src="/_next/static/nENEKRtsitJh7ixPHU9Bl/_ssgManifest.js" defer=""></script><style id="__jsx-2373991563">a.jsx-2373991563{color:inherit;-webkit-text-decoration:none;text-decoration:none;}a.jsx-2373991563:hover{-webkit-text-decoration:underline;text-decoration:underline;}</style><style id="__jsx-3058196896">.container.jsx-3058196896{position:fixed;width:38px;height:38px;cursor:pointer;top:1rem;left:1.25rem;z-index:2;background-color:rgba(255,255,255,0.7);}.meat.jsx-3058196896{position:absolute;width:28px;height:2px;background:#222;top:calc(50% - 2px / 2);left:calc(50% - 28px / 2);-webkit-transition:all 150ms ease-in;transition:all 150ms ease-in;}.meat-1.jsx-3058196896{-webkit-transform:translateY(-10px);-ms-transform:translateY(-10px);transform:translateY(-10px);}.meat-2.jsx-3058196896{width:calc(28px - 6px);}.meat-3.jsx-3058196896{-webkit-transform:translateY(10px);-ms-transform:translateY(10px);transform:translateY(10px);}.active.jsx-3058196896 .meat-1.jsx-3058196896{-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);transform:rotate(45deg);}.active.jsx-3058196896 .meat-2.jsx-3058196896{opacity:0;}.active.jsx-3058196896 .meat-3.jsx-3058196896{-webkit-transform:rotate(-45deg);-ms-transform:rotate(-45deg);transform:rotate(-45deg);}@media (min-width:769px){.container.jsx-3058196896{display:none;}}</style><style id="__jsx-4138737674">.container.jsx-4138737674{width:0;}ul.jsx-4138737674{opacity:0;width:100%;height:100vh;text-align:right;list-style:none;margin:0;padding:0;position:fixed;top:0;background-color:#fff;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;z-index:1;-webkit-transform:translateY(100%);-ms-transform:translateY(100%);transform:translateY(100%);-webkit-transition:opacity 200ms;transition:opacity 200ms;}.active.jsx-4138737674 ul.jsx-4138737674{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);transform:translateY(0);}li.jsx-4138737674{margin-bottom:1.75rem;font-size:2rem;padding:0 1.5rem 0 0;}li.jsx-4138737674:last-child{margin-bottom:0;}.active.jsx-4138737674{color:#222;}@media (min-width:769px){.container.jsx-4138737674{width:7rem;display:block;}ul.jsx-4138737674{opacity:1;width:7rem;top:auto;display:block;-webkit-transform:translateY(0);-ms-transform:translateY(0);transform:translateY(0);}li.jsx-4138737674{font-size:1rem;padding:0;}}</style><style id="__jsx-3674465219">span.jsx-3674465219{color:#9b9b9b;}</style><style id="__jsx-255066894">a.jsx-255066894{display:inline-block;}a.jsx-255066894:not(:last-child){margin-right:2em;}</style><style id="__jsx-3618008669">p.jsx-3618008669{font-size:0.75rem;text-align:center;}</style><style id="__jsx-4153080612">.container.jsx-3387257903{display:block;max-width:60rem;width:100%;margin:0 auto;padding:0 1.5rem;box-sizing:border-box;z-index:0;}.metadata.jsx-3387257903 div.jsx-3387257903{display:inline-block;margin-right:0.5rem;}article.jsx-3387257903{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;}h1.jsx-3387257903{margin:0 0 0.5rem;font-size:2.25rem;}.tag-list.jsx-3387257903{list-style:none;text-align:right;margin:1.75rem 0 0 0;padding:0;}.tag-list.jsx-3387257903 li.jsx-3387257903{display:inline-block;margin-left:0.5rem;}.social-list.jsx-3387257903{margin-top:3rem;text-align:center;}@media (min-width:769px){.container.jsx-3387257903{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}</style><style id="__jsx-1699270818">.token.comment,.token.prolog,.token.doctype,.token.cdata,.token.plain-text{color:#6a737d;}.token.atrule,.token.attr-value,.token.keyword,.token.operator{color:#d73a49;}.token.property,.token.tag,.token.boolean,.token.number,.token.constant,.token.symbol,.token.deleted{color:#22863a;}.token.selector,.token.attr-name,.token.string,.token.char,.token.builtin,.token.inserted{color:#032f62;}.token.function,.token.class-name{color:#6f42c1;}.language-jsx .token.punctuation,.language-jsx .token.tag .token.punctuation,.language-jsx .token.tag .token.script,.language-jsx .token.plain-text{color:#24292e;}.language-jsx .token.tag .token.attr-name{color:#6f42c1;}.language-jsx .token.tag .token.class-name{color:#005cc5;}.language-jsx .token.tag .token.script-punctuation,.language-jsx .token.attr-value .token.punctuation:first-child{color:#d73a49;}.language-jsx .token.attr-value{color:#032f62;}.language-jsx span[class="comment"]{color:pink;}.language-html .token.tag .token.punctuation{color:#24292e;}.language-html .token.tag .token.attr-name{color:#6f42c1;}.language-html .token.tag .token.attr-value,.language-html .token.tag .token.attr-value .token.punctuation:not(:first-child){color:#032f62;}.language-css .token.selector{color:#6f42c1;}.language-css .token.property{color:#005cc5;}</style><style id="__jsx-707554062">.root.jsx-707554062{display:block;padding:4rem 0;box-sizing:border-box;height:100%;}main.jsx-707554062{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;min-height:100%;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}@media (min-width:769px){.root.jsx-707554062{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;}main.jsx-707554062{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;}}</style></head><body><div id="__next"><div class="jsx-707554062 root"><nav class="jsx-707554062"><div class="jsx-3058196896 container "><div class="jsx-3058196896 meat meat-1"></div><div class="jsx-3058196896 meat meat-2"></div><div class="jsx-3058196896 meat meat-3"></div></div><div class="jsx-4138737674 container "><ul class="jsx-4138737674"><li class="jsx-4138737674"><a class="jsx-4138737674 " href="/">about</a></li><li class="jsx-4138737674"><a class="jsx-4138737674 " href="/projects">projects</a></li><li class="jsx-4138737674"><a class="jsx-4138737674 active" href="/posts">blog</a></li></ul></div></nav><main class="jsx-707554062"><div class="jsx-3387257903 container"><article class="jsx-3387257903"><header class="jsx-3387257903"><h1 class="jsx-3387257903">Learning From and Verification with ChatGPT</h1><div class="jsx-3387257903 metadata"><div class="jsx-3387257903"><time dateTime="2023-02-06T00:00:00-08:00" class="jsx-3674465219"><span class="jsx-3674465219">February 6, 2023</span></time></div><div class="jsx-3387257903"><span class="jsx-3674465219">Brad Barrows</span></div></div></header><div class="jsx-3387257903 content_content__1yuPc"><div><div style="position:relative"><span style="position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b">#</span><h1 id="Hopping%20on%20the%20ChatGPT%20Bandwagon%20and%20My%20Previous%20Use%20of%20Chatgpt%20and%20Github%20Copilot" class="jsx-2373991563"><a href="#Hopping%20on%20the%20ChatGPT%20Bandwagon%20and%20My%20Previous%20Use%20of%20Chatgpt%20and%20Github%20Copilot" class="jsx-2373991563">Hopping on the ChatGPT Bandwagon and My Previous Use of Chatgpt and Github Copilot</a></h1></div><div style="position:relative"><span style="position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b">#</span><h2 id="CoPilot" class="jsx-2373991563"><a href="#CoPilot" class="jsx-2373991563">CoPilot</a></h2></div><p>So I have had access to GitHub CoPilot for a year or two and it has definately been helpful in a lot minor ways (mundane tasks) and once with a surprisingly helpful solution spanning 50 lines of code that only needed minor changes.
It is usually just nice for work such as being able to automtically write out some parameters I just wrote the documentation for above.</p><p>Once though I had created a few constant lists and functions which made different HTTP API requests. I had written one for block that iterated over one of the lists and used one of the functions I had written to get data I would later need to combine with results from future requests.
CoPilot then actually suggested a chunk of code, about 50 lines long correctly iterating over another lists also including an inner for loop needed to get data for each of the results from the outer for loop.</p><p>I am still inpressed by CoPilot from that day. Everyone was in a rush to get some data migrated from one service to another and I had to write scripts to extract data from one API, massage it into a new shape, correlate that data with data from other requests to the API, and then populate the new service with this data.</p><p>I believe I only had to make changes on 2 or 3 lines of that code.</p><p>It has also been helpful with languages I am less familiar with or learning. Often I will be writing Rust code and sort through the different suggestions by CoPilot just to to learn how others would have gone about the same task.</p><div style="position:relative"><span style="position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b">#</span><h2 id="ChatGPT" class="jsx-2373991563"><a href="#ChatGPT" class="jsx-2373991563">ChatGPT</a></h2></div><p>Now everyone knows how amazing ChatGPT is. My favorite examples involve reverse engineering. For example, a Ghidra plugin that will help name variables at the C pseudocode level or explain one of the functions that Ghidra created pseudocode for. Down to the level of what &quot;kind&quot; of function it is, what it is used for. For exxample, taking a function comprised of a handful of for loops and conditionals and figuring out it is a memcpy operation.</p><p>I have realized that it is also much faster for me to research topics I don&#x27;t have enough experience with or knowledge in.
The best part being that you can get a great answer right away without sorting through a bunch of search results and then easily drill down into topics mentioned there by asking further questions.</p><p>Or in one case recently, helping me to understand best practices in GoLang for specific tasks.</p><p>I was reading through some GoLang code making heavy use of goroutines.
I realized this function was just iterating over a list of values, asynchronously collecting the results, and then returning the reaults once all of the async operations had finished. </p><p>In JS, an example of something &quot;similar&quot; with NodeJS could be:</p><pre><code>
  async function makeAPIRequestToGetUserProfile(userId) { /* make http request, etc.. */ }
  const userIds = [0, 1, 2];
  const profileDataOfUsers = await Promise.all(userIds.map( id =&gt; makeAPIRequestToGetUserProfile(id) ));

</code></pre><p>The existing implementation I read used a few GoLang primitves that I had not used before. I have not written a ton of GoLang code, have a lot I could learn, and when I am using GoLang for work I am often worried about whether or not I am following best practices.</p><p>Reading this GoLang function I was able to make assumptions and by reading the amazingly well documented GoLang code base&#x27;s inline documentation, then further determine exactly how the function worked.</p><p>Now I still wanted to verify my understanding and I was curious if the pattern used in this code was what would be considered as following GoLang best practices.</p><p>So next I asked ChatGPT to write me a function that did what I had determined the code I was reading did.</p><p>I was then given an amazing response which gave me an example making use of all the same GoLang synchronization and concurrency primitives. What I appreciated the most was that this result was a simple example that allowed me to focus on the GoLang primitives and patterns.</p><p>The result was so close to the code I had been reading that I was also able to realize I had missed some functionality in my first &quot;mental summary&quot; of how this code worked.</p><p>Not only was it spawning threads/goroutines to collect data in parallel but it also was checking to see if it should stop by checking the passed Context.</p><div style="position:relative"><span style="position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b">#</span><h3 id="The%20First%20Attempt" class="jsx-2373991563"><a href="#The%20First%20Attempt" class="jsx-2373991563">The First Attempt</a></h3></div><p>So with my first ChatGPT question being:</p><pre><code>  Write me an example GoLang function that collects results from multiple goroutines and returns the list of results
</code></pre><p>I recieved a nice example:</p><pre><code>  package main

  import (
    &quot;fmt&quot;
    &quot;sync&quot;
  )

  func worker(id int, wg *sync.WaitGroup, results chan int) {
    defer wg.Done()
    results &lt;- id * 2
  }

  func collectResults(n int) []int {
    var wg sync.WaitGroup
    results := make(chan int, n)

    for i := 0; i &lt; n; i++ {
      wg.Add(1)
      go worker(i, &amp;wg, results)
    }

    wg.Wait()
    close(results)

    var resultList []int
    for res := range results {
      resultList = append(resultList, res)
    }

    return resultList
  }

  func main() {
    resultList := collectResults(10)
    fmt.Println(resultList)
  }
</code></pre><p>The description of the code by ChatGPT was also somewhat helpful. Although reading the GoLang codebase&#x27;s inline documentation provided a much better understanding and was easy to find with VSCode taking me directly to the definiton.
ChatGPT&#x27;s code description:</p><pre><code>  This example uses a sync.WaitGroup to wait for all the goroutines to complete and a channel results to collect the results from each goroutine. The function worker takes an ID and a WaitGroup pointer, and sends its result to the results channel. The collectResults function starts n worker goroutines, waits for all of them to finish using the WaitGroup, closes the results channel, and collects all the results into a slice.
``

### Same Question, Different Results

When asking the same question I actually get a slightly different implementation:

</code></pre><p>  package main</p><p>  import (
&quot;fmt&quot;
&quot;sync&quot;
)</p><p>  func collectResults(n int) []int {
var wg sync.WaitGroup
results := make([]int, 0, n)
resultCh := make(chan int)</p><pre><code>for i := 0; i &lt; n; i++ {
  wg.Add(1)
  go func(i int) {
    defer wg.Done()
    resultCh &lt;- i
  }(i)
}

go func() {
  wg.Wait()
  close(resultCh)
}()

for res := range resultCh {
  results = append(results, res)
}

return results
</code></pre><p>  }</p><p>  func main() {
results := collectResults(5)
fmt.Println(results)
}</p><pre><code>
Getting this different result was actually really helpful. The first thing I saw, and was actually wondering about with other code I read, was that there was a separate goroutine dedicated to just waiting for the WaitGroup count to decrement to 0 before closing the channel:

</code></pre><pre><code>go func() {
  wg.Wait()
  close(resultCh)
}()
</code></pre><pre><code>
Without seeing this different result I would not have learned that unless you create a &quot;buffered&quot; channel sending on the channel will block. As the docs say, that:
</code></pre><p>  Sends to a buffered channel block only when the buffer is full.</p><pre><code>
This is why the first response from ChatGPT was a little simpler and didn&#x27;t require the extra goroutine. It creates a channel, buffered to size n:

</code></pre><p>  results := make(chan int, n)</p><pre><code>
### Getting Slightly More Complicated

Now I wanted to see how close of an example I could get to the code I was reading. The code I was reading also took a Context and checked for cancellation.
Building on my previous ChatGPT question with:

</code></pre><p>  The function collectResults should use a GoLang Context and check if it was cancelled to stop the process of collecting results.</p><pre><code>
The result I get back is exactly what I was hoping for, if not better. Illustrating how Context can be used to check for cancellation.


</code></pre><p>  package main</p><p>  import (
&quot;context&quot;
&quot;fmt&quot;
&quot;sync&quot;
)</p><p>  func collectResults(ctx context.Context, n int) []int {
var wg sync.WaitGroup
results := make([]int, 0, n)
resultCh := make(chan int)</p><pre><code>for i := 0; i &lt; n; i++ {
  wg.Add(1)
  go func(i int) {
    defer wg.Done()
    select {
    case &lt;-ctx.Done():
      return
    case resultCh &lt;- i:
    }
  }(i)
}

go func() {
  wg.Wait()
  close(resultCh)
}()

for {
  select {
  case &lt;-ctx.Done():
    return results
  case res, ok := &lt;-resultCh:
    if !ok {
      return results
    }
    results = append(results, res)
  }
}
</code></pre><p>  }</p><p>  func main() {
ctx, cancel := context.WithCancel(context.Background())
defer cancel()</p><pre><code>results := collectResults(ctx, 5)
fmt.Println(results)
</code></pre><p>  }</p><pre><code>
The explanation by ChatGPT is also great and had I not already read the documentation would have been enough information to understand how this code works:

</code></pre><p>  In this example, the collectResults function creates a channel resultCh for collecting results from the goroutines, launches n number of goroutines, each sending its index to the channel, and increments a wait group for each goroutine. It also includes a select statement with the Context&#x27;s Done channel to check if the Context has been cancelled and return early if so. Then, it launches a goroutine that waits for all goroutines to finish and closes the result channel. Finally, the main function collects the results from the channel by range over it with a select statement that also checks the Context&#x27;s Done channel to return early if the Context is cancelled.</p><pre><code>
### Asking for an Explanation for the Original Code

I also tried asking for an explanation of the original code (just one function) which contained references to types and interfaces defined elsewhere.

What I think is most impressive here is that it was able to infer how some interfaces were used just from the name scheme. 
The rest of the actual explanation was perfect as well.

### In summary

I would probably save a lot of time if I just spent a little time practicing querying/prompting ChatGPT when researching something.
Google is so full of poorly written Medium posts, all with duplicate content, that researching can be done quicker and more accurately with ChatGPT in many cases.

Specifically with GoLang, the documentation in the code and official documentation online is well written/done that I should probably just never leave those resources.
But I plan on trying to take more advantage of this personally.
</code></pre></div></div></article><footer class="jsx-3387257903"><div class="jsx-3387257903 social-list"><div class="jsx-255066894"><a title="LinkedIn" href="https://www.linkedin.com/in/bbarrows/}" target="_blank" rel="noopener" class="jsx-255066894"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#222"><path fill="#444" d="M5.453 11.099v15.484H.297V11.099h5.156zm.328-4.781q.016 1.141-.789 1.906t-2.117.766h-.031q-1.281 0-2.063-.766T0 6.318q0-1.156.805-1.914t2.102-.758 2.078.758.797 1.914zM24 17.708v8.875h-5.141v-8.281q0-1.641-.633-2.57t-1.977-.93q-.984 0-1.648.539t-.992 1.336q-.172.469-.172 1.266v8.641H8.296q.031-6.234.031-10.109t-.016-4.625l-.016-.75h5.141v2.25h-.031q.312-.5.641-.875t.883-.812 1.359-.68 1.789-.242q2.672 0 4.297 1.773t1.625 5.195z"></path></svg></a><a title="GitHub" href="https://github.com/bebrws/" target="_blank" rel="noopener" class="jsx-255066894"><svg viewBox="0 0 11 11" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2" width="24" height="24" fill="#222"><path d="M10.5 5.63a4.992 4.992 0 01-.977 3.016A5.018 5.018 0 016.998 10.5c-.12.022-.207.007-.263-.047a.267.267 0 01-.083-.2v-1.41c0-.432-.116-.748-.347-.948.253-.027.481-.067.683-.12.203-.054.412-.14.627-.26.216-.121.396-.27.54-.445.145-.176.263-.41.354-.702.091-.291.137-.626.137-1.005a1.95 1.95 0 00-.527-1.376c.164-.405.147-.86-.053-1.363-.125-.04-.305-.015-.54.074a3.59 3.59 0 00-.614.294l-.254.16a4.727 4.727 0 00-1.28-.174c-.44 0-.867.058-1.28.174a5.931 5.931 0 00-.284-.18 3.995 3.995 0 00-.557-.258c-.254-.1-.445-.13-.574-.09-.195.504-.211.958-.046 1.363a1.95 1.95 0 00-.527 1.376c0 .379.045.713.136 1.002.092.29.208.523.35.702.143.178.322.327.537.447.216.12.425.207.627.26.203.054.43.094.684.12-.178.161-.287.39-.327.689a1.32 1.32 0 01-.3.1 1.885 1.885 0 01-.38.034A.785.785 0 013 8.573a1.177 1.177 0 01-.37-.418 1.077 1.077 0 00-.324-.347.973.973 0 00-.33-.16l-.133-.02a.432.432 0 00-.194.03c-.035.02-.046.045-.033.077a.487.487 0 00.147.174l.046.033c.098.044.195.129.29.254.096.124.166.238.21.34l.067.154c.058.17.156.306.294.41.138.105.287.172.447.201.16.029.314.045.463.047a1.96 1.96 0 00.37-.024l.154-.026a62.026 62.026 0 00.007.955c0 .08-.03.147-.087.2-.058.054-.147.07-.267.047a5.018 5.018 0 01-2.524-1.854A4.992 4.992 0 01.255 5.63c0-.93.23-1.789.687-2.575a5.103 5.103 0 011.865-1.867A5.005 5.005 0 015.377.5c.93 0 1.787.23 2.572.688a5.103 5.103 0 011.864 1.867c.458.786.687 1.645.687 2.575z" fill="#444" fill-rule="nonzero"></path></svg></a></div></div><p class="jsx-3618008669">Â© 2021</p></footer></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Learning From and Verification with ChatGPT","dateString":"2023-02-06","slug":"learning-from-and-verification-with-chatgpt","description":"","tags":["GoLang","ChatGPT","Learning","Machine Learning","ML"],"author":"bebrws","source":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i \u003c arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i \u003c sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i \u003c sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Hopping on the ChatGPT Bandwagon and My Previous Use of Chatgpt and Github Copilot\"), mdx(\"h2\", null, \"CoPilot\"), mdx(\"p\", null, \"So I have had access to GitHub CoPilot for a year or two and it has definately been helpful in a lot minor ways (mundane tasks) and once with a surprisingly helpful solution spanning 50 lines of code that only needed minor changes.\\nIt is usually just nice for work such as being able to automtically write out some parameters I just wrote the documentation for above.\"), mdx(\"p\", null, \"Once though I had created a few constant lists and functions which made different HTTP API requests. I had written one for block that iterated over one of the lists and used one of the functions I had written to get data I would later need to combine with results from future requests.\\nCoPilot then actually suggested a chunk of code, about 50 lines long correctly iterating over another lists also including an inner for loop needed to get data for each of the results from the outer for loop.\"), mdx(\"p\", null, \"I am still inpressed by CoPilot from that day. Everyone was in a rush to get some data migrated from one service to another and I had to write scripts to extract data from one API, massage it into a new shape, correlate that data with data from other requests to the API, and then populate the new service with this data.\"), mdx(\"p\", null, \"I believe I only had to make changes on 2 or 3 lines of that code.\"), mdx(\"p\", null, \"It has also been helpful with languages I am less familiar with or learning. Often I will be writing Rust code and sort through the different suggestions by CoPilot just to to learn how others would have gone about the same task.\"), mdx(\"h2\", null, \"ChatGPT\"), mdx(\"p\", null, \"Now everyone knows how amazing ChatGPT is. My favorite examples involve reverse engineering. For example, a Ghidra plugin that will help name variables at the C pseudocode level or explain one of the functions that Ghidra created pseudocode for. Down to the level of what \\\"kind\\\" of function it is, what it is used for. For exxample, taking a function comprised of a handful of for loops and conditionals and figuring out it is a memcpy operation.\"), mdx(\"p\", null, \"I have realized that it is also much faster for me to research topics I don't have enough experience with or knowledge in.\\nThe best part being that you can get a great answer right away without sorting through a bunch of search results and then easily drill down into topics mentioned there by asking further questions.\"), mdx(\"p\", null, \"Or in one case recently, helping me to understand best practices in GoLang for specific tasks.\"), mdx(\"p\", null, \"I was reading through some GoLang code making heavy use of goroutines.\\nI realized this function was just iterating over a list of values, asynchronously collecting the results, and then returning the reaults once all of the async operations had finished. \"), mdx(\"p\", null, \"In JS, an example of something \\\"similar\\\" with NodeJS could be:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\n  async function makeAPIRequestToGetUserProfile(userId) { /* make http request, etc.. */ }\\n  const userIds = [0, 1, 2];\\n  const profileDataOfUsers = await Promise.all(userIds.map( id =\u003e makeAPIRequestToGetUserProfile(id) ));\\n\\n\")), mdx(\"p\", null, \"The existing implementation I read used a few GoLang primitves that I had not used before. I have not written a ton of GoLang code, have a lot I could learn, and when I am using GoLang for work I am often worried about whether or not I am following best practices.\"), mdx(\"p\", null, \"Reading this GoLang function I was able to make assumptions and by reading the amazingly well documented GoLang code base's inline documentation, then further determine exactly how the function worked.\"), mdx(\"p\", null, \"Now I still wanted to verify my understanding and I was curious if the pattern used in this code was what would be considered as following GoLang best practices.\"), mdx(\"p\", null, \"So next I asked ChatGPT to write me a function that did what I had determined the code I was reading did.\"), mdx(\"p\", null, \"I was then given an amazing response which gave me an example making use of all the same GoLang synchronization and concurrency primitives. What I appreciated the most was that this result was a simple example that allowed me to focus on the GoLang primitives and patterns.\"), mdx(\"p\", null, \"The result was so close to the code I had been reading that I was also able to realize I had missed some functionality in my first \\\"mental summary\\\" of how this code worked.\"), mdx(\"p\", null, \"Not only was it spawning threads/goroutines to collect data in parallel but it also was checking to see if it should stop by checking the passed Context.\"), mdx(\"h3\", null, \"The First Attempt\"), mdx(\"p\", null, \"So with my first ChatGPT question being:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"  Write me an example GoLang function that collects results from multiple goroutines and returns the list of results\\n\")), mdx(\"p\", null, \"I recieved a nice example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"  package main\\n\\n  import (\\n    \\\"fmt\\\"\\n    \\\"sync\\\"\\n  )\\n\\n  func worker(id int, wg *sync.WaitGroup, results chan int) {\\n    defer wg.Done()\\n    results \u003c- id * 2\\n  }\\n\\n  func collectResults(n int) []int {\\n    var wg sync.WaitGroup\\n    results := make(chan int, n)\\n\\n    for i := 0; i \u003c n; i++ {\\n      wg.Add(1)\\n      go worker(i, \u0026wg, results)\\n    }\\n\\n    wg.Wait()\\n    close(results)\\n\\n    var resultList []int\\n    for res := range results {\\n      resultList = append(resultList, res)\\n    }\\n\\n    return resultList\\n  }\\n\\n  func main() {\\n    resultList := collectResults(10)\\n    fmt.Println(resultList)\\n  }\\n\")), mdx(\"p\", null, \"The description of the code by ChatGPT was also somewhat helpful. Although reading the GoLang codebase's inline documentation provided a much better understanding and was easy to find with VSCode taking me directly to the definiton.\\nChatGPT's code description:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"  This example uses a sync.WaitGroup to wait for all the goroutines to complete and a channel results to collect the results from each goroutine. The function worker takes an ID and a WaitGroup pointer, and sends its result to the results channel. The collectResults function starts n worker goroutines, waits for all of them to finish using the WaitGroup, closes the results channel, and collects all the results into a slice.\\n``\\n\\n### Same Question, Different Results\\n\\nWhen asking the same question I actually get a slightly different implementation:\\n\\n\")), mdx(\"p\", null, \"  package main\"), mdx(\"p\", null, \"  import (\\n\\\"fmt\\\"\\n\\\"sync\\\"\\n)\"), mdx(\"p\", null, \"  func collectResults(n int) []int {\\nvar wg sync.WaitGroup\\nresults := make([]int, 0, n)\\nresultCh := make(chan int)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"for i := 0; i \u003c n; i++ {\\n  wg.Add(1)\\n  go func(i int) {\\n    defer wg.Done()\\n    resultCh \u003c- i\\n  }(i)\\n}\\n\\ngo func() {\\n  wg.Wait()\\n  close(resultCh)\\n}()\\n\\nfor res := range resultCh {\\n  results = append(results, res)\\n}\\n\\nreturn results\\n\")), mdx(\"p\", null, \"  }\"), mdx(\"p\", null, \"  func main() {\\nresults := collectResults(5)\\nfmt.Println(results)\\n}\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\nGetting this different result was actually really helpful. The first thing I saw, and was actually wondering about with other code I read, was that there was a separate goroutine dedicated to just waiting for the WaitGroup count to decrement to 0 before closing the channel:\\n\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"go func() {\\n  wg.Wait()\\n  close(resultCh)\\n}()\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\nWithout seeing this different result I would not have learned that unless you create a \\\"buffered\\\" channel sending on the channel will block. As the docs say, that:\\n\")), mdx(\"p\", null, \"  Sends to a buffered channel block only when the buffer is full.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\nThis is why the first response from ChatGPT was a little simpler and didn't require the extra goroutine. It creates a channel, buffered to size n:\\n\\n\")), mdx(\"p\", null, \"  results := make(chan int, n)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\n### Getting Slightly More Complicated\\n\\nNow I wanted to see how close of an example I could get to the code I was reading. The code I was reading also took a Context and checked for cancellation.\\nBuilding on my previous ChatGPT question with:\\n\\n\")), mdx(\"p\", null, \"  The function collectResults should use a GoLang Context and check if it was cancelled to stop the process of collecting results.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\nThe result I get back is exactly what I was hoping for, if not better. Illustrating how Context can be used to check for cancellation.\\n\\n\\n\")), mdx(\"p\", null, \"  package main\"), mdx(\"p\", null, \"  import (\\n\\\"context\\\"\\n\\\"fmt\\\"\\n\\\"sync\\\"\\n)\"), mdx(\"p\", null, \"  func collectResults(ctx context.Context, n int) []int {\\nvar wg sync.WaitGroup\\nresults := make([]int, 0, n)\\nresultCh := make(chan int)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"for i := 0; i \u003c n; i++ {\\n  wg.Add(1)\\n  go func(i int) {\\n    defer wg.Done()\\n    select {\\n    case \u003c-ctx.Done():\\n      return\\n    case resultCh \u003c- i:\\n    }\\n  }(i)\\n}\\n\\ngo func() {\\n  wg.Wait()\\n  close(resultCh)\\n}()\\n\\nfor {\\n  select {\\n  case \u003c-ctx.Done():\\n    return results\\n  case res, ok := \u003c-resultCh:\\n    if !ok {\\n      return results\\n    }\\n    results = append(results, res)\\n  }\\n}\\n\")), mdx(\"p\", null, \"  }\"), mdx(\"p\", null, \"  func main() {\\nctx, cancel := context.WithCancel(context.Background())\\ndefer cancel()\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"results := collectResults(ctx, 5)\\nfmt.Println(results)\\n\")), mdx(\"p\", null, \"  }\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\nThe explanation by ChatGPT is also great and had I not already read the documentation would have been enough information to understand how this code works:\\n\\n\")), mdx(\"p\", null, \"  In this example, the collectResults function creates a channel resultCh for collecting results from the goroutines, launches n number of goroutines, each sending its index to the channel, and increments a wait group for each goroutine. It also includes a select statement with the Context's Done channel to check if the Context has been cancelled and return early if so. Then, it launches a goroutine that waits for all goroutines to finish and closes the result channel. Finally, the main function collects the results from the channel by range over it with a select statement that also checks the Context's Done channel to return early if the Context is cancelled.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\n### Asking for an Explanation for the Original Code\\n\\nI also tried asking for an explanation of the original code (just one function) which contained references to types and interfaces defined elsewhere.\\n\\nWhat I think is most impressive here is that it was able to infer how some interfaces were used just from the name scheme. \\nThe rest of the actual explanation was perfect as well.\\n\\n### In summary\\n\\nI would probably save a lot of time if I just spent a little time practicing querying/prompting ChatGPT when researching something.\\nGoogle is so full of poorly written Medium posts, all with duplicate content, that researching can be done quicker and more accurately with ChatGPT in many cases.\\n\\nSpecifically with GoLang, the documentation in the code and official documentation online is well written/done that I should probably just never leave those resources.\\nBut I plan on trying to take more advantage of this personally.\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"\u003cdiv style=\"position:relative\"\u003e\u003cspan style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\"\u003e#\u003c/span\u003e\u003ch1 id=\"Hopping%20on%20the%20ChatGPT%20Bandwagon%20and%20My%20Previous%20Use%20of%20Chatgpt%20and%20Github%20Copilot\" class=\"jsx-2373991563\"\u003e\u003ca href=\"#Hopping%20on%20the%20ChatGPT%20Bandwagon%20and%20My%20Previous%20Use%20of%20Chatgpt%20and%20Github%20Copilot\" class=\"jsx-2373991563\"\u003eHopping on the ChatGPT Bandwagon and My Previous Use of Chatgpt and Github Copilot\u003c/a\u003e\u003c/h1\u003e\u003c/div\u003e\u003cdiv style=\"position:relative\"\u003e\u003cspan style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\"\u003e#\u003c/span\u003e\u003ch2 id=\"CoPilot\" class=\"jsx-2373991563\"\u003e\u003ca href=\"#CoPilot\" class=\"jsx-2373991563\"\u003eCoPilot\u003c/a\u003e\u003c/h2\u003e\u003c/div\u003e\u003cp\u003eSo I have had access to GitHub CoPilot for a year or two and it has definately been helpful in a lot minor ways (mundane tasks) and once with a surprisingly helpful solution spanning 50 lines of code that only needed minor changes.\nIt is usually just nice for work such as being able to automtically write out some parameters I just wrote the documentation for above.\u003c/p\u003e\u003cp\u003eOnce though I had created a few constant lists and functions which made different HTTP API requests. I had written one for block that iterated over one of the lists and used one of the functions I had written to get data I would later need to combine with results from future requests.\nCoPilot then actually suggested a chunk of code, about 50 lines long correctly iterating over another lists also including an inner for loop needed to get data for each of the results from the outer for loop.\u003c/p\u003e\u003cp\u003eI am still inpressed by CoPilot from that day. Everyone was in a rush to get some data migrated from one service to another and I had to write scripts to extract data from one API, massage it into a new shape, correlate that data with data from other requests to the API, and then populate the new service with this data.\u003c/p\u003e\u003cp\u003eI believe I only had to make changes on 2 or 3 lines of that code.\u003c/p\u003e\u003cp\u003eIt has also been helpful with languages I am less familiar with or learning. Often I will be writing Rust code and sort through the different suggestions by CoPilot just to to learn how others would have gone about the same task.\u003c/p\u003e\u003cdiv style=\"position:relative\"\u003e\u003cspan style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\"\u003e#\u003c/span\u003e\u003ch2 id=\"ChatGPT\" class=\"jsx-2373991563\"\u003e\u003ca href=\"#ChatGPT\" class=\"jsx-2373991563\"\u003eChatGPT\u003c/a\u003e\u003c/h2\u003e\u003c/div\u003e\u003cp\u003eNow everyone knows how amazing ChatGPT is. My favorite examples involve reverse engineering. For example, a Ghidra plugin that will help name variables at the C pseudocode level or explain one of the functions that Ghidra created pseudocode for. Down to the level of what \u0026quot;kind\u0026quot; of function it is, what it is used for. For exxample, taking a function comprised of a handful of for loops and conditionals and figuring out it is a memcpy operation.\u003c/p\u003e\u003cp\u003eI have realized that it is also much faster for me to research topics I don\u0026#x27;t have enough experience with or knowledge in.\nThe best part being that you can get a great answer right away without sorting through a bunch of search results and then easily drill down into topics mentioned there by asking further questions.\u003c/p\u003e\u003cp\u003eOr in one case recently, helping me to understand best practices in GoLang for specific tasks.\u003c/p\u003e\u003cp\u003eI was reading through some GoLang code making heavy use of goroutines.\nI realized this function was just iterating over a list of values, asynchronously collecting the results, and then returning the reaults once all of the async operations had finished. \u003c/p\u003e\u003cp\u003eIn JS, an example of something \u0026quot;similar\u0026quot; with NodeJS could be:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\n  async function makeAPIRequestToGetUserProfile(userId) { /* make http request, etc.. */ }\n  const userIds = [0, 1, 2];\n  const profileDataOfUsers = await Promise.all(userIds.map( id =\u0026gt; makeAPIRequestToGetUserProfile(id) ));\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe existing implementation I read used a few GoLang primitves that I had not used before. I have not written a ton of GoLang code, have a lot I could learn, and when I am using GoLang for work I am often worried about whether or not I am following best practices.\u003c/p\u003e\u003cp\u003eReading this GoLang function I was able to make assumptions and by reading the amazingly well documented GoLang code base\u0026#x27;s inline documentation, then further determine exactly how the function worked.\u003c/p\u003e\u003cp\u003eNow I still wanted to verify my understanding and I was curious if the pattern used in this code was what would be considered as following GoLang best practices.\u003c/p\u003e\u003cp\u003eSo next I asked ChatGPT to write me a function that did what I had determined the code I was reading did.\u003c/p\u003e\u003cp\u003eI was then given an amazing response which gave me an example making use of all the same GoLang synchronization and concurrency primitives. What I appreciated the most was that this result was a simple example that allowed me to focus on the GoLang primitives and patterns.\u003c/p\u003e\u003cp\u003eThe result was so close to the code I had been reading that I was also able to realize I had missed some functionality in my first \u0026quot;mental summary\u0026quot; of how this code worked.\u003c/p\u003e\u003cp\u003eNot only was it spawning threads/goroutines to collect data in parallel but it also was checking to see if it should stop by checking the passed Context.\u003c/p\u003e\u003cdiv style=\"position:relative\"\u003e\u003cspan style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\"\u003e#\u003c/span\u003e\u003ch3 id=\"The%20First%20Attempt\" class=\"jsx-2373991563\"\u003e\u003ca href=\"#The%20First%20Attempt\" class=\"jsx-2373991563\"\u003eThe First Attempt\u003c/a\u003e\u003c/h3\u003e\u003c/div\u003e\u003cp\u003eSo with my first ChatGPT question being:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e  Write me an example GoLang function that collects results from multiple goroutines and returns the list of results\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI recieved a nice example:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e  package main\n\n  import (\n    \u0026quot;fmt\u0026quot;\n    \u0026quot;sync\u0026quot;\n  )\n\n  func worker(id int, wg *sync.WaitGroup, results chan int) {\n    defer wg.Done()\n    results \u0026lt;- id * 2\n  }\n\n  func collectResults(n int) []int {\n    var wg sync.WaitGroup\n    results := make(chan int, n)\n\n    for i := 0; i \u0026lt; n; i++ {\n      wg.Add(1)\n      go worker(i, \u0026amp;wg, results)\n    }\n\n    wg.Wait()\n    close(results)\n\n    var resultList []int\n    for res := range results {\n      resultList = append(resultList, res)\n    }\n\n    return resultList\n  }\n\n  func main() {\n    resultList := collectResults(10)\n    fmt.Println(resultList)\n  }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe description of the code by ChatGPT was also somewhat helpful. Although reading the GoLang codebase\u0026#x27;s inline documentation provided a much better understanding and was easy to find with VSCode taking me directly to the definiton.\nChatGPT\u0026#x27;s code description:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e  This example uses a sync.WaitGroup to wait for all the goroutines to complete and a channel results to collect the results from each goroutine. The function worker takes an ID and a WaitGroup pointer, and sends its result to the results channel. The collectResults function starts n worker goroutines, waits for all of them to finish using the WaitGroup, closes the results channel, and collects all the results into a slice.\n``\n\n### Same Question, Different Results\n\nWhen asking the same question I actually get a slightly different implementation:\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e  package main\u003c/p\u003e\u003cp\u003e  import (\n\u0026quot;fmt\u0026quot;\n\u0026quot;sync\u0026quot;\n)\u003c/p\u003e\u003cp\u003e  func collectResults(n int) []int {\nvar wg sync.WaitGroup\nresults := make([]int, 0, n)\nresultCh := make(chan int)\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efor i := 0; i \u0026lt; n; i++ {\n  wg.Add(1)\n  go func(i int) {\n    defer wg.Done()\n    resultCh \u0026lt;- i\n  }(i)\n}\n\ngo func() {\n  wg.Wait()\n  close(resultCh)\n}()\n\nfor res := range resultCh {\n  results = append(results, res)\n}\n\nreturn results\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e  }\u003c/p\u003e\u003cp\u003e  func main() {\nresults := collectResults(5)\nfmt.Println(results)\n}\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\nGetting this different result was actually really helpful. The first thing I saw, and was actually wondering about with other code I read, was that there was a separate goroutine dedicated to just waiting for the WaitGroup count to decrement to 0 before closing the channel:\n\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003ego func() {\n  wg.Wait()\n  close(resultCh)\n}()\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e\nWithout seeing this different result I would not have learned that unless you create a \u0026quot;buffered\u0026quot; channel sending on the channel will block. As the docs say, that:\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e  Sends to a buffered channel block only when the buffer is full.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\nThis is why the first response from ChatGPT was a little simpler and didn\u0026#x27;t require the extra goroutine. It creates a channel, buffered to size n:\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e  results := make(chan int, n)\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\n### Getting Slightly More Complicated\n\nNow I wanted to see how close of an example I could get to the code I was reading. The code I was reading also took a Context and checked for cancellation.\nBuilding on my previous ChatGPT question with:\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e  The function collectResults should use a GoLang Context and check if it was cancelled to stop the process of collecting results.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\nThe result I get back is exactly what I was hoping for, if not better. Illustrating how Context can be used to check for cancellation.\n\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e  package main\u003c/p\u003e\u003cp\u003e  import (\n\u0026quot;context\u0026quot;\n\u0026quot;fmt\u0026quot;\n\u0026quot;sync\u0026quot;\n)\u003c/p\u003e\u003cp\u003e  func collectResults(ctx context.Context, n int) []int {\nvar wg sync.WaitGroup\nresults := make([]int, 0, n)\nresultCh := make(chan int)\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efor i := 0; i \u0026lt; n; i++ {\n  wg.Add(1)\n  go func(i int) {\n    defer wg.Done()\n    select {\n    case \u0026lt;-ctx.Done():\n      return\n    case resultCh \u0026lt;- i:\n    }\n  }(i)\n}\n\ngo func() {\n  wg.Wait()\n  close(resultCh)\n}()\n\nfor {\n  select {\n  case \u0026lt;-ctx.Done():\n    return results\n  case res, ok := \u0026lt;-resultCh:\n    if !ok {\n      return results\n    }\n    results = append(results, res)\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e  }\u003c/p\u003e\u003cp\u003e  func main() {\nctx, cancel := context.WithCancel(context.Background())\ndefer cancel()\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eresults := collectResults(ctx, 5)\nfmt.Println(results)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e  }\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\nThe explanation by ChatGPT is also great and had I not already read the documentation would have been enough information to understand how this code works:\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e  In this example, the collectResults function creates a channel resultCh for collecting results from the goroutines, launches n number of goroutines, each sending its index to the channel, and increments a wait group for each goroutine. It also includes a select statement with the Context\u0026#x27;s Done channel to check if the Context has been cancelled and return early if so. Then, it launches a goroutine that waits for all goroutines to finish and closes the result channel. Finally, the main function collects the results from the channel by range over it with a select statement that also checks the Context\u0026#x27;s Done channel to return early if the Context is cancelled.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\n### Asking for an Explanation for the Original Code\n\nI also tried asking for an explanation of the original code (just one function) which contained references to types and interfaces defined elsewhere.\n\nWhat I think is most impressive here is that it was able to infer how some interfaces were used just from the name scheme. \nThe rest of the actual explanation was perfect as well.\n\n### In summary\n\nI would probably save a lot of time if I just spent a little time practicing querying/prompting ChatGPT when researching something.\nGoogle is so full of poorly written Medium posts, all with duplicate content, that researching can be done quicker and more accurately with ChatGPT in many cases.\n\nSpecifically with GoLang, the documentation in the code and official documentation online is well written/done that I should probably just never leave those resources.\nBut I plan on trying to take more advantage of this personally.\n\u003c/code\u003e\u003c/pre\u003e","scope":{"slug":"learning-from-and-verification-with-chatgpt","title":"Learning From and Verification with ChatGPT","date":"2023-02-06","author":"bebrws","tags":["GoLang","ChatGPT","Learning","Machine Learning","ML"]}}},"__N_SSG":true},"page":"/posts/[post]","query":{"post":"learning-from-and-verification-with-chatgpt"},"buildId":"nENEKRtsitJh7ixPHU9Bl","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>