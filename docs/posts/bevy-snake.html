<!DOCTYPE html><html><head><script type="text/javascript" class="jsx-707554062">
          
          function loadBevySnake() {
            setTimeout(function() {
            var element = document.getElementById('bevy-portal');
                  if (element) {
                    console.log('Element with id "bevy-portal" exists. Adding script tag.');

                  var script = document.createElement('script');
                  script.type = 'module';
                  script.src = '../static/load-bevy-snake.js';
                  document.head.appendChild(script);
            } else {
                    console.log('Element with id "bevy-portal" does not exist.');
                    loadBevySnake();
            }
          }, 500);
        }

        loadBevySnake();
      </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=UA-154810525-2" class="jsx-707554062"></script><script type="text/javascript" class="jsx-707554062">
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'UA-154810525-2');
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-BZKS5D8HPF" class="jsx-707554062"></script><script type="text/javascript" class="jsx-707554062">
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-BZKS5D8HPF');
        </script><meta charSet="utf-8" class="jsx-707554062"/><meta name="viewport" content="width=device-width, initial-scale=1" class="jsx-707554062"/><link rel="manifest" href="/site.webmanifest" class="jsx-707554062"/><link rel="apple-touch-icon" href="/icon.png" class="jsx-707554062"/><meta name="theme-color" content="#fff" class="jsx-707554062"/><title>Creating a Snake Game Clone with Rust/Bevy | Brad Barrows&#x27; Blog</title><meta name="description" content="Brad Barrows&#x27; Blog"/><link rel="canonical" href="https://bbarrows.com/posts/bevy-snake"/><meta property="og:site_name" content="Brad Barrows&#x27; Blog"/><meta property="og:url" content="https://bbarrows.com/posts/bevy-snake"/><meta property="og:title" content="Creating a Snake Game Clone with Rust/Bevy | Brad Barrows&#x27; Blog"/><meta property="og:description" content="Brad Barrows&#x27; Blog"/><meta property="og:image" content="https://bbarrows.com/og_image.png"/><meta property="og:type" content="article"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":"https://bbarrows.com/posts/bevy-snake","headline":"Creating a Snake Game Clone with Rust/Bevy","datePublished":"2024-02-19T00:00:00-08:00","author":"Brad Barrows","description":""}</script><meta name="next-head-count" content="20"/><link rel="preload" href="/_next/static/css/8e11f38ccf46f6277e39.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e11f38ccf46f6277e39.css" data-n-g=""/><link rel="preload" href="/_next/static/css/08c00d6a07e310229cb0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08c00d6a07e310229cb0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-f47d69457824065d04c3.js" defer=""></script><script src="/_next/static/chunks/framework-895f067827ebe11ffe45.js" defer=""></script><script src="/_next/static/chunks/main-d32200c037819e7e8fa0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-eae7af63eb651790e0a7.js" defer=""></script><script src="/_next/static/chunks/962-b2e3b32260744832b5cf.js" defer=""></script><script src="/_next/static/chunks/189-6fa1af65347fdf66ab7b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpost%5D-798896a96beb46d3eaba.js" defer=""></script><script src="/_next/static/ZiYYe9iDwc-NJSd5b0k2E/_buildManifest.js" defer=""></script><script src="/_next/static/ZiYYe9iDwc-NJSd5b0k2E/_ssgManifest.js" defer=""></script><style id="__jsx-2373991563">a.jsx-2373991563{color:inherit;-webkit-text-decoration:none;text-decoration:none;}a.jsx-2373991563:hover{-webkit-text-decoration:underline;text-decoration:underline;}</style><style id="__jsx-3058196896">.container.jsx-3058196896{position:fixed;width:38px;height:38px;cursor:pointer;top:1rem;left:1.25rem;z-index:2;background-color:rgba(255,255,255,0.7);}.meat.jsx-3058196896{position:absolute;width:28px;height:2px;background:#222;top:calc(50% - 2px / 2);left:calc(50% - 28px / 2);-webkit-transition:all 150ms ease-in;transition:all 150ms ease-in;}.meat-1.jsx-3058196896{-webkit-transform:translateY(-10px);-ms-transform:translateY(-10px);transform:translateY(-10px);}.meat-2.jsx-3058196896{width:calc(28px - 6px);}.meat-3.jsx-3058196896{-webkit-transform:translateY(10px);-ms-transform:translateY(10px);transform:translateY(10px);}.active.jsx-3058196896 .meat-1.jsx-3058196896{-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);transform:rotate(45deg);}.active.jsx-3058196896 .meat-2.jsx-3058196896{opacity:0;}.active.jsx-3058196896 .meat-3.jsx-3058196896{-webkit-transform:rotate(-45deg);-ms-transform:rotate(-45deg);transform:rotate(-45deg);}@media (min-width:769px){.container.jsx-3058196896{display:none;}}</style><style id="__jsx-4138737674">.container.jsx-4138737674{width:0;}ul.jsx-4138737674{opacity:0;width:100%;height:100vh;text-align:right;list-style:none;margin:0;padding:0;position:fixed;top:0;background-color:#fff;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;z-index:1;-webkit-transform:translateY(100%);-ms-transform:translateY(100%);transform:translateY(100%);-webkit-transition:opacity 200ms;transition:opacity 200ms;}.active.jsx-4138737674 ul.jsx-4138737674{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);transform:translateY(0);}li.jsx-4138737674{margin-bottom:1.75rem;font-size:2rem;padding:0 1.5rem 0 0;}li.jsx-4138737674:last-child{margin-bottom:0;}.active.jsx-4138737674{color:#222;}@media (min-width:769px){.container.jsx-4138737674{width:7rem;display:block;}ul.jsx-4138737674{opacity:1;width:7rem;top:auto;display:block;-webkit-transform:translateY(0);-ms-transform:translateY(0);transform:translateY(0);}li.jsx-4138737674{font-size:1rem;padding:0;}}</style><style id="__jsx-3674465219">span.jsx-3674465219{color:#9b9b9b;}</style><style id="__jsx-255066894">a.jsx-255066894{display:inline-block;}a.jsx-255066894:not(:last-child){margin-right:2em;}</style><style id="__jsx-3618008669">p.jsx-3618008669{font-size:0.75rem;text-align:center;}</style><style id="__jsx-4153080612">.container.jsx-3387257903{display:block;max-width:60rem;width:100%;margin:0 auto;padding:0 1.5rem;box-sizing:border-box;z-index:0;}.metadata.jsx-3387257903 div.jsx-3387257903{display:inline-block;margin-right:0.5rem;}article.jsx-3387257903{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;}h1.jsx-3387257903{margin:0 0 0.5rem;font-size:2.25rem;}.tag-list.jsx-3387257903{list-style:none;text-align:right;margin:1.75rem 0 0 0;padding:0;}.tag-list.jsx-3387257903 li.jsx-3387257903{display:inline-block;margin-left:0.5rem;}.social-list.jsx-3387257903{margin-top:3rem;text-align:center;}@media (min-width:769px){.container.jsx-3387257903{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}</style><style id="__jsx-1699270818">.token.comment,.token.prolog,.token.doctype,.token.cdata,.token.plain-text{color:#6a737d;}.token.atrule,.token.attr-value,.token.keyword,.token.operator{color:#d73a49;}.token.property,.token.tag,.token.boolean,.token.number,.token.constant,.token.symbol,.token.deleted{color:#22863a;}.token.selector,.token.attr-name,.token.string,.token.char,.token.builtin,.token.inserted{color:#032f62;}.token.function,.token.class-name{color:#6f42c1;}.language-jsx .token.punctuation,.language-jsx .token.tag .token.punctuation,.language-jsx .token.tag .token.script,.language-jsx .token.plain-text{color:#24292e;}.language-jsx .token.tag .token.attr-name{color:#6f42c1;}.language-jsx .token.tag .token.class-name{color:#005cc5;}.language-jsx .token.tag .token.script-punctuation,.language-jsx .token.attr-value .token.punctuation:first-child{color:#d73a49;}.language-jsx .token.attr-value{color:#032f62;}.language-jsx span[class="comment"]{color:pink;}.language-html .token.tag .token.punctuation{color:#24292e;}.language-html .token.tag .token.attr-name{color:#6f42c1;}.language-html .token.tag .token.attr-value,.language-html .token.tag .token.attr-value .token.punctuation:not(:first-child){color:#032f62;}.language-css .token.selector{color:#6f42c1;}.language-css .token.property{color:#005cc5;}</style><style id="__jsx-707554062">.root.jsx-707554062{display:block;padding:4rem 0;box-sizing:border-box;height:100%;}main.jsx-707554062{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;min-height:100%;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}@media (min-width:769px){.root.jsx-707554062{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;}main.jsx-707554062{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;}}</style></head><body><div id="__next"><div class="jsx-707554062 root"><nav class="jsx-707554062"><div class="jsx-3058196896 container "><div class="jsx-3058196896 meat meat-1"></div><div class="jsx-3058196896 meat meat-2"></div><div class="jsx-3058196896 meat meat-3"></div></div><div class="jsx-4138737674 container "><ul class="jsx-4138737674"><li class="jsx-4138737674"><a class="jsx-4138737674 " href="/">about</a></li><li class="jsx-4138737674"><a class="jsx-4138737674 " href="/projects">projects</a></li><li class="jsx-4138737674"><a class="jsx-4138737674 active" href="/posts">blog</a></li></ul></div></nav><main class="jsx-707554062"><div class="jsx-3387257903 container"><article class="jsx-3387257903"><header class="jsx-3387257903"><h1 class="jsx-3387257903">Creating a Snake Game Clone with Rust/Bevy</h1><div class="jsx-3387257903 metadata"><div class="jsx-3387257903"><time dateTime="2024-02-19T00:00:00-08:00" class="jsx-3674465219"><span class="jsx-3674465219">February 19, 2024</span></time></div><div class="jsx-3387257903"><span class="jsx-3674465219">Brad Barrows</span></div></div></header><div class="jsx-3387257903 content_content__1yuPc"><div><div style="position:relative"><span style="position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b">#</span><h1 id="Rust%20Practice%20with%20Bevy" class="jsx-2373991563"><a href="#Rust%20Practice%20with%20Bevy" class="jsx-2373991563">Rust Practice with Bevy</a></h1></div><p>Bevy has an amazing dependency injection system that makes its &quot;ECS&quot; (Entity Component System) architecture very easy and ituitive to use.
Really the DI system is one of the most amazing Rust feats that I have seen so far.</p><p>Someone has taken the time to document how to create your own <a href="https://promethia-27.github.io/dependency_injection_like_bevy_from_scratch/chapter1/system.html">Bevy based DI system here which is a great read</a></p><p>There is also an unofficial Bevy book that is really helpful <a href="https://bevy-cheatbook.github.io/programming/intro-data.html">here</a></p><div style="position:relative"><span style="position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b">#</span><h2 id="Bevy%20and%20ECS" class="jsx-2373991563"><a href="#Bevy%20and%20ECS" class="jsx-2373991563">Bevy and ECS</a></h2></div><p>ECS is documented <a href="https://bevyengine.org/learn/quick-start/getting-started/ecs/">here</a>
It describes some of the basic concepts of how the Bevy game engine works. Combined with a powerful dependency injection (DI) system, Bevy is powerful, easy to work with, and fun to use.</p><p>For my snake game I only needed the concept of three entities really: the snake, the food, and the snake&#x27;s body.</p><p>This is done by the C part of ECS. I create a Component for each. This allows me to, later on, using the DI/query system executed on each game loop, to find all the entities of a certain type and do something with them.</p><p>On setup, I create the snake and the food using a spawn command. It takes a tuple where I can provide multiple Components that make up whatever entity I am creating.</p><p>Each of the described objects above have a visual aspect for example, so each have a 2D mesh (which includes a transform/translation aka location).</p><p>Here is where I create the SnakeHead for example:</p><pre><code>    let head_mesh = Mesh2dHandle(meshes.add(Rectangle::new(OBJECT_SIZE, OBJECT_SIZE)));
    let box_color = Color::rgb(0.8, 0.2, 0.1);
    commands.spawn((
        MaterialMesh2dBundle {
            mesh: head_mesh,
            material: materials.add(box_color),
            transform: Transform::from_translation(Vec3::new(0.0, 0.0, 0.0)),
            ..default()
        },
        SnakeHead {
            direction: Direction::Up,
        },
    ));
</code></pre><p>The most amazing part of Bevy though that I have found so far is its &quot;query&quot;/DI system. With types and traits, I can query for all the entities of a certain type and do something with them each step of the game loop.</p><p>This is the function signature I have for checking for collisions for ex:</p><pre><code>fn check_collisions(
    mut commands: Commands,
    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,
    mut materials: ResMut&lt;Assets&lt;ColorMaterial&gt;&gt;,
    mut apple_query: Query&lt;(&amp;mut Transform), (With&lt;Apple&gt;, Without&lt;SnakeHead&gt;, Without&lt;SnakeBody&gt;)&gt;,
    mut snake_head_query: Query&lt;(&amp;mut Transform, &amp;mut SnakeHead)&gt;,
    mut snake_body_query: Query&lt;(&amp;mut Transform, Entity), (With&lt;SnakeBody&gt;, Without&lt;SnakeHead&gt;)&gt;,
</code></pre><p>This function signature can be however long.</p><p>The DI system will provide me with whatever objects I need. Commands, meshes, materials, etc.. As well as decipher a simple to work with type system to provide me with all the entities that match a specific query.</p><p>For example, with the snake body. I want to be able to move each one and also remove them if the snake crashes. To move them I just need their Transform (part of what was provided from the MaterialMesh2dBundle during setup) and the Entity itself so I can send a command to despawn them or remove body parts from the game.</p><p>The DI system that powers all this is amazing to me. I had no idea this could be accomplished in Rust until someone from the Bevy Discord chat kindly pointed me to this documentation which breaks down <a href="https://promethia-27.github.io/dependency_injection_like_bevy_from_scratch/chapter1/system.html">how it all works</a>.</p><div style="position:relative"><span style="position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b">#</span><h2 id="Reading%20and%20Learning%20the%20Complicated%20Macros%20from%20the%20DI%20System%20Mentioned%20Above" class="jsx-2373991563"><a href="#Reading%20and%20Learning%20the%20Complicated%20Macros%20from%20the%20DI%20System%20Mentioned%20Above" class="jsx-2373991563">Reading and Learning the Complicated Macros from the DI System Mentioned Above</a></h2></div><p>If you take the example from the end of page 3 in the DI like Bevy from Scratch book, you can use cargo expand to see what the macro is doing.</p><p>I created a new project and added the macro to the main.rs file. Then I ran cargo expand and it showed me the expanded macro created unsugared Rust code which made understanding the macros and the documentation much easier to understand.</p><p>To install cargo expand run: <code>cargo install cargo-expand</code></p><p>The code I ran
<code>cargo expand &gt; expanded.rs</code>
on is:</p><pre><code>struct FunctionSystem&lt;Input, F&gt; {
    f: F,
    marker: PhantomData&lt;fn() -&gt; Input&gt;,
}

trait System {
    fn run(&amp;mut self, resources: &amp;mut HashMap&lt;TypeId, Box&lt;dyn Any&gt;&gt;);
}

macro_rules! impl_system {
    (
        $(
            $($params:ident),+
        )?
    ) =&gt; {
        #[allow(non_snake_case, unused)]
        impl&lt;
            F: FnMut(
                $( $($params),+ )?
            )
            $(, $($params: &#x27;static),+ )?
        &gt; System for FunctionSystem&lt;($( $($params,)+ )?), F&gt; {
            fn run(&amp;mut self, resources: &amp;mut HashMap&lt;TypeId, Box&lt;dyn Any&gt;&gt;) {
                $($(
                    let $params = *resources.remove(&amp;TypeId::of::&lt;$params&gt;()).unwrap().downcast::&lt;$params&gt;().unwrap();
                )+)?

                (self.f)(
                    $($($params),+)?
                );
            }
        }
    }
}

impl_system!();
impl_system!(T1);
impl_system!(T1, T2);
impl_system!(T1, T2, T3);
impl_system!(T1, T2, T3, T4);

trait IntoSystem&lt;Input&gt; {
    type System: System;

    fn into_system(self) -&gt; Self::System;
}

macro_rules! impl_into_system {
    (
        $($(
                $params:ident
        ),+)?
    ) =&gt; {
        impl&lt;F: FnMut($($($params),+)?) $(, $($params: &#x27;static),+ )?&gt; IntoSystem&lt;( $($($params,)+)? )&gt; for F {
            type System = FunctionSystem&lt;( $($($params,)+)? ), Self&gt;;

            fn into_system(self) -&gt; Self::System {
                FunctionSystem {
                    f: self,
                    marker: Default::default(),
                }
            }
        }
    }
}

impl_into_system!();
impl_into_system!(T1);
impl_into_system!(T1, T2);
impl_into_system!(T1, T2, T3);
impl_into_system!(T1, T2, T3, T4);

type StoredSystem = Box&lt;dyn System&gt;;

struct Scheduler {
    systems: Vec&lt;StoredSystem&gt;,
    resources: HashMap&lt;TypeId, Box&lt;dyn Any&gt;&gt;,
}

impl Scheduler {
    pub fn run(&amp;mut self) {
        for system in self.systems.iter_mut() {
            system.run(&amp;mut self.resources);
        }
    }

    pub fn add_system&lt;I, S: System + &#x27;static&gt;(&amp;mut self, system: impl IntoSystem&lt;I, System = S&gt;) {
        self.systems.push(Box::new(system.into_system()));
    }

    pub fn add_resource&lt;R: &#x27;static&gt;(&amp;mut self, res: R) {
        self.resources.insert(TypeId::of::&lt;R&gt;(), Box::new(res));
    }
}

fn main() {
    let mut scheduler = Scheduler {
        systems: vec![],
        resources: HashMap::default(),
    };

    scheduler.add_system(foo);
    scheduler.add_resource(12i32);

    scheduler.run();
}

fn foo(int: i32) {
    println!(&quot;int! {int}&quot;);
}
</code></pre><div style="position:relative"><span style="position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b">#</span><h1 id="My%20Snake%20Clone" class="jsx-2373991563"><a href="#My%20Snake%20Clone" class="jsx-2373991563">My Snake Clone</a></h1></div><p>Can be found <a href="https://github.com/bebrws/bevy-snake">here</a></p><div style="position:relative"><span style="position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b">#</span><h1 id="And%20Compiled%20to%20WASM%20and%20Played%20Here%21%20%28Only%20on%20WASM%20supported%20browsers%20%2d%20so%20no%20mobile%29" class="jsx-2373991563"><a href="#And%20Compiled%20to%20WASM%20and%20Played%20Here%21%20%28Only%20on%20WASM%20supported%20browsers%20%2d%20so%20no%20mobile%29" class="jsx-2373991563">And Compiled to WASM and Played Here! (Only on WASM supported browsers - so no mobile)</a></h1></div><canvas id="bevy-portal" tabindex="0" data-raw-handle="1" alt="app" cursor="auto"></canvas></div></div></article><footer class="jsx-3387257903"><div class="jsx-3387257903 social-list"><div class="jsx-255066894"><a title="LinkedIn" href="https://www.linkedin.com/in/bbarrows/}" target="_blank" rel="noopener" class="jsx-255066894"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#222"><path fill="#444" d="M5.453 11.099v15.484H.297V11.099h5.156zm.328-4.781q.016 1.141-.789 1.906t-2.117.766h-.031q-1.281 0-2.063-.766T0 6.318q0-1.156.805-1.914t2.102-.758 2.078.758.797 1.914zM24 17.708v8.875h-5.141v-8.281q0-1.641-.633-2.57t-1.977-.93q-.984 0-1.648.539t-.992 1.336q-.172.469-.172 1.266v8.641H8.296q.031-6.234.031-10.109t-.016-4.625l-.016-.75h5.141v2.25h-.031q.312-.5.641-.875t.883-.812 1.359-.68 1.789-.242q2.672 0 4.297 1.773t1.625 5.195z"></path></svg></a><a title="GitHub" href="https://github.com/bebrws/" target="_blank" rel="noopener" class="jsx-255066894"><svg viewBox="0 0 11 11" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2" width="24" height="24" fill="#222"><path d="M10.5 5.63a4.992 4.992 0 01-.977 3.016A5.018 5.018 0 016.998 10.5c-.12.022-.207.007-.263-.047a.267.267 0 01-.083-.2v-1.41c0-.432-.116-.748-.347-.948.253-.027.481-.067.683-.12.203-.054.412-.14.627-.26.216-.121.396-.27.54-.445.145-.176.263-.41.354-.702.091-.291.137-.626.137-1.005a1.95 1.95 0 00-.527-1.376c.164-.405.147-.86-.053-1.363-.125-.04-.305-.015-.54.074a3.59 3.59 0 00-.614.294l-.254.16a4.727 4.727 0 00-1.28-.174c-.44 0-.867.058-1.28.174a5.931 5.931 0 00-.284-.18 3.995 3.995 0 00-.557-.258c-.254-.1-.445-.13-.574-.09-.195.504-.211.958-.046 1.363a1.95 1.95 0 00-.527 1.376c0 .379.045.713.136 1.002.092.29.208.523.35.702.143.178.322.327.537.447.216.12.425.207.627.26.203.054.43.094.684.12-.178.161-.287.39-.327.689a1.32 1.32 0 01-.3.1 1.885 1.885 0 01-.38.034A.785.785 0 013 8.573a1.177 1.177 0 01-.37-.418 1.077 1.077 0 00-.324-.347.973.973 0 00-.33-.16l-.133-.02a.432.432 0 00-.194.03c-.035.02-.046.045-.033.077a.487.487 0 00.147.174l.046.033c.098.044.195.129.29.254.096.124.166.238.21.34l.067.154c.058.17.156.306.294.41.138.105.287.172.447.201.16.029.314.045.463.047a1.96 1.96 0 00.37-.024l.154-.026a62.026 62.026 0 00.007.955c0 .08-.03.147-.087.2-.058.054-.147.07-.267.047a5.018 5.018 0 01-2.524-1.854A4.992 4.992 0 01.255 5.63c0-.93.23-1.789.687-2.575a5.103 5.103 0 011.865-1.867A5.005 5.005 0 015.377.5c.93 0 1.787.23 2.572.688a5.103 5.103 0 011.864 1.867c.458.786.687 1.645.687 2.575z" fill="#444" fill-rule="nonzero"></path></svg></a></div></div><p class="jsx-3618008669">© 2021</p></footer></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Creating a Snake Game Clone with Rust/Bevy","dateString":"2024-02-19","slug":"bevy-snake","description":"","tags":["Rust","bevy","WASM","WebAssembly","game"],"author":"bebrws","source":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i \u003c arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i \u003c sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i \u003c sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Rust Practice with Bevy\"), mdx(\"p\", null, \"Bevy has an amazing dependency injection system that makes its \\\"ECS\\\" (Entity Component System) architecture very easy and ituitive to use.\\nReally the DI system is one of the most amazing Rust feats that I have seen so far.\"), mdx(\"p\", null, \"Someone has taken the time to document how to create your own \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://promethia-27.github.io/dependency_injection_like_bevy_from_scratch/chapter1/system.html\"\n  }, \"Bevy based DI system here which is a great read\")), mdx(\"p\", null, \"There is also an unofficial Bevy book that is really helpful \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://bevy-cheatbook.github.io/programming/intro-data.html\"\n  }, \"here\")), mdx(\"h2\", null, \"Bevy and ECS\"), mdx(\"p\", null, \"ECS is documented \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://bevyengine.org/learn/quick-start/getting-started/ecs/\"\n  }, \"here\"), \"\\nIt describes some of the basic concepts of how the Bevy game engine works. Combined with a powerful dependency injection (DI) system, Bevy is powerful, easy to work with, and fun to use.\"), mdx(\"p\", null, \"For my snake game I only needed the concept of three entities really: the snake, the food, and the snake's body.\"), mdx(\"p\", null, \"This is done by the C part of ECS. I create a Component for each. This allows me to, later on, using the DI/query system executed on each game loop, to find all the entities of a certain type and do something with them.\"), mdx(\"p\", null, \"On setup, I create the snake and the food using a spawn command. It takes a tuple where I can provide multiple Components that make up whatever entity I am creating.\"), mdx(\"p\", null, \"Each of the described objects above have a visual aspect for example, so each have a 2D mesh (which includes a transform/translation aka location).\"), mdx(\"p\", null, \"Here is where I create the SnakeHead for example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"    let head_mesh = Mesh2dHandle(meshes.add(Rectangle::new(OBJECT_SIZE, OBJECT_SIZE)));\\n    let box_color = Color::rgb(0.8, 0.2, 0.1);\\n    commands.spawn((\\n        MaterialMesh2dBundle {\\n            mesh: head_mesh,\\n            material: materials.add(box_color),\\n            transform: Transform::from_translation(Vec3::new(0.0, 0.0, 0.0)),\\n            ..default()\\n        },\\n        SnakeHead {\\n            direction: Direction::Up,\\n        },\\n    ));\\n\")), mdx(\"p\", null, \"The most amazing part of Bevy though that I have found so far is its \\\"query\\\"/DI system. With types and traits, I can query for all the entities of a certain type and do something with them each step of the game loop.\"), mdx(\"p\", null, \"This is the function signature I have for checking for collisions for ex:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"fn check_collisions(\\n    mut commands: Commands,\\n    mut meshes: ResMut\u003cAssets\u003cMesh\u003e\u003e,\\n    mut materials: ResMut\u003cAssets\u003cColorMaterial\u003e\u003e,\\n    mut apple_query: Query\u003c(\u0026mut Transform), (With\u003cApple\u003e, Without\u003cSnakeHead\u003e, Without\u003cSnakeBody\u003e)\u003e,\\n    mut snake_head_query: Query\u003c(\u0026mut Transform, \u0026mut SnakeHead)\u003e,\\n    mut snake_body_query: Query\u003c(\u0026mut Transform, Entity), (With\u003cSnakeBody\u003e, Without\u003cSnakeHead\u003e)\u003e,\\n\")), mdx(\"p\", null, \"This function signature can be however long.\"), mdx(\"p\", null, \"The DI system will provide me with whatever objects I need. Commands, meshes, materials, etc.. As well as decipher a simple to work with type system to provide me with all the entities that match a specific query.\"), mdx(\"p\", null, \"For example, with the snake body. I want to be able to move each one and also remove them if the snake crashes. To move them I just need their Transform (part of what was provided from the MaterialMesh2dBundle during setup) and the Entity itself so I can send a command to despawn them or remove body parts from the game.\"), mdx(\"p\", null, \"The DI system that powers all this is amazing to me. I had no idea this could be accomplished in Rust until someone from the Bevy Discord chat kindly pointed me to this documentation which breaks down \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://promethia-27.github.io/dependency_injection_like_bevy_from_scratch/chapter1/system.html\"\n  }, \"how it all works\"), \".\"), mdx(\"h2\", null, \"Reading and Learning the Complicated Macros from the DI System Mentioned Above\"), mdx(\"p\", null, \"If you take the example from the end of page 3 in the DI like Bevy from Scratch book, you can use cargo expand to see what the macro is doing.\"), mdx(\"p\", null, \"I created a new project and added the macro to the main.rs file. Then I ran cargo expand and it showed me the expanded macro created unsugared Rust code which made understanding the macros and the documentation much easier to understand.\"), mdx(\"p\", null, \"To install cargo expand run: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo install cargo-expand\")), mdx(\"p\", null, \"The code I ran\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo expand \u003e expanded.rs\"), \"\\non is:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"struct FunctionSystem\u003cInput, F\u003e {\\n    f: F,\\n    marker: PhantomData\u003cfn() -\u003e Input\u003e,\\n}\\n\\ntrait System {\\n    fn run(\u0026mut self, resources: \u0026mut HashMap\u003cTypeId, Box\u003cdyn Any\u003e\u003e);\\n}\\n\\nmacro_rules! impl_system {\\n    (\\n        $(\\n            $($params:ident),+\\n        )?\\n    ) =\u003e {\\n        #[allow(non_snake_case, unused)]\\n        impl\u003c\\n            F: FnMut(\\n                $( $($params),+ )?\\n            )\\n            $(, $($params: 'static),+ )?\\n        \u003e System for FunctionSystem\u003c($( $($params,)+ )?), F\u003e {\\n            fn run(\u0026mut self, resources: \u0026mut HashMap\u003cTypeId, Box\u003cdyn Any\u003e\u003e) {\\n                $($(\\n                    let $params = *resources.remove(\u0026TypeId::of::\u003c$params\u003e()).unwrap().downcast::\u003c$params\u003e().unwrap();\\n                )+)?\\n\\n                (self.f)(\\n                    $($($params),+)?\\n                );\\n            }\\n        }\\n    }\\n}\\n\\nimpl_system!();\\nimpl_system!(T1);\\nimpl_system!(T1, T2);\\nimpl_system!(T1, T2, T3);\\nimpl_system!(T1, T2, T3, T4);\\n\\ntrait IntoSystem\u003cInput\u003e {\\n    type System: System;\\n\\n    fn into_system(self) -\u003e Self::System;\\n}\\n\\nmacro_rules! impl_into_system {\\n    (\\n        $($(\\n                $params:ident\\n        ),+)?\\n    ) =\u003e {\\n        impl\u003cF: FnMut($($($params),+)?) $(, $($params: 'static),+ )?\u003e IntoSystem\u003c( $($($params,)+)? )\u003e for F {\\n            type System = FunctionSystem\u003c( $($($params,)+)? ), Self\u003e;\\n\\n            fn into_system(self) -\u003e Self::System {\\n                FunctionSystem {\\n                    f: self,\\n                    marker: Default::default(),\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nimpl_into_system!();\\nimpl_into_system!(T1);\\nimpl_into_system!(T1, T2);\\nimpl_into_system!(T1, T2, T3);\\nimpl_into_system!(T1, T2, T3, T4);\\n\\ntype StoredSystem = Box\u003cdyn System\u003e;\\n\\nstruct Scheduler {\\n    systems: Vec\u003cStoredSystem\u003e,\\n    resources: HashMap\u003cTypeId, Box\u003cdyn Any\u003e\u003e,\\n}\\n\\nimpl Scheduler {\\n    pub fn run(\u0026mut self) {\\n        for system in self.systems.iter_mut() {\\n            system.run(\u0026mut self.resources);\\n        }\\n    }\\n\\n    pub fn add_system\u003cI, S: System + 'static\u003e(\u0026mut self, system: impl IntoSystem\u003cI, System = S\u003e) {\\n        self.systems.push(Box::new(system.into_system()));\\n    }\\n\\n    pub fn add_resource\u003cR: 'static\u003e(\u0026mut self, res: R) {\\n        self.resources.insert(TypeId::of::\u003cR\u003e(), Box::new(res));\\n    }\\n}\\n\\nfn main() {\\n    let mut scheduler = Scheduler {\\n        systems: vec![],\\n        resources: HashMap::default(),\\n    };\\n\\n    scheduler.add_system(foo);\\n    scheduler.add_resource(12i32);\\n\\n    scheduler.run();\\n}\\n\\nfn foo(int: i32) {\\n    println!(\\\"int! {int}\\\");\\n}\\n\")), mdx(\"h1\", null, \"My Snake Clone\"), mdx(\"p\", null, \"Can be found \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/bebrws/bevy-snake\"\n  }, \"here\")), mdx(\"h1\", null, \"And Compiled to WASM and Played Here! (Only on WASM supported browsers - so no mobile)\"), mdx(React.Fragment, null, mdx(\"canvas\", {\n    id: \"bevy-portal\",\n    tabindex: \"0\",\n    \"data-raw-handle\": \"1\",\n    alt: \"app\",\n    cursor: \"auto\"\n  })));\n}\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"\u003cdiv style=\"position:relative\"\u003e\u003cspan style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\"\u003e#\u003c/span\u003e\u003ch1 id=\"Rust%20Practice%20with%20Bevy\" class=\"jsx-2373991563\"\u003e\u003ca href=\"#Rust%20Practice%20with%20Bevy\" class=\"jsx-2373991563\"\u003eRust Practice with Bevy\u003c/a\u003e\u003c/h1\u003e\u003c/div\u003e\u003cp\u003eBevy has an amazing dependency injection system that makes its \u0026quot;ECS\u0026quot; (Entity Component System) architecture very easy and ituitive to use.\nReally the DI system is one of the most amazing Rust feats that I have seen so far.\u003c/p\u003e\u003cp\u003eSomeone has taken the time to document how to create your own \u003ca href=\"https://promethia-27.github.io/dependency_injection_like_bevy_from_scratch/chapter1/system.html\"\u003eBevy based DI system here which is a great read\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThere is also an unofficial Bevy book that is really helpful \u003ca href=\"https://bevy-cheatbook.github.io/programming/intro-data.html\"\u003ehere\u003c/a\u003e\u003c/p\u003e\u003cdiv style=\"position:relative\"\u003e\u003cspan style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\"\u003e#\u003c/span\u003e\u003ch2 id=\"Bevy%20and%20ECS\" class=\"jsx-2373991563\"\u003e\u003ca href=\"#Bevy%20and%20ECS\" class=\"jsx-2373991563\"\u003eBevy and ECS\u003c/a\u003e\u003c/h2\u003e\u003c/div\u003e\u003cp\u003eECS is documented \u003ca href=\"https://bevyengine.org/learn/quick-start/getting-started/ecs/\"\u003ehere\u003c/a\u003e\nIt describes some of the basic concepts of how the Bevy game engine works. Combined with a powerful dependency injection (DI) system, Bevy is powerful, easy to work with, and fun to use.\u003c/p\u003e\u003cp\u003eFor my snake game I only needed the concept of three entities really: the snake, the food, and the snake\u0026#x27;s body.\u003c/p\u003e\u003cp\u003eThis is done by the C part of ECS. I create a Component for each. This allows me to, later on, using the DI/query system executed on each game loop, to find all the entities of a certain type and do something with them.\u003c/p\u003e\u003cp\u003eOn setup, I create the snake and the food using a spawn command. It takes a tuple where I can provide multiple Components that make up whatever entity I am creating.\u003c/p\u003e\u003cp\u003eEach of the described objects above have a visual aspect for example, so each have a 2D mesh (which includes a transform/translation aka location).\u003c/p\u003e\u003cp\u003eHere is where I create the SnakeHead for example:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e    let head_mesh = Mesh2dHandle(meshes.add(Rectangle::new(OBJECT_SIZE, OBJECT_SIZE)));\n    let box_color = Color::rgb(0.8, 0.2, 0.1);\n    commands.spawn((\n        MaterialMesh2dBundle {\n            mesh: head_mesh,\n            material: materials.add(box_color),\n            transform: Transform::from_translation(Vec3::new(0.0, 0.0, 0.0)),\n            ..default()\n        },\n        SnakeHead {\n            direction: Direction::Up,\n        },\n    ));\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe most amazing part of Bevy though that I have found so far is its \u0026quot;query\u0026quot;/DI system. With types and traits, I can query for all the entities of a certain type and do something with them each step of the game loop.\u003c/p\u003e\u003cp\u003eThis is the function signature I have for checking for collisions for ex:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efn check_collisions(\n    mut commands: Commands,\n    mut meshes: ResMut\u0026lt;Assets\u0026lt;Mesh\u0026gt;\u0026gt;,\n    mut materials: ResMut\u0026lt;Assets\u0026lt;ColorMaterial\u0026gt;\u0026gt;,\n    mut apple_query: Query\u0026lt;(\u0026amp;mut Transform), (With\u0026lt;Apple\u0026gt;, Without\u0026lt;SnakeHead\u0026gt;, Without\u0026lt;SnakeBody\u0026gt;)\u0026gt;,\n    mut snake_head_query: Query\u0026lt;(\u0026amp;mut Transform, \u0026amp;mut SnakeHead)\u0026gt;,\n    mut snake_body_query: Query\u0026lt;(\u0026amp;mut Transform, Entity), (With\u0026lt;SnakeBody\u0026gt;, Without\u0026lt;SnakeHead\u0026gt;)\u0026gt;,\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis function signature can be however long.\u003c/p\u003e\u003cp\u003eThe DI system will provide me with whatever objects I need. Commands, meshes, materials, etc.. As well as decipher a simple to work with type system to provide me with all the entities that match a specific query.\u003c/p\u003e\u003cp\u003eFor example, with the snake body. I want to be able to move each one and also remove them if the snake crashes. To move them I just need their Transform (part of what was provided from the MaterialMesh2dBundle during setup) and the Entity itself so I can send a command to despawn them or remove body parts from the game.\u003c/p\u003e\u003cp\u003eThe DI system that powers all this is amazing to me. I had no idea this could be accomplished in Rust until someone from the Bevy Discord chat kindly pointed me to this documentation which breaks down \u003ca href=\"https://promethia-27.github.io/dependency_injection_like_bevy_from_scratch/chapter1/system.html\"\u003ehow it all works\u003c/a\u003e.\u003c/p\u003e\u003cdiv style=\"position:relative\"\u003e\u003cspan style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\"\u003e#\u003c/span\u003e\u003ch2 id=\"Reading%20and%20Learning%20the%20Complicated%20Macros%20from%20the%20DI%20System%20Mentioned%20Above\" class=\"jsx-2373991563\"\u003e\u003ca href=\"#Reading%20and%20Learning%20the%20Complicated%20Macros%20from%20the%20DI%20System%20Mentioned%20Above\" class=\"jsx-2373991563\"\u003eReading and Learning the Complicated Macros from the DI System Mentioned Above\u003c/a\u003e\u003c/h2\u003e\u003c/div\u003e\u003cp\u003eIf you take the example from the end of page 3 in the DI like Bevy from Scratch book, you can use cargo expand to see what the macro is doing.\u003c/p\u003e\u003cp\u003eI created a new project and added the macro to the main.rs file. Then I ran cargo expand and it showed me the expanded macro created unsugared Rust code which made understanding the macros and the documentation much easier to understand.\u003c/p\u003e\u003cp\u003eTo install cargo expand run: \u003ccode\u003ecargo install cargo-expand\u003c/code\u003e\u003c/p\u003e\u003cp\u003eThe code I ran\n\u003ccode\u003ecargo expand \u0026gt; expanded.rs\u003c/code\u003e\non is:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003estruct FunctionSystem\u0026lt;Input, F\u0026gt; {\n    f: F,\n    marker: PhantomData\u0026lt;fn() -\u0026gt; Input\u0026gt;,\n}\n\ntrait System {\n    fn run(\u0026amp;mut self, resources: \u0026amp;mut HashMap\u0026lt;TypeId, Box\u0026lt;dyn Any\u0026gt;\u0026gt;);\n}\n\nmacro_rules! impl_system {\n    (\n        $(\n            $($params:ident),+\n        )?\n    ) =\u0026gt; {\n        #[allow(non_snake_case, unused)]\n        impl\u0026lt;\n            F: FnMut(\n                $( $($params),+ )?\n            )\n            $(, $($params: \u0026#x27;static),+ )?\n        \u0026gt; System for FunctionSystem\u0026lt;($( $($params,)+ )?), F\u0026gt; {\n            fn run(\u0026amp;mut self, resources: \u0026amp;mut HashMap\u0026lt;TypeId, Box\u0026lt;dyn Any\u0026gt;\u0026gt;) {\n                $($(\n                    let $params = *resources.remove(\u0026amp;TypeId::of::\u0026lt;$params\u0026gt;()).unwrap().downcast::\u0026lt;$params\u0026gt;().unwrap();\n                )+)?\n\n                (self.f)(\n                    $($($params),+)?\n                );\n            }\n        }\n    }\n}\n\nimpl_system!();\nimpl_system!(T1);\nimpl_system!(T1, T2);\nimpl_system!(T1, T2, T3);\nimpl_system!(T1, T2, T3, T4);\n\ntrait IntoSystem\u0026lt;Input\u0026gt; {\n    type System: System;\n\n    fn into_system(self) -\u0026gt; Self::System;\n}\n\nmacro_rules! impl_into_system {\n    (\n        $($(\n                $params:ident\n        ),+)?\n    ) =\u0026gt; {\n        impl\u0026lt;F: FnMut($($($params),+)?) $(, $($params: \u0026#x27;static),+ )?\u0026gt; IntoSystem\u0026lt;( $($($params,)+)? )\u0026gt; for F {\n            type System = FunctionSystem\u0026lt;( $($($params,)+)? ), Self\u0026gt;;\n\n            fn into_system(self) -\u0026gt; Self::System {\n                FunctionSystem {\n                    f: self,\n                    marker: Default::default(),\n                }\n            }\n        }\n    }\n}\n\nimpl_into_system!();\nimpl_into_system!(T1);\nimpl_into_system!(T1, T2);\nimpl_into_system!(T1, T2, T3);\nimpl_into_system!(T1, T2, T3, T4);\n\ntype StoredSystem = Box\u0026lt;dyn System\u0026gt;;\n\nstruct Scheduler {\n    systems: Vec\u0026lt;StoredSystem\u0026gt;,\n    resources: HashMap\u0026lt;TypeId, Box\u0026lt;dyn Any\u0026gt;\u0026gt;,\n}\n\nimpl Scheduler {\n    pub fn run(\u0026amp;mut self) {\n        for system in self.systems.iter_mut() {\n            system.run(\u0026amp;mut self.resources);\n        }\n    }\n\n    pub fn add_system\u0026lt;I, S: System + \u0026#x27;static\u0026gt;(\u0026amp;mut self, system: impl IntoSystem\u0026lt;I, System = S\u0026gt;) {\n        self.systems.push(Box::new(system.into_system()));\n    }\n\n    pub fn add_resource\u0026lt;R: \u0026#x27;static\u0026gt;(\u0026amp;mut self, res: R) {\n        self.resources.insert(TypeId::of::\u0026lt;R\u0026gt;(), Box::new(res));\n    }\n}\n\nfn main() {\n    let mut scheduler = Scheduler {\n        systems: vec![],\n        resources: HashMap::default(),\n    };\n\n    scheduler.add_system(foo);\n    scheduler.add_resource(12i32);\n\n    scheduler.run();\n}\n\nfn foo(int: i32) {\n    println!(\u0026quot;int! {int}\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cdiv style=\"position:relative\"\u003e\u003cspan style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\"\u003e#\u003c/span\u003e\u003ch1 id=\"My%20Snake%20Clone\" class=\"jsx-2373991563\"\u003e\u003ca href=\"#My%20Snake%20Clone\" class=\"jsx-2373991563\"\u003eMy Snake Clone\u003c/a\u003e\u003c/h1\u003e\u003c/div\u003e\u003cp\u003eCan be found \u003ca href=\"https://github.com/bebrws/bevy-snake\"\u003ehere\u003c/a\u003e\u003c/p\u003e\u003cdiv style=\"position:relative\"\u003e\u003cspan style=\"position:absolute;margin-left:-1.5em;font-weight:300;font-size:1.5rem;color:#9b9b9b\"\u003e#\u003c/span\u003e\u003ch1 id=\"And%20Compiled%20to%20WASM%20and%20Played%20Here%21%20%28Only%20on%20WASM%20supported%20browsers%20%2d%20so%20no%20mobile%29\" class=\"jsx-2373991563\"\u003e\u003ca href=\"#And%20Compiled%20to%20WASM%20and%20Played%20Here%21%20%28Only%20on%20WASM%20supported%20browsers%20%2d%20so%20no%20mobile%29\" class=\"jsx-2373991563\"\u003eAnd Compiled to WASM and Played Here! (Only on WASM supported browsers - so no mobile)\u003c/a\u003e\u003c/h1\u003e\u003c/div\u003e\u003ccanvas id=\"bevy-portal\" tabindex=\"0\" data-raw-handle=\"1\" alt=\"app\" cursor=\"auto\"\u003e\u003c/canvas\u003e","scope":{"slug":"bevy-snake","title":"Creating a Snake Game Clone with Rust/Bevy","date":"2024-02-19","author":"bebrws","tags":["Rust","bevy","WASM","WebAssembly","game"]}}},"__N_SSG":true},"page":"/posts/[post]","query":{"post":"bevy-snake"},"buildId":"ZiYYe9iDwc-NJSd5b0k2E","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>